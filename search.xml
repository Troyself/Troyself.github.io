<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>openmpi[0]-openmpi-img-parse</title>
      <link href="/2025/09/16/openmpi-0-openmpi-img-parse/"/>
      <url>/2025/09/16/openmpi-0-openmpi-img-parse/</url>
      
        <content type="html"><![CDATA[<!--<div align="center">-->  <!--<img src="" alt=""/>--><!--</div>--><ol class="series-items"><li><a href="/2025/09/16/openmpi-0-openmpi-img-parse/" title="openmpi[0]-openmpi-img-parse">openmpi[0]-openmpi-img-parse</a></li><li><a href="/2025/09/08/openmpi-1-what-is-openmpi/" title="openmpi[1] 什么是openmpi">openmpi[1] 什么是openmpi</a></li><li><a href="/2025/09/08/openmpi-2-modular-component-architecture/" title="openmpi[2] 模块化组件架构">openmpi[2] 模块化组件架构</a></li><li><a href="/2025/09/08/openmpi-3-btl-mca-self/" title="openmpi[3] btl框架的self组件分析">openmpi[3] btl框架的self组件分析</a></li></ol><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>Open MPI（Open 对称多处理器接口）是一个开源、高性能的 MPI（消息传递接口）实现。</p><p>核心概念解释：</p><ul><li>MPI (Message Passing Interface)：MPI 不是一个编程语言，而是一个标准或规范。它定义了一套用于并行计算的函数库，允许不同的进程（通常运行在不同的处理器或计算节点上）通过显式地发送和接收消息来相互通信和协作。你可以把它想象成一套并行程序之间进行交流的“语言规则”。</li><li>并行计算：指将一个大的计算任务分解成许多小任务，这些小任务可以同时（并行地）在多个处理器上执行，以缩短完成整个任务所需的时间。</li><li>实现 (Implementation)：MPI 本身只是一个标准，具体的编程库需要由不同的组织或公司去“实现”。Open MPI 就是众多 MPI 实现中的一个，其他著名的实现包括 MPICH、Intel MPI 等。</li></ul><p>简而言之，Open MPI 就是一个让你能用 MPI 标准来编写并行程序，并在各种计算集群和多核处理器上高效运行这些程序的工具箱。</p><p>MPI的编程方式，是“一处代码，多处执行”。编写过多线程的人应该能够理解，就是同样的代码，不同的进程执行不同的路径</p><p>OpenMPI的架构图如下所示(old)：</p><div align="center">  <img src="https://cdn.jsdelivr.net/gh/troyself/blog-img-bed//2025%2F09%2F22%2F20250922102157.png" alt="2025%2F09%2F22%2F20250922100058"/></div><p>自上向下依次为:</p><ul><li>OMPI(Open MPI)<ul><li>由MPI 标准定义的接口</li><li>暴露给上层的API接口，直接由应用程序调用</li></ul></li><li>ORTE(Open MPI Run-Time Environment) - 目前已经被PRRTE所取代，不过都是runtime的一层<ul><li>runtime system<ul><li>加载，监控进程，杀死独立的进程</li><li>重定向stdin, stdout, stderr</li></ul></li><li>ORTE 进程管理方式：在简单的环境中，通过rsh或ssh 来launch 进程。而复杂环境(HPC专用)会有shceduler、resource manager等管理组件，面向多个用户进行公平的调度以及资源分配，ORTE支持多种管理环境，例如，orque&#x2F;PBS Pro, SLURM, Oracle Grid Engine, and LSF.</li></ul></li><li>OPAL (Open, Portable Access Layer) (pronounced: o-pull): OPAL 是xOmpi的最底层,只作用于单个进程,负责不同环境的可移植性,包含了一些通用功能（例如链表、字符串操作、debug控制等等）.</li></ul><p>由于考虑到性能因素，Open MPI 有中“旁路”机制（bypass），ORTE以及OMPI层，可以绕过OPAL，直接与操作系统（甚至是硬件）进行交互.<br>例如OMPI会直接与网卡进行交互，从而达到最大的网络性能。这也就是为什么可以在架构图中看到，OMPI&#x2F;ORTE与操作系统有一个旁路接口。</p><p>但是，openmpi自从v4.0开始，已经将ORTE移出openmpi框架。改为3rd-party并重命名为PRRTE.</p><p>最新架构图如下：</p><div align="center">  <img src="https://cdn.jsdelivr.net/gh/troyself/blog-img-bed//2025%2F09%2F22%2F20250922102224.png" alt="2025%2F09%2F22%2F20250922100321"/></div><h2 id="MCA-Architecture"><a href="#MCA-Architecture" class="headerlink" title="MCA Architecture"></a>MCA Architecture</h2><p>为了在 Open MPI 中使用类似功能但是不同实现，Open MPI 设计一套被称为Modular Component Architecture (MCA)的架构.</p><p>MCA架构的核心思想是，允许用户通过配置文件来选择使用哪些组件，而不需要修改源代码。</p><p>Open MPI 项目的架构图如下所示：</p><div align="center">  <img src="https://cdn.jsdelivr.net/gh/troyself/blog-img-bed//2025%2F09%2F22%2F20250922102252.png" alt="2025%2F09%2F22%2F20250922100413"/></div><p>自顶向下依次为:</p><ul><li>Project: Project本质上是 Open MPI 代码库中最高抽象层的划分。但这里的Project可不是说的项目，而是指的Open MPI 代码库中主要的、顶层的代码部分<ul><li>OMPI</li><li>OPAL</li><li>OSHMEM: 提供对称堆分配器，支持不同类型的内存分配器;实现OpenSHMEM标准的通信原语，如put&#x2F;get操作等;管理OpenSHMEM程序的初始化、进程管理和资源协调.</li><li>… (maybe)</li></ul></li><li>Framework:<ul><li>BTL: 字节传输</li><li>coll: 集合操作</li><li>PML: 点对点传输</li><li>…</li></ul></li><li>Component:<ul><li>self: 进程与他自身通信</li><li>sm: 同一主机内的进程互相通信</li><li>tcp: 通过tcp与其他主机内的进程通信</li><li>…</li></ul></li><li>Module:<ul><li>eth0</li><li>eth1</li><li>…</li></ul></li></ul><h2 id="BTL-self-实现-同主机-同进程-不同线程通信"><a href="#BTL-self-实现-同主机-同进程-不同线程通信" class="headerlink" title="BTL&#x2F;self 实现: 同主机, 同进程, 不同线程通信"></a>BTL&#x2F;self 实现: 同主机, 同进程, 不同线程通信</h2><h3 id="component"><a href="#component" class="headerlink" title="component"></a>component</h3><div align="center">  <img src="https://cdn.jsdelivr.net/gh/troyself/blog-img-bed//2025%2F09%2F22%2F20250922102048.png" style="zoom:80%" alt="2025%2F09%2F22%2F20250922102048"/></div><p>在btl的component实现中，最首先实现的是component的register和init函数。</p><p>register函数向mca架构注册了mca参数，init函数完成了opal_freelist的init工作。</p><p>这里提到了一个新的数据结构:opal_freelist, 这是Open MPI中OPAL层的一个核心内存管理组件，用于高效管理可重用对象的内存池。基于LIFO(后进先出)的内存池实现，主要作用是：</p><ul><li>内存池管理：预分配固定大小的内存块，避免频繁的malloc&#x2F;free操作</li><li>对象重用：支持对象的快速分配和回收</li><li>内存对齐：支持指定的内存对齐要求</li><li>动态扩展：当内存池耗尽时可以自动增长</li></ul><p>当opal_freelist初始化时，每一个opal_freelist_item的内存结构图如下所示：</p><div align="center">  <img src="https://cdn.jsdelivr.net/gh/troyself/blog-img-bed//2025%2F09%2F22%2F20250922111949.png" style="zoom:50%" alt="2025%2F09%2F22%2F20250922111949"/></div><p>在最后还调用了一个add_procs函数，这个函数是为了判断当前进程是否可以用该组件(self)进行通信，这也是openmpi自动选择组件的核心支撑之一。</p><p>self组件这里的实现很简单，就是判断想要与本进程通信的是不是本进程，如果是本进程则标记可以通信, 否则拒绝通信，让openmpi选择其他组件。</p><p>其实add_procs也是下一个标题的ops的一部分，不过搬到这里来讲是因为笔者认为它们都属于”init”初始化工作的一部分。</p><h3 id="ops"><a href="#ops" class="headerlink" title="ops"></a>ops</h3><p>在btl框架下的组件，需要实现btl框架要求的ops:</p><ul><li>add_procs: 已经在上面解释过</li><li>del_procs: 删除process, 一般在finalize的时候调用，在self中直接返回成功</li><li>finalize: 在self中直接返回成功</li><li>alloc: 申请数据描述符函数(需要根据数据大小选择不同的数据描述符)</li><li>free: 释放数据描述符函数</li><li>prepare_src: 准备发送的数据</li><li>send: 将数据实际发送</li><li>sendi: prepare_src + send</li><li>put: rdma put函数</li><li>get: rdma get函数</li></ul><h4 id="send"><a href="#send" class="headerlink" title="send"></a>send</h4><div align="center">  <img src="https://cdn.jsdelivr.net/gh/troyself/blog-img-bed//2025%2F09%2F22%2F20250922112134.png" style="zoom:50%" alt="2025%2F09%2F22%2F20250922112134"/></div><p>在send时，从MPI Application逐层调用，最终到达btl层。</p><p>首先到达的并不会是send函数而是prepare_src函数，因为不是sendi这样的”原子操作”，所以数据准备发送是可以分开处理的。</p><p>在prepare_src函数中，先调用alloc函数申请数据描述符，然后判断是否为内联函数。</p><p>如果是内联函数，则直接将数据地址传递给数据描述符；否则通过iov将数据打包到数据描述符中的预申请buffer.</p><p>数据描述符的内存空间是在opal_freelist初始化的时候申请的，目的就是为了非内联发送的数据缓存。</p><p>之后在合适的时机调用到self的send函数。</p><p>self的send函数直接调用openmpi btl内部的接收回调函数，并将prepare_src时准备的数据描述符作为参数传递进去。</p><p>因为self是本进程与本进程通信，所有资源都是可以互相直接访问的，所以可以直接传递进去。</p><h4 id="recv"><a href="#recv" class="headerlink" title="recv"></a>recv</h4><p>在recv函数中，直接就可以从openmpi里面准备好的数据描述符拿到数据。</p><p>send &amp; recv完整流程图如下:</p><div align="center">  <img src="https://cdn.jsdelivr.net/gh/troyself/blog-img-bed//2025%2F09%2F22%2F20250922103343.png" alt="2025%2F09%2F22%2F20250922103343"/></div><h4 id="rdma-put-get"><a href="#rdma-put-get" class="headerlink" title="rdma: put&#x2F;get"></a>rdma: put&#x2F;get</h4><p>在self进程中的rdma put&#x2F;get操作，因为知道目标地址与源地址，所以就不需要那些麻烦的数据描述符。</p><p>而且是self进程间通信，所以rdma的put&#x2F;get操作可以直接通过memcpy完成。</p><p>rdma put&#x2F;get的流程图如下:</p><div align="center">  <img src="https://cdn.jsdelivr.net/gh/troyself/blog-img-bed//2025%2F09%2F22%2F20250922112610.png" alt="2025%2F09%2F22%2F20250922112610"/></div><h2 id="BTL-sm-实现-同主机-不同进程通信"><a href="#BTL-sm-实现-同主机-不同进程通信" class="headerlink" title="BTL&#x2F;sm 实现: 同主机, 不同进程通信"></a>BTL&#x2F;sm 实现: 同主机, 不同进程通信</h2><h3 id="component-1"><a href="#component-1" class="headerlink" title="component"></a>component</h3><p>sm的component流程与self类似，如下：</p><div align="center">  <img src="https://cdn.jsdelivr.net/gh/troyself/blog-img-bed//2025%2F09%2F22%2F20250922134932.png" style="zoom:30%" alt="2025%2F09%2F22%2F20250922134932"/></div><p>不过sm的component有许多细节需要解释。</p><h4 id="register"><a href="#register" class="headerlink" title="register"></a>register</h4><p>首先先注册自定义的mca参数到架构中，之后判断是否拥有&#x2F;dev&#x2F;shm目录。</p><p>如果有，则dir &#x3D; &#x2F;dev&#x2F;shm,否则dir &#x3D; OMPI session dir.</p><p>之后配置btl需要被传递的参数，这点与self一致。</p><p>具体框图：</p><div align="center">  <img src="https://cdn.jsdelivr.net/gh/troyself/blog-img-bed//2025%2F09%2F22%2F20250922135258.png" style="zoom:50%" alt="2025%2F09%2F22%2F20250922135258"/></div><h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><p>先检查用户所传递的自定义参数是否合法，之后判断是否具有SMSC。</p><p>SMSC是Linux实现的共享内存机制，可以跨进程共享数据，也是OMPI的sm组件里面实现single-copy的重要依赖。</p><p>如果支持SMSC的话就设置btl参数支持single-copy.</p><p>否则设置btl所需要的ops结构体中的rdma get&#x2F;put为NULL,表示不支持rdma操作(必须通过openmpi buffer中转).</p><p>之后根据register中赋值的dir变量创建共享内存文件，并将共享内存文件attach到my_segment变量中，让这个变量指向这段共享内存。</p><p>在my_segment这段共享内存中，需要注意的是FIFO数据结构占据了前128个bytes.</p><p>最后通过MODEX操作发送这个memory info到对等进程中，告诉他们:嘿，我的内存在这个位置。</p><p>这里是否还记得之前的框图，btl&#x2F;tcp组件有一个，但是有两个eth网口就有两个module.</p><p>这里如果通过sm进行通讯，则每一个进程就是一个module.</p><p>所以每个进程都有自己的共享内存区域。</p><p>具体框图如下:</p><div align="center">  <img src="https://cdn.jsdelivr.net/gh/troyself/blog-img-bed//2025%2F09%2F22%2F20250922135819.png" style="zoom:50%" alt="2025%2F09%2F22%2F20250922135819"/></div><h4 id="add-procs"><a href="#add-procs" class="headerlink" title="add_procs"></a>add_procs</h4><p>add_procs的过程是比self复杂很多的，因为设计到了ep(endpoint)的概念，此时内存不再是铁板一块，我们需要一种手段获取到对等进程的内存。</p><p>在add_procs中，会根据btl_inited变量来判断是否第一次初始化过，如果没有，就调用sm_btl_first_time_init()进行第一次初始化.</p><p>之后遍历所有进程，当进程的jobid与当前进程jobid相同并且属于local node的话，就会设置进程可见性。</p><p>在设置进程可见性后，通过init_sm_endpoint()初始化这个进程的ep.</p><p>具体框图如下:</p><div align="center">  <img src="https://cdn.jsdelivr.net/gh/troyself/blog-img-bed//2025%2F09%2F22%2F20250922135611.png" style="zoom:40%" alt="2025%2F09%2F22%2F20250922135611"/></div><h5 id="first-time-init"><a href="#first-time-init" class="headerlink" title="first_time_init"></a>first_time_init</h5><p>首先为endpoints数组动态分配内存(数组成员数量来自MCA_BTL_SM_NUM_LOCAL_PEERS),<br>之后给fbox_in_enpoints数组分配内存，数组成员数量如上。</p><p>之后创建内存池，内存池的内存空间由my_segment提供，my_segment变量在init的时候attach到了共享内存文件。</p><p>最后初始化free_list数据结构。</p><p>在初始化free_list的时候，流程与内存空间如下图所示：</p><div align="center">  <img src="https://cdn.jsdelivr.net/gh/troyself/blog-img-bed//2025%2F09%2F22%2F20250922151616.png" style="zoom:50%" alt="2025%2F09%2F22%2F20250922151616"/></div><p>具体框图如下:</p><div align="center">  <img src="https://cdn.jsdelivr.net/gh/troyself/blog-img-bed//2025%2F09%2F22%2F20250922151706.png" style="zoom:50%" alt="2025%2F09%2F22%2F20250922151706"/></div><h5 id="init-sm-endpoint"><a href="#init-sm-endpoint" class="headerlink" title="init_sm_endpoint"></a>init_sm_endpoint</h5><p>该函数会先通过modex拿到对等进程的信息，如果对等进程是本进程的话，那么ep-&gt;segment_base &#x3D; my_segment;否则的话则通过modex拿到对等进程的内存信息，将ep-&gt;segment_base attach到对等进程的共享内存。</p><p>具体框图如下:</p><div align="center">  <img src="https://cdn.jsdelivr.net/gh/troyself/blog-img-bed//2025%2F09%2F22%2F20250922153242.png" style="zoom:50%" alt="2025%2F09%2F22%2F20250922153242"/></div><h4 id="component完整框图"><a href="#component完整框图" class="headerlink" title="component完整框图"></a>component完整框图</h4><div align="center">  <img src="https://cdn.jsdelivr.net/gh/troyself/blog-img-bed//2025%2F09%2F22%2F20250922134837.png" alt="2025%2F09%2F22%2F20250922134837"/></div><h3 id="send-1"><a href="#send-1" class="headerlink" title="send"></a>send</h3><p>send的调用链与self相同，唯一不同的就是prepare_src和send函数的实现。</p><h4 id="prepare-src"><a href="#prepare-src" class="headerlink" title="prepare_src"></a>prepare_src</h4><p>在prepare_src函数中，首先申请数据描述符。</p><p>在拿到数据描述符后，判断是否为内联发送(数据不在设备上并且是连续的内存空间)。</p><p>如果是内联发送，则判断是否具有SMSC(共享内存功能),如果有的话，则直接将地址写入数据描述符（single-copy);如果没有的话，则memcpy到到数据描述符中的预留空间。</p><p>如果不是内联发送，则通过covertor_pack函数将数据打包到数据描述符中的预留空间。</p><p>具体框图如下:</p><div align="center">  <img src="https://cdn.jsdelivr.net/gh/troyself/blog-img-bed//2025%2F09%2F22%2F20250922154056.png" alt="2025%2F09%2F22%2F20250922154056"/></div><h4 id="send-2"><a href="#send-2" class="headerlink" title="send"></a>send</h4><p>在send函数中，不能像self一样直接简单的调用openmpi内部的接收回调函数，需要实际发送。</p><p>首先设置hdr标志位，之后判断是否fastbox发送。</p><p>如果是fastbox发送，则直接通过fastbox发送。</p><p>如果不是fastbox发送，则通过sm实现的lock-free的FIFO进行发送。</p><p>之后判断是否发送成功，如果不成功，则将该数据描述符放到pending_list中。</p><p>等待合适的时机取出。</p><p>具体框图如下:</p><div align="center">  <img src="https://cdn.jsdelivr.net/gh/troyself/blog-img-bed//2025%2F09%2F22%2F20250922154113.png" alt="2025%2F09%2F22%2F20250922154113"/></div><h4 id="send完整框图"><a href="#send完整框图" class="headerlink" title="send完整框图"></a>send完整框图</h4><div align="center">  <img src="https://cdn.jsdelivr.net/gh/troyself/blog-img-bed//2025%2F09%2F22%2F20250922153900.png" alt="2025%2F09%2F22%2F20250922153900"/></div><h3 id="recv-1"><a href="#recv-1" class="headerlink" title="recv"></a>recv</h3><p>recv的流程与self更是大相径庭，因为之前的self的recv只需要从ompi框架拿数据就可以了。</p><p>但是sm的recv需要来读取数据是否发送完成等操作，所以在component::ops里面引入了btl_progress()。</p><p>但是recv的调用链与self是相同的。</p><h4 id="progress"><a href="#progress" class="headerlink" title="progress"></a>progress</h4><p>在progress函数中，首先检查fastbox是否有数据需要处理，如果有，则处理.</p><p>之后检查是否有数据描述符挂到了pending_list中，如果有，则尝试将他们写入真正的FIFO中。</p><p>在这里再次失败了也没关系，失败的话就不会从pending_list中拿出，下次recv的时候依然会尝试再次写入。</p><p>在最后调用poll_fifo来检查fifo。</p><p>具体框图如下:</p><div align="center">  <img src="https://cdn.jsdelivr.net/gh/troyself/blog-img-bed//2025%2F09%2F22%2F20250922155248.png" style="zoom:50%" alt="2025%2F09%2F22%2F20250922155248"/></div><h5 id="poll-fifo"><a href="#poll-fifo" class="headerlink" title="poll_fifo"></a>poll_fifo</h5><p>在poll_fifo中，是一个31次的循环读fifo，这个值我并不清楚具体含义，可能是性能和效率的权衡。</p><p>在循环中，读取fifo,如果失败则返回。</p><p>如果读取fifo成功，则判断是否是一个已经完成的fifo，如果是的话调用数据描述符的回调函数。</p><p>如果不是已经完成的fifo,则判断是否为single-copy.</p><p>如果是single-copy,则映射endpoint的共享内存到本地。</p><p>如果不是，直接执行recv的回调函数。</p><p>之后将读取的这个fifo设置complete标志位，再回写到ep的fifo中。</p><p>具体框图如下:</p><div align="center">  <img src="https://cdn.jsdelivr.net/gh/troyself/blog-img-bed//2025%2F09%2F22%2F20250922155744.png" style="zoom:50%" alt="2025%2F09%2F22%2F20250922155744"/></div><h4 id="recv完整框图"><a href="#recv完整框图" class="headerlink" title="recv完整框图"></a>recv完整框图</h4><div align="center">  <img src="https://cdn.jsdelivr.net/gh/troyself/blog-img-bed//2025%2F09%2F22%2F20250922154754.png" alt="2025%2F09%2F22%2F20250922154754"/></div>]]></content>
      
      
      <categories>
          
          <category> openmpi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openmpi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openmpi[3] btl框架的self组件分析</title>
      <link href="/2025/09/08/openmpi-3-btl-mca-self/"/>
      <url>/2025/09/08/openmpi-3-btl-mca-self/</url>
      
        <content type="html"><![CDATA[<ol class="series-items"><li><a href="/2025/09/16/openmpi-0-openmpi-img-parse/" title="openmpi[0]-openmpi-img-parse">openmpi[0]-openmpi-img-parse</a></li><li><a href="/2025/09/08/openmpi-1-what-is-openmpi/" title="openmpi[1] 什么是openmpi">openmpi[1] 什么是openmpi</a></li><li><a href="/2025/09/08/openmpi-2-modular-component-architecture/" title="openmpi[2] 模块化组件架构">openmpi[2] 模块化组件架构</a></li><li><a href="/2025/09/08/openmpi-3-btl-mca-self/" title="openmpi[3] btl框架的self组件分析">openmpi[3] btl框架的self组件分析</a></li></ol><p>在openmpi[2]中，已经分析了openmpi的模块化架构。对于本章节来说，上一章提到的framework对应的是btl;component对应的就是self; mca的意思就是mca模块🤣</p><h2 id="self组件的分层"><a href="#self组件的分层" class="headerlink" title="self组件的分层"></a>self组件的分层</h2><p>在opal&#x2F;mca&#x2F;btl&#x2F;self目录中，可以看到如下文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ tree</span><br><span class="line">.</span><br><span class="line">├── btl_self.c</span><br><span class="line">├── btl_self_component.c</span><br><span class="line">├── btl_self_component.lo</span><br><span class="line">├── btl_self_frag.c</span><br><span class="line">├── btl_self_frag.h</span><br><span class="line">├── btl_self_frag.lo</span><br><span class="line">├── btl_self.h</span><br><span class="line">├── btl_self.lo</span><br><span class="line">├── libmca_btl_self.la</span><br><span class="line">├── Makefile</span><br><span class="line">├── Makefile.am</span><br><span class="line">├── Makefile.<span class="keyword">in</span></span><br><span class="line">└── owner.txt</span><br></pre></td></tr></table></figure><p>除去不需要关心的编译相关和注释相关，我们剩下了这三个内容：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ tree</span><br><span class="line">.</span><br><span class="line">├── btl_self.c</span><br><span class="line">├── btl_self_component.c</span><br><span class="line">├── btl_self_frag.c</span><br><span class="line">├── btl_self_frag.h</span><br></pre></td></tr></table></figure><ul><li>btl_frag: 与传输相关</li><li>btl_self_component: 组件初始化及注册</li><li>btl_self: 提供ops函数</li></ul><h2 id="component"><a href="#component" class="headerlink" title="component"></a>component</h2><p>在btl_self_component.c中，一共包含了四个函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mca_btl_self_component_register</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mca_btl_self_component_open</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mca_btl_self_component_close</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SELF module initialization.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param num_btls (OUT)                  Number of BTLs returned in BTL array.</span></span><br><span class="line"><span class="comment"> * @param enable_progress_threads (IN)    Flag indicating whether BTL is allowed to have progress</span></span><br><span class="line"><span class="comment"> * threads</span></span><br><span class="line"><span class="comment"> * @param enable_mpi_threads (IN)         Flag indicating whether BTL must support multilple</span></span><br><span class="line"><span class="comment"> * simultaneous invocations from different threads</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">mca_btl_base_module_t</span> **</span><br><span class="line"><span class="title function_">mca_btl_self_component_init</span><span class="params">(<span class="type">int</span> *num_btls, <span class="type">bool</span> enable_progress_threads, <span class="type">bool</span> enable_mpi_threads)</span>;</span><br></pre></td></tr></table></figure><h3 id="调用顺序和关系"><a href="#调用顺序和关系" class="headerlink" title="调用顺序和关系"></a>调用顺序和关系</h3><p>这四个函数在 Open MPI 启动过程中按照特定顺序被 MCA 框架调用：</p><p>register → open → init → close</p><h4 id="register"><a href="#register" class="headerlink" title="register"></a>register</h4><p>调用时机：MCA 框架加载组件时最先调用，用于注册组件参数。</p><p>主要职责：</p><p>注册组件到 MCA 变量系统<br>设置 free list 相关参数（free_list_num、free_list_max、free_list_inc）<br>配置 BTL 模块的性能参数（带宽、延迟、消息大小限制等）<br>设置 BTL 功能标志（RDMA、就地发送等）</p><h4 id="open"><a href="#open" class="headerlink" title="open"></a>open</h4><p>调用时机：参数注册完成后，在组件初始化之前调用。</p><p>主要职责：</p><p>构造三个 opal_free_list_t 对象（eager、send、rdma fragments）<br>为后续的内存池初始化做准备<br>不进行实际的内存分配，只是对象构造</p><h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><p>调用时机：组件打开后，当 BTL 框架需要实际创建 BTL 模块时调用。</p><p>主要职责：</p><p>初始化三个 free list，分配实际内存池<br>为不同类型的 fragment 设置不同的大小和对齐要求<br>创建并返回 BTL 模块数组给上层使用<br>这是唯一返回实际可用 BTL 模块的函数</p><h4 id="close"><a href="#close" class="headerlink" title="close"></a>close</h4><p>调用时机：程序结束或组件卸载时调用，用于清理资源。</p><p>主要职责：</p><p>析构三个 opal_free_list_t 对象<br>释放在 open 阶段分配的资源<br>确保没有内存泄漏</p><h3 id="关于构造的引入"><a href="#关于构造的引入" class="headerlink" title="关于构造的引入"></a>关于构造的引入</h3><p>在open&#x2F;close中第一次见到了面向对象的真容</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mca_btl_self_component_open</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* initialize objects */</span></span><br><span class="line">    OBJ_CONSTRUCT(&amp;mca_btl_self_component.self_frags_eager, <span class="type">opal_free_list_t</span>);</span><br><span class="line">    OBJ_CONSTRUCT(&amp;mca_btl_self_component.self_frags_send, <span class="type">opal_free_list_t</span>);</span><br><span class="line">    OBJ_CONSTRUCT(&amp;mca_btl_self_component.self_frags_rdma, <span class="type">opal_free_list_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OPAL_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * component cleanup - sanity checking of queue lengths</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mca_btl_self_component_close</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    OBJ_DESTRUCT(&amp;mca_btl_self_component.self_frags_eager);</span><br><span class="line">    OBJ_DESTRUCT(&amp;mca_btl_self_component.self_frags_send);</span><br><span class="line">    OBJ_DESTRUCT(&amp;mca_btl_self_component.self_frags_rdma);</span><br><span class="line">    <span class="keyword">return</span> OPAL_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先来看open函数中对opal_free_list_t这个类的构造宏是如何构成的:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_CONSTRUCT(object, type)                        \</span></span><br><span class="line"><span class="meta">    do &#123;                                                   \</span></span><br><span class="line"><span class="meta">        OBJ_CONSTRUCT_INTERNAL((object), OBJ_CLASS(type)); \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_CONSTRUCT_INTERNAL(object, type)                      \</span></span><br><span class="line"><span class="meta">    do &#123;                                                          \</span></span><br><span class="line"><span class="meta">        OBJ_SET_MAGIC_ID((object), OPAL_OBJ_MAGIC_ID);            \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (opal_class_init_epoch != (type)-&gt;cls_initialized) &#123;   \</span></span><br><span class="line"><span class="meta">            opal_class_initialize((type));                        \</span></span><br><span class="line"><span class="meta">        &#125;                                                         \</span></span><br><span class="line"><span class="meta">        ((opal_object_t *) (object))-&gt;obj_class = (type);         \</span></span><br><span class="line"><span class="meta">        ((opal_object_t *) (object))-&gt;obj_reference_count = 1;    \</span></span><br><span class="line"><span class="meta">        opal_obj_run_constructors((opal_object_t *) (object));    \</span></span><br><span class="line"><span class="meta">        OBJ_REMEMBER_FILE_AND_LINENO(object, __FILE__, __LINE__); \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br></pre></td></tr></table></figure><p>OBJ_CONSTRUCT本质上就是调用OBJ_CONSTRUCT_INTERNAL.</p><p>在OBJ_CONSTRUCT_INTERNAL里面，先设置一个MAGIC_ID(如果没使能DEBUG的话，这就是nop)</p><p>之后来判断世代计数器，这里笔者也没有细究代码，不过来看是opal这个子系统初始化或者释放资源的时候会重新设置这个epoch的变量。在opal_class_initialize里面会初始化opal的class系统，然后设置epoch变量。</p><p>根据opal_class_initialize的注释也能看出:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lazy initialization of class descriptor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">opal_class_initialize</span><span class="params">(<span class="type">opal_class_t</span> *cls)</span></span><br></pre></td></tr></table></figure><p>思考：这里会带来空间占用的问题，如果调用OBJ_CONSTRUCT_INTERNAL的函数多了，这点懒加载带来的性能改变是否真的值得用这么多空间换吗？</p><p>即答: 几十KB而已🤣</p><p>之后会调用opal_obj_run_constructors函数来运行构造函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Run the hierarchy of class constructors for this object, in a</span></span><br><span class="line"><span class="comment"> * parent-first order.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Do not use this function directly: use OBJ_CONSTRUCT() instead.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WARNING: This implementation relies on a hardwired maximum depth of</span></span><br><span class="line"><span class="comment"> * the inheritance tree!!!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Hardwired for fairly shallow inheritance trees</span></span><br><span class="line"><span class="comment"> * @param size          Pointer to the object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">opal_obj_run_constructors</span><span class="params">(<span class="type">opal_object_t</span> *object)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">opal_construct_t</span> *cls_construct;</span><br><span class="line"></span><br><span class="line">    assert(<span class="literal">NULL</span> != object-&gt;obj_class);</span><br><span class="line"></span><br><span class="line">    cls_construct = object-&gt;obj_class-&gt;cls_construct_array;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span> != *cls_construct) &#123;</span><br><span class="line">        (*cls_construct)(object);</span><br><span class="line">        cls_construct++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="frag"><a href="#frag" class="headerlink" title="frag"></a>frag</h2><p>frag.c这个文件是为了抽象出self这个组件的传输相关内容。</p><p>根据self的源码来看，mca_btl_base_descriptor_t是btl进行传输的基础描述符。</p><p>frag相当于在这个基础描述符上增加了一些东西。</p><p>frag定义如下:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * shared memory send fragment derived type.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mca_btl_self_frag_t</span> &#123;</span></span><br><span class="line">    <span class="type">mca_btl_base_descriptor_t</span> base;</span><br><span class="line">    <span class="type">mca_btl_base_segment_t</span> segments[<span class="number">2</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mca_btl_base_endpoint_t</span> *<span class="title">endpoint</span>;</span></span><br><span class="line">    <span class="type">opal_free_list_t</span> *<span class="built_in">list</span>;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mca_btl_self_frag_t</span> <span class="title">mca_btl_self_frag_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mca_btl_self_frag_t</span> <span class="title">mca_btl_self_frag_eager_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mca_btl_self_frag_t</span> <span class="title">mca_btl_self_frag_send_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mca_btl_self_frag_t</span> <span class="title">mca_btl_self_frag_rdma_t</span>;</span></span><br></pre></td></tr></table></figure><p>由于openmpi采用了面向对象的思想，所以base这里可以看作是frag的父对象。</p><p><strong>segment</strong></p><p>这里面有一个segment需要额外注意，另外一个endpoint在self这个组件中没有用到。</p><p>segment定义如下:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Describes a region/segment of memory that is addressable</span></span><br><span class="line"><span class="comment"> * by an BTL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: In many cases the alloc and prepare methods of BTLs</span></span><br><span class="line"><span class="comment"> * do not return a mca_btl_base_segment_t but instead return a</span></span><br><span class="line"><span class="comment"> * subclass. Extreme care should be used when modifying</span></span><br><span class="line"><span class="comment"> * BTL segments to prevent overwriting internal BTL data.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * All BTLs MUST use base segments when calling registered</span></span><br><span class="line"><span class="comment"> * Callbacks.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * BTL MUST use mca_btl_base_segment_t or a subclass and</span></span><br><span class="line"><span class="comment"> * MUST store their segment length in btl_seg_size. BTLs</span></span><br><span class="line"><span class="comment"> * MUST specify a segment no larger than MCA_BTL_SEG_MAX_SIZE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mca_btl_base_segment_t</span> &#123;</span></span><br><span class="line">    <span class="comment">/** Address of the memory */</span></span><br><span class="line">    <span class="type">opal_ptr_t</span> seg_addr;</span><br><span class="line">    <span class="comment">/** Length in bytes */</span></span><br><span class="line">    <span class="type">uint64_t</span> seg_len;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mca_btl_base_segment_t</span> <span class="title">mca_btl_base_segment_t</span>;</span></span><br></pre></td></tr></table></figure><p>每个 segment 包含两个关键字段：</p><ul><li>seg_addr：指向数据的内存地址</li><li>seg_len：数据段的长度</li></ul><p>frag这里又用到了我们在component中提到的类思想,在btl_self_frag.c中实现了类的构造函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">mca_btl_self_frag_constructor</span><span class="params">(<span class="type">mca_btl_self_frag_t</span> *frag)</span></span><br><span class="line">&#123;</span><br><span class="line">    frag-&gt;base.des_flags = <span class="number">0</span>;</span><br><span class="line">    frag-&gt;segments[<span class="number">0</span>].seg_addr.pval = (<span class="type">void</span> *) frag-&gt;data;</span><br><span class="line">    frag-&gt;segments[<span class="number">0</span>].seg_len = (<span class="type">uint32_t</span>) frag-&gt;size;</span><br><span class="line">    frag-&gt;base.des_segments = frag-&gt;segments;</span><br><span class="line">    frag-&gt;base.des_segment_count = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mca_btl_self_frag_eager_constructor</span><span class="params">(<span class="type">mca_btl_self_frag_t</span> *frag)</span></span><br><span class="line">&#123;</span><br><span class="line">    frag-&gt;<span class="built_in">list</span> = &amp;mca_btl_self_component.self_frags_eager;</span><br><span class="line">    frag-&gt;size = mca_btl_self.btl_eager_limit;</span><br><span class="line">    mca_btl_self_frag_constructor(frag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mca_btl_self_frag_send_constructor</span><span class="params">(<span class="type">mca_btl_self_frag_t</span> *frag)</span></span><br><span class="line">&#123;</span><br><span class="line">    frag-&gt;<span class="built_in">list</span> = &amp;mca_btl_self_component.self_frags_send;</span><br><span class="line">    frag-&gt;size = mca_btl_self.btl_max_send_size;</span><br><span class="line">    mca_btl_self_frag_constructor(frag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mca_btl_self_frag_rdma_constructor</span><span class="params">(<span class="type">mca_btl_self_frag_t</span> *frag)</span></span><br><span class="line">&#123;</span><br><span class="line">    frag-&gt;<span class="built_in">list</span> = &amp;mca_btl_self_component.self_frags_rdma;</span><br><span class="line">    frag-&gt;size = MCA_BTL_SELF_MAX_INLINE_SIZE;</span><br><span class="line">    mca_btl_self_frag_constructor(frag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OBJ_CLASS_INSTANCE(<span class="type">mca_btl_self_frag_eager_t</span>, <span class="type">mca_btl_base_descriptor_t</span>,</span><br><span class="line">                   mca_btl_self_frag_eager_constructor, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">OBJ_CLASS_INSTANCE(<span class="type">mca_btl_self_frag_send_t</span>, <span class="type">mca_btl_base_descriptor_t</span>,</span><br><span class="line">                   mca_btl_self_frag_send_constructor, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">OBJ_CLASS_INSTANCE(<span class="type">mca_btl_self_frag_rdma_t</span>, <span class="type">mca_btl_base_descriptor_t</span>,</span><br><span class="line">                   mca_btl_self_frag_rdma_constructor, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>OBJ_CLASS_INSTANCE宏是定义类的实例，具体定义如下:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Static initializer for a class descriptor</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param NAME          Name of class</span></span><br><span class="line"><span class="comment"> * @param PARENT        Name of parent class</span></span><br><span class="line"><span class="comment"> * @param CONSTRUCTOR   Pointer to constructor</span></span><br><span class="line"><span class="comment"> * @param DESTRUCTOR    Pointer to destructor</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Put this in NAME.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_CLASS_INSTANCE(NAME, PARENT, CONSTRUCTOR, DESTRUCTOR) \</span></span><br><span class="line"><span class="meta">    opal_class_t NAME##_class = &#123;#NAME,                           \</span></span><br><span class="line"><span class="meta">                                 OBJ_CLASS(PARENT),               \</span></span><br><span class="line"><span class="meta">                                 (opal_construct_t) CONSTRUCTOR,  \</span></span><br><span class="line"><span class="meta">                                 (opal_destruct_t) DESTRUCTOR,    \</span></span><br><span class="line"><span class="meta">                                 0,                               \</span></span><br><span class="line"><span class="meta">                                 0,                               \</span></span><br><span class="line"><span class="meta">                                 NULL,                            \</span></span><br><span class="line"><span class="meta">                                 NULL,                            \</span></span><br><span class="line"><span class="meta">                                 sizeof(NAME)&#125;</span></span><br></pre></td></tr></table></figure><p>拿frag_eager举例，frag_eager的定义在.h文件中为:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * shared memory send fragment derived type.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mca_btl_self_frag_t</span> &#123;</span></span><br><span class="line">    <span class="type">mca_btl_base_descriptor_t</span> base;</span><br><span class="line">    <span class="type">mca_btl_base_segment_t</span> segments[<span class="number">2</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mca_btl_base_endpoint_t</span> *<span class="title">endpoint</span>;</span></span><br><span class="line">    <span class="type">opal_free_list_t</span> *<span class="built_in">list</span>;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mca_btl_self_frag_t</span> <span class="title">mca_btl_self_frag_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mca_btl_self_frag_t</span> <span class="title">mca_btl_self_frag_eager_t</span>;</span></span><br></pre></td></tr></table></figure><p>可以看到frag_eager就是frag的alias而已，最终会被OBJ_CLASS_INSTANCE定义为mca_btl_self_frag_rdma_t_class的一个结构体，父对象是base也就是mca_btl_base_descriptor_t.</p><p>这很合理，因为frag结构体第一个成员就是base, 在openmpi中估计会通过强制类型转换来拿到父对象。</p><p>这里注意，并没有析构函数，这是因为并没有什么动态申请的资源好释放的。</p><p>在frag.h文件中进行了类的声明：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">OBJ_CLASS_DECLARATION(<span class="type">mca_btl_self_frag_eager_t</span>);</span><br><span class="line">OBJ_CLASS_DECLARATION(<span class="type">mca_btl_self_frag_send_t</span>);</span><br><span class="line">OBJ_CLASS_DECLARATION(<span class="type">mca_btl_self_frag_rdma_t</span>);</span><br></pre></td></tr></table></figure><p>OBJ_CLASS_DECLARATION的定义如下:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Declaration for class descriptor</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param NAME          Name of class</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Put this in NAME.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_CLASS_DECLARATION(NAME) extern opal_class_t NAME##_class</span></span><br></pre></td></tr></table></figure><p>继续拿frag_eager举例，其实就是extern mca_btl_self_frag_rdma_t_class这个结构体变量。</p><p>以便能够在其他文件中访问。这里openmpi框架会做好互斥访问的。</p><p>但是翻遍了self的源码树，也没发现在component里面显示调用的OBJ_CONSTRUCT宏，也就是没地方进入frag的构造函数。别急，接下来进入opal_free_list的“魔法”（其实就是隐藏在api里面了）</p><h2 id="opal-free-list"><a href="#opal-free-list" class="headerlink" title="opal_free_list"></a>opal_free_list</h2><p>opal_free_list 是 Open MPI 中的一个高效内存管理机制，用于预分配和重用固定大小的内存块。</p><p>它基于 LIFO (Last-In-First-Out) 原理，提供快速的内存分配和释放操作。</p><p>在component的init函数中，我们实际初始化了opal_free_list, 是通过opal_free_list_init函数实现的。</p><p>opal_free_list_init函数定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize a free list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param free_list                (IN)  Free list.</span></span><br><span class="line"><span class="comment"> * @param frag_size                (IN)  Size of each element - allocated by malloc.</span></span><br><span class="line"><span class="comment"> * @param frag_alignment           (IN)  Fragment alignment.</span></span><br><span class="line"><span class="comment"> * @param frag_class               (IN)  opal_class_t of element - used to initialize allocated</span></span><br><span class="line"><span class="comment"> * elements.</span></span><br><span class="line"><span class="comment"> * @param payload_buffer_size      (IN)  Size of payload buffer - allocated from mpool.</span></span><br><span class="line"><span class="comment"> * @param payload_buffer_alignment (IN)  Payload buffer alignment.</span></span><br><span class="line"><span class="comment"> * @param num_elements_to_alloc    (IN)  Initial number of elements to allocate.</span></span><br><span class="line"><span class="comment"> * @param max_elements_to_alloc    (IN)  Maximum number of elements to allocate.</span></span><br><span class="line"><span class="comment"> * @param num_elements_per_alloc   (IN)  Number of elements to grow by per allocation.</span></span><br><span class="line"><span class="comment"> * @param mpool                    (IN)  Optional memory pool for allocations.</span></span><br><span class="line"><span class="comment"> * @param rcache_reg_flags         (IN)  Flags to pass to rcache registration function.</span></span><br><span class="line"><span class="comment"> * @param rcache                   (IN)  Optional registration cache.</span></span><br><span class="line"><span class="comment"> * @param item_init                (IN)  Optional item initialization function</span></span><br><span class="line"><span class="comment"> * @param ctx                      (IN)  Initialization function context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">OPAL_DECLSPEC <span class="type">int</span> <span class="title function_">opal_free_list_init</span><span class="params">(<span class="type">opal_free_list_t</span> *free_list, <span class="type">size_t</span> frag_size,</span></span><br><span class="line"><span class="params">                                      <span class="type">size_t</span> frag_alignment, <span class="type">opal_class_t</span> *frag_class,</span></span><br><span class="line"><span class="params">                                      <span class="type">size_t</span> payload_buffer_size, <span class="type">size_t</span> payload_buffer_alignment,</span></span><br><span class="line"><span class="params">                                      <span class="type">int</span> num_elements_to_alloc, <span class="type">int</span> max_elements_to_alloc,</span></span><br><span class="line"><span class="params">                                      <span class="type">int</span> num_elements_per_alloc,</span></span><br><span class="line"><span class="params">                                      <span class="keyword">struct</span> <span class="type">mca_mpool_base_module_t</span> *mpool, <span class="type">int</span> rcache_reg_flags,</span></span><br><span class="line"><span class="params">                                      <span class="keyword">struct</span> <span class="type">mca_rcache_base_module_t</span> *rcache,</span></span><br><span class="line"><span class="params">                                      <span class="type">opal_free_list_item_init_fn_t</span> item_init, <span class="type">void</span> *ctx)</span>;</span><br></pre></td></tr></table></figure><p>这里函数参数比较复杂，我们逐个分析：</p><ul><li>核心参数<ul><li>frag_size：每个元素的大小，通过 malloc 分配</li><li>frag_alignment：Fragment 的内存对齐要求</li><li>frag_class：用于初始化分配元素的 opal_class_t 类型</li><li>payload_buffer_size：负载缓冲区大小，从 mpool 分配</li><li>payload_buffer_alignment：负载缓冲区的对齐要求</li></ul></li><li>分配控制参数<ul><li>num_elements_to_alloc：初始分配的元素数量</li><li>max_elements_to_alloc：最大可分配的元素数量</li><li>num_elements_per_alloc：每次增长时分配的元素数量</li></ul></li><li>高级参数<ul><li>mpool：可选的内存池，用于分配</li><li>rcache_reg_flags：传递给 rcache 注册函数的标志</li><li>rcache：可选的注册缓存</li><li>item_init：可选的元素初始化函数</li><li>ctx：初始化函数的上下文</li></ul></li></ul><p>回到component的调用中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ret = opal_free_list_init(&amp;mca_btl_self_component.self_frags_eager,</span><br><span class="line">                          <span class="keyword">sizeof</span>(<span class="type">mca_btl_self_frag_eager_t</span>) + mca_btl_self.btl_eager_limit,</span><br><span class="line">                          opal_cache_line_size, OBJ_CLASS(<span class="type">mca_btl_self_frag_eager_t</span>), <span class="number">0</span>,</span><br><span class="line">                          opal_cache_line_size, mca_btl_self_component.free_list_num,</span><br><span class="line">                          mca_btl_self_component.free_list_max,</span><br><span class="line">                          mca_btl_self_component.free_list_inc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>可以看到frag_size为frag_eager的大小 + eager_limit的大小，这是为什么呢？</p><p>在frag的定义中最后一个成员是<code>unsigned char data[];</code>, 所以这eager_limit是为这个data申请的内存。</p><p>另一个需要关心的内容是frag_class参数，这里直接调用了<code>OBJ_CLASS(mca_btl_self_frag_eager_t)</code>,这个宏在上面已经说过了。</p><h3 id="opal-free-list实现携带类的析构"><a href="#opal-free-list实现携带类的析构" class="headerlink" title="opal_free_list实现携带类的析构"></a>opal_free_list实现携带类的析构</h3><p>opal_free_list只是一个数据结构，需要实现真正数据交互还需要携带一个类。</p><p>携带类指的就是这个意思。</p><p>在opal_free_list_init函数中会调用 opal_free_list_grow_st函数</p><h4 id="opal-free-list-init"><a href="#opal-free-list-init" class="headerlink" title="opal_free_list_init"></a>opal_free_list_init</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">opal_free_list_init</span><span class="params">(<span class="type">opal_free_list_t</span> *flist, <span class="type">size_t</span> frag_size, <span class="type">size_t</span> frag_alignment,</span></span><br><span class="line"><span class="params">                        <span class="type">opal_class_t</span> *frag_class, <span class="type">size_t</span> payload_buffer_size,</span></span><br><span class="line"><span class="params">                        <span class="type">size_t</span> payload_buffer_alignment, <span class="type">int</span> num_elements_to_alloc,</span></span><br><span class="line"><span class="params">                        <span class="type">int</span> max_elements_to_alloc, <span class="type">int</span> num_elements_per_alloc,</span></span><br><span class="line"><span class="params">                        <span class="type">mca_mpool_base_module_t</span> *mpool, <span class="type">int</span> rcache_reg_flags,</span></span><br><span class="line"><span class="params">                        <span class="type">mca_rcache_base_module_t</span> *rcache, <span class="type">opal_free_list_item_init_fn_t</span> item_init,</span></span><br><span class="line"><span class="params">                        <span class="type">void</span> *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (frag_class) &#123;</span><br><span class="line">        flist-&gt;fl_frag_class = frag_class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num_elements_to_alloc) &#123;</span><br><span class="line">        <span class="keyword">return</span> opal_free_list_grow_st(flist, num_elements_to_alloc, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OPAL_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中调用<code> opal_free_list_grow_st</code>才是真正能够实现携带类构造函数的函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">opal_free_list_grow_st</span><span class="params">(<span class="type">opal_free_list_t</span> *flist, <span class="type">size_t</span> num_elements,</span></span><br><span class="line"><span class="params">                           <span class="type">opal_free_list_item_t</span> **item_out)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num_elements; ++i) &#123;</span><br><span class="line">        <span class="type">opal_free_list_item_t</span> *item = (<span class="type">opal_free_list_item_t</span> *) ptr;</span><br><span class="line">        item-&gt;registration = reg;</span><br><span class="line">        item-&gt;ptr = payload_ptr;</span><br><span class="line"></span><br><span class="line">        OBJ_CONSTRUCT_INTERNAL(item, flist-&gt;fl_frag_class);</span><br></pre></td></tr></table></figure><p>这里很清晰了，在opal_free_list_grow_st函数中调用<code>OBJ_CONSTRUCT_INTERNAL</code>宏来进行携带类的构造。</p><p>所以携带类构造函数在以下两种情况被执行:</p><ul><li>初始化时调用：当 opal_free_list_init 被调用且 num_elements_to_alloc &gt; 0 时，会立即调用 opal_free_list_grow_st 来预分配元素：</li><li>动态增长时调用：当 free list 为空需要增长时，也会调用构造函数初始化新分配的元素。</li></ul><h4 id="opal-free-list-get"><a href="#opal-free-list-get" class="headerlink" title="opal_free_list_get"></a>opal_free_list_get</h4><p>opal_free_list_get函数可以从list中拿到一个携带类资源。</p><h4 id="opal-free-list-return"><a href="#opal-free-list-return" class="headerlink" title="opal_free_list_return"></a>opal_free_list_return</h4><p>opal_free_list_return函数可以释放一个list中的携带类。</p><h2 id="module-ops"><a href="#module-ops" class="headerlink" title="module ops"></a>module ops</h2><p>接下来就是实现对于btl framework需要实现的ops了：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* btl self module */</span></span><br><span class="line"><span class="type">mca_btl_base_module_t</span> mca_btl_self = &#123;.btl_component = &amp;mca_btl_self_component.super,</span><br><span class="line">                                      .btl_add_procs = mca_btl_self_add_procs,</span><br><span class="line">                                      .btl_del_procs = mca_btl_self_del_procs,</span><br><span class="line">                                      .btl_finalize = mca_btl_self_finalize,</span><br><span class="line">                                      .btl_alloc = mca_btl_self_alloc,</span><br><span class="line">                                      .btl_free = mca_btl_self_free,</span><br><span class="line">                                      .btl_prepare_src = mca_btl_self_prepare_src,</span><br><span class="line">                                      .btl_send = mca_btl_self_send,</span><br><span class="line">                                      .btl_sendi = mca_btl_self_sendi,</span><br><span class="line">                                      .btl_put = mca_btl_self_put,</span><br><span class="line">                                      .btl_get = mca_btl_self_get,</span><br><span class="line">                                      .btl_dump = mca_btl_base_dump&#125;;</span><br></pre></td></tr></table></figure><h3 id="btl-add-procs-进程添加"><a href="#btl-add-procs-进程添加" class="headerlink" title="btl_add_procs - 进程添加"></a>btl_add_procs - 进程添加</h3><p>BTL Self 只对自身进程设置可达性，通过比较进程名称来判断是否为同一进程。</p><p>add_procs负责：</p><ul><li>进程可达性检测：确定哪些进程可以通过当前 BTL 模块到达</li><li>endpoint 创建：为可达的进程创建通信端点</li><li>位图设置：在 reachable 位图中标记可达的进程</li><li>连接建立：建立与远程进程的实际连接（如 TCP 连接）</li></ul><p>self的add_procs实现非常简单, 因为只需要处理本进程内：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PML-&gt;BTL notification of change in the process list.</span></span><br><span class="line"><span class="comment"> * PML-&gt;BTL Notification that a receive fragment has been matched.</span></span><br><span class="line"><span class="comment"> * Called for message that is send from process with the virtual</span></span><br><span class="line"><span class="comment"> * address of the shared memory segment being different than that of</span></span><br><span class="line"><span class="comment"> * the receiver.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param btl (IN)</span></span><br><span class="line"><span class="comment"> * @param proc (IN)</span></span><br><span class="line"><span class="comment"> * @param peer (OUT)</span></span><br><span class="line"><span class="comment"> * @return     OPAL_SUCCESS or error status on failure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mca_btl_self_add_procs</span><span class="params">(<span class="keyword">struct</span> <span class="type">mca_btl_base_module_t</span> *btl, <span class="type">size_t</span> nprocs,</span></span><br><span class="line"><span class="params">                                  <span class="keyword">struct</span> <span class="type">opal_proc_t</span> **procs,</span></span><br><span class="line"><span class="params">                                  <span class="keyword">struct</span> <span class="type">mca_btl_base_endpoint_t</span> **peers,</span></span><br><span class="line"><span class="params">                                  <span class="type">opal_bitmap_t</span> *reachability)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>) nprocs; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == opal_compare_proc(procs[i]-&gt;proc_name, OPAL_PROC_MY_NAME)) &#123;</span><br><span class="line">            opal_bitmap_set_bit(reachability, i);</span><br><span class="line">            <span class="comment">/* need to return something to keep the bml from ignoring us */</span></span><br><span class="line">            peers[i] = (<span class="keyword">struct</span> <span class="type">mca_btl_base_endpoint_t</span> *) <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* there will always be only one ... */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OPAL_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键逻辑：</p><ul><li>遍历所有传入的进程</li><li>通过 opal_compare_proc 比较进程名称与当前进程</li><li>如果是同一进程，设置位图并创建虚拟 endpoint</li><li>只会有一个进程匹配（自己）</li></ul><h4 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h4><p>位图的作用: reachable 位图是一个关键的数据结构，用于：</p><ul><li>标记可达性：每个位对应一个进程，设置为 1 表示该进程可通过此 BTL 到达</li><li>BTL 选择：上层（BML）根据位图决定使用哪些 BTL 与特定进程通信</li><li>负载均衡：当多个 BTL 都能到达同一进程时，可以进行选择</li></ul><h3 id="btl-del-procs-进程删除"><a href="#btl-del-procs-进程删除" class="headerlink" title="btl_del_procs - 进程删除"></a>btl_del_procs - 进程删除</h3><p>用于清理进程相关资源, self的实现很简单，直接返回成功，因为没有需要清理的资源。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PML-&gt;BTL notification of change in the process list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param btl (IN)     BTL instance</span></span><br><span class="line"><span class="comment"> * @param proc (IN)    Peer process</span></span><br><span class="line"><span class="comment"> * @param peer (IN)    Peer addressing information.</span></span><br><span class="line"><span class="comment"> * @return             Status indicating if cleanup was successful</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mca_btl_self_del_procs</span><span class="params">(<span class="keyword">struct</span> <span class="type">mca_btl_base_module_t</span> *btl, <span class="type">size_t</span> nprocs,</span></span><br><span class="line"><span class="params">                                  <span class="keyword">struct</span> <span class="type">opal_proc_t</span> **procs,</span></span><br><span class="line"><span class="params">                                  <span class="keyword">struct</span> <span class="type">mca_btl_base_endpoint_t</span> **peers)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> OPAL_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="btl-alloc-内存分配"><a href="#btl-alloc-内存分配" class="headerlink" title="btl_alloc - 内存分配"></a>btl_alloc - 内存分配</h3><p>self实现如下:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocate a segment.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param btl (IN)      BTL module</span></span><br><span class="line"><span class="comment"> * @param size (IN)     Request segment size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">mca_btl_base_descriptor_t</span> *<span class="title function_">mca_btl_self_alloc</span><span class="params">(<span class="keyword">struct</span> <span class="type">mca_btl_base_module_t</span> *btl,</span></span><br><span class="line"><span class="params">                                                     <span class="keyword">struct</span> <span class="type">mca_btl_base_endpoint_t</span> *endpoint,</span></span><br><span class="line"><span class="params">                                                     <span class="type">uint8_t</span> order, <span class="type">size_t</span> size, <span class="type">uint32_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">mca_btl_self_frag_t</span> *frag = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= MCA_BTL_SELF_MAX_INLINE_SIZE) &#123;</span><br><span class="line">        MCA_BTL_SELF_FRAG_ALLOC_RDMA(frag);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= mca_btl_self.btl_eager_limit) &#123;</span><br><span class="line">        MCA_BTL_SELF_FRAG_ALLOC_EAGER(frag);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= btl-&gt;btl_max_send_size) &#123;</span><br><span class="line">        MCA_BTL_SELF_FRAG_ALLOC_SEND(frag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (OPAL_UNLIKELY(<span class="literal">NULL</span> == frag)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    frag-&gt;segments[<span class="number">0</span>].seg_len = size;</span><br><span class="line">    frag-&gt;base.des_segment_count = <span class="number">1</span>;</span><br><span class="line">    frag-&gt;base.des_flags = flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;frag-&gt;base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到根据内存大小进行不同的选择：</p><ul><li>&lt;&#x3D; MCA_BTL_SELF_MAX_INLINE_SIZE -&gt; rdma_frag</li><li>&lt;&#x3D; mca_btl_self.btl_eager_limit -&gt; eager_frag</li><li>&lt;&#x3D; btl_max_send_size -&gt; send_frag</li></ul><h3 id="btl-prepare-src-发送准备"><a href="#btl-prepare-src-发送准备" class="headerlink" title="btl_prepare_src - 发送准备"></a>btl_prepare_src - 发送准备</h3><p>prepare_src 可以根据数据特性选择最优的处理方式。比如对于连续数据可以避免不必要的内存拷贝。</p><p>这点我们会在下面的代码看到：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prepare data for send</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param btl (IN)      BTL module</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="type">mca_btl_base_descriptor_t</span> *<span class="title function_">mca_btl_self_prepare_src</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> <span class="type">mca_btl_base_module_t</span> *btl, <span class="keyword">struct</span> <span class="type">mca_btl_base_endpoint_t</span> *endpoint,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> <span class="type">opal_convertor_t</span> *convertor, <span class="type">uint8_t</span> order, <span class="type">size_t</span> reserve, <span class="type">size_t</span> *size, <span class="type">uint32_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> inline_send = !(opal_convertor_need_buffers(convertor) || opal_convertor_on_device(convertor));</span><br><span class="line">    <span class="type">size_t</span> buffer_len = reserve + (inline_send ? <span class="number">0</span> : *size);</span><br><span class="line">    <span class="type">mca_btl_self_frag_t</span> *frag;</span><br><span class="line"></span><br><span class="line">    frag = (<span class="type">mca_btl_self_frag_t</span> *) mca_btl_self_alloc(btl, endpoint, order, buffer_len, flags);</span><br><span class="line">    <span class="keyword">if</span> (OPAL_UNLIKELY(<span class="literal">NULL</span> == frag)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先先获取是否需要内联发送，内联发送的条件是:</p><ul><li>opal_convertor_need_buffers &#x3D; 0, 也就是说数据是连续的，不需要额外缓冲区进行打包</li><li>opal_convertor_on_device &#x3D; 0, 数据没有在设备上，比如GPU</li></ul><p>这里又引入了一个新的数据结构convertor, 它其实就是数据buffer的一个封装，主要作用：</p><ul><li>处理非连续数据类型：将复杂的 MPI 数据类型（如结构体、向量等）转换为可传输的连续字节流</li><li>数据打包&#x2F;解包：通过 opal_convertor_pack 和 opal_convertor_unpack 函数进行数据转换</li><li>跨架构支持：处理不同架构间的数据格式转换</li></ul><p>在buffer_len中比较迷惑的一点就是reserve, 预留内存大小。是上层协议（如 PML）需要在数据前面预留的头部空间，用于存放协议头信息</p><p>接下来申请一个frag，之后就会遇到两个路径。</p><p>这里需要先提前说一下segments的规范：</p><ul><li>当为连续数据的时候， segments[0]为PML层的头部数据保留， segments[1]指向实际数据的指针（零拷贝）</li><li>当为非连续数据的时候， segments[0]为PML层的头部数据+实际数据， segments[1] 没有作用。</li></ul><h4 id="连续数据内联准备发送"><a href="#连续数据内联准备发送" class="headerlink" title="连续数据内联准备发送"></a>连续数据内联准备发送</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">void</span> *data_ptr;</span><br><span class="line"></span><br><span class="line">    opal_convertor_get_current_pointer(convertor, &amp;data_ptr);</span><br><span class="line"></span><br><span class="line">    frag-&gt;segments[<span class="number">1</span>].seg_addr.pval = data_ptr;</span><br><span class="line">    frag-&gt;segments[<span class="number">1</span>].seg_len = *size;</span><br><span class="line">    frag-&gt;base.des_segment_count = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;frag-&gt;base;</span><br></pre></td></tr></table></figure><p>当inline_send &#x3D; true的时候，就走的else也就是内联发送分支。</p><p>从UNLIKELY这个宏可以看出，绝大部分时间应该走的是这个分支。</p><p>在内联发送中，将convertor的当前指针拿到data_prt变量中，然后赋值给segments[1]。</p><p>最后直接返回了frag的父对象也就是base描述符的指针。</p><p>这样接收方可以直接从convertor指向的指针中直接拿数据，0拷贝。</p><h4 id="非连续数据或非本地数据（在设备上）准备发送"><a href="#非连续数据或非本地数据（在设备上）准备发送" class="headerlink" title="非连续数据或非本地数据（在设备上）准备发送"></a>非连续数据或非本地数据（在设备上）准备发送</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* non-contiguous data */</span></span><br><span class="line"><span class="keyword">if</span> (OPAL_UNLIKELY(!inline_send)) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> =</span> &#123;.iov_len = *size,</span><br><span class="line">                        .iov_base = (IOVBASE_TYPE *) ((<span class="type">uintptr_t</span>) frag-&gt;data + reserve)&#125;;</span><br><span class="line">    <span class="type">size_t</span> max_data = *size;</span><br><span class="line">    <span class="type">uint32_t</span> iov_count = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line">    rc = opal_convertor_pack(convertor, &amp;iov, &amp;iov_count, &amp;max_data);</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        mca_btl_self_free(btl, &amp;frag-&gt;base);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *size = max_data;</span><br><span class="line">    frag-&gt;segments[<span class="number">0</span>].seg_len = reserve + max_data;</span><br></pre></td></tr></table></figure><p>当inline_send &#x3D; false的时候，就走的if分支。</p><p>此时需要创建一个iovec的数据结构，iovec 是一个标准的 I&#x2F;O 向量结构，包含 iov_base（指针）和 iov_len（长度）两个字段。在处理非连续数据时，它用于指定 opal_convertor_pack 函数将数据打包到哪个缓冲区位置。</p><p>这里的iovec的赋值更加确定了我们之前解释的segments.</p><p>可以看到iovec的iov_base的地址跳过了reserve, 充分说明是给PML层的头部预留的空间。</p><p>之后通过<code>opal_convertor_pack</code>函数将数据打包到iovec指向的地址中。</p><p>最后更新segments[0].seg_len。</p><p>这里可能比较疑惑seg的addr怎么没有像连续数据那样设置，因为在frag的构造函数中已经指向了frag-&gt;data了，而上面iovec拷贝的目标地址正是frag-&gt;data.</p><h3 id="btl-send-消息发送"><a href="#btl-send-消息发送" class="headerlink" title="btl_send - 消息发送"></a>btl_send - 消息发送</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initiate a send to the peer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param btl (IN)      BTL module</span></span><br><span class="line"><span class="comment"> * @param peer (IN)     BTL peer addressing</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mca_btl_self_send</span><span class="params">(<span class="keyword">struct</span> <span class="type">mca_btl_base_module_t</span> *btl,</span></span><br><span class="line"><span class="params">                             <span class="keyword">struct</span> <span class="type">mca_btl_base_endpoint_t</span> *endpoint,</span></span><br><span class="line"><span class="params">                             <span class="keyword">struct</span> <span class="type">mca_btl_base_descriptor_t</span> *des, <span class="type">mca_btl_base_tag_t</span> tag)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">mca_btl_active_message_callback_t</span> *reg = mca_btl_base_active_message_trigger + tag;</span><br><span class="line">    <span class="type">mca_btl_base_receive_descriptor_t</span> recv_desc = &#123;.endpoint = endpoint,</span><br><span class="line">                                                   .des_segments = des-&gt;des_segments,</span><br><span class="line">                                                   .des_segment_count = des-&gt;des_segment_count,</span><br><span class="line">                                                   .tag = tag,</span><br><span class="line">                                                   .cbdata = reg-&gt;cbdata&#125;;</span><br><span class="line">    <span class="type">int</span> btl_ownership = (des-&gt;des_flags &amp; MCA_BTL_DES_FLAGS_BTL_OWNERSHIP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* upcall */</span></span><br><span class="line">    reg-&gt;cbfunc(btl, &amp;recv_desc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* send completion */</span></span><br><span class="line">    <span class="keyword">if</span> (des-&gt;des_flags &amp; MCA_BTL_DES_SEND_ALWAYS_CALLBACK) &#123;</span><br><span class="line">        des-&gt;des_cbfunc(btl, endpoint, des, OPAL_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (btl_ownership) &#123;</span><br><span class="line">        mca_btl_self_free(btl, des);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在send函数中，由于self组件是同线程内使用，所以不需要任何的传送机制。</p><p>直接调用回调函数模拟接收就可以了。</p><p>MCA_BTL_DES_SEND_ALWAYS_CALLBACK宏用来判断是否需要调用des的回调。</p><p>btl_ownership用来判断是否需要由btl层释放描述符。</p><h3 id="btl-sendi-立即发送"><a href="#btl-sendi-立即发送" class="headerlink" title="btl_sendi - 立即发送"></a>btl_sendi - 立即发送</h3><p>sendi函数是指的立即发送，也就是将prepare_src和send函数合并到一步”原子性”的完成。</p><p>先看一下函数的定义：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mca_btl_self_sendi</span><span class="params">(<span class="keyword">struct</span> <span class="type">mca_btl_base_module_t</span> *btl,</span></span><br><span class="line"><span class="params">                              <span class="keyword">struct</span> <span class="type">mca_btl_base_endpoint_t</span> *endpoint,</span></span><br><span class="line"><span class="params">                              <span class="keyword">struct</span> <span class="type">opal_convertor_t</span> *convertor, <span class="type">void</span> *header, <span class="type">size_t</span> header_size,</span></span><br><span class="line"><span class="params">                              <span class="type">size_t</span> payload_size, <span class="type">uint8_t</span> order, <span class="type">uint32_t</span> flags,</span></span><br><span class="line"><span class="params">                              <span class="type">mca_btl_base_tag_t</span> tag, <span class="type">mca_btl_base_descriptor_t</span> **descriptor)</span></span><br></pre></td></tr></table></figure><p>这里需要注意几个参数：</p><ul><li>payload_size: 负载数据大小</li><li>header_size: 协议头大小</li></ul><p>endpoint不需要注意，在add_procs里面我们设置成-1了也就是没用到这东西</p><p>在sendi的开头，先是进行了如下操作：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!payload_size ||</span><br><span class="line">    !(opal_convertor_need_buffers(convertor) ||</span><br><span class="line">      opal_convertor_on_device(convertor))) &#123;</span><br><span class="line">    <span class="type">void</span> *data_ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (payload_size) &#123;</span><br><span class="line">        opal_convertor_get_current_pointer(convertor, &amp;data_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">mca_btl_base_segment_t</span> segments[<span class="number">2</span>] = &#123;&#123;.seg_addr.pval = header, .seg_len = header_size&#125;,</span><br><span class="line">                                          &#123;.seg_addr.pval = data_ptr, .seg_len = payload_size&#125;&#125;;</span><br><span class="line">    <span class="type">mca_btl_base_descriptor_t</span> des = &#123;.des_segments = segments,</span><br><span class="line">                                     .des_segment_count = payload_size ? <span class="number">2</span> : <span class="number">1</span>,</span><br><span class="line">                                     .des_flags = <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    (<span class="type">void</span>) mca_btl_self_send(btl, endpoint, &amp;des, tag);</span><br><span class="line">    <span class="keyword">return</span> OPAL_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一条路径就是快速路径，可以看到是直接用的临时变量des和segments，而不是用的alloc的frag.</p><p>因为调用 mca_btl_self_alloc 需要从内存池中分配片段，涉及内存池操作和可能的锁竞争。</p><p>如果负载数据大小为0 || (是连续的数据 &amp;&amp; 数据不在设备上)，那么就执行这个if函数。</p><p>人话：负载数据大小为0或者内联发送</p><p>进入这个if的时候会再次判断是否payload_size是否不为0,如果不为0，就获取convertor的指针到data_ptr中。</p><p>封装进入segments, 设置协议头地址和大小&#x2F;数据地址和大小。</p><p>最后将segments给到des, 然后直接调用send函数。</p><p>如果没有成功进入快速路径的话，就走的如下代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">frag = mca_btl_self_prepare_src(btl, endpoint, convertor, order, header_size, &amp;payload_size,</span><br><span class="line">                                flags | MCA_BTL_DES_FLAGS_BTL_OWNERSHIP);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == frag) &#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="literal">NULL</span> != descriptor ) &#123;</span><br><span class="line">        *descriptor = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OPAL_ERR_OUT_OF_RESOURCE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(frag-&gt;des_segments[<span class="number">0</span>].seg_addr.pval, header, header_size);</span><br><span class="line">(<span class="type">void</span>) mca_btl_self_send(btl, endpoint, frag, tag);</span><br><span class="line"><span class="keyword">return</span> OPAL_SUCCESS;</span><br></pre></td></tr></table></figure><p>慢速路径其实就是将prepare_src和send函数合并到一起并没有做性能优化，唯一需要注意的就是通过<code>memcpy</code>函数获得了协议头的数据。</p><h3 id="btl-put-btl-get-RDMA-put-get操作"><a href="#btl-put-btl-get-RDMA-put-get操作" class="headerlink" title="btl_put&#x2F;btl_get - RDMA put&#x2F;get操作"></a>btl_put&#x2F;btl_get - RDMA put&#x2F;get操作</h3><p>self组件对于rdma的实现相当简单粗暴，因为都是同一个进程内的内存，所以直接可以memcpy</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mca_btl_self_put</span><span class="params">(<span class="type">mca_btl_base_module_t</span> *btl, <span class="keyword">struct</span> <span class="type">mca_btl_base_endpoint_t</span> *endpoint,</span></span><br><span class="line"><span class="params">                            <span class="type">void</span> *local_address, <span class="type">uint64_t</span> remote_address,</span></span><br><span class="line"><span class="params">                            <span class="type">mca_btl_base_registration_handle_t</span> *local_handle,</span></span><br><span class="line"><span class="params">                            <span class="type">mca_btl_base_registration_handle_t</span> *remote_handle, <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">                            <span class="type">int</span> flags, <span class="type">int</span> order, <span class="type">mca_btl_base_rdma_completion_fn_t</span> cbfunc,</span></span><br><span class="line"><span class="params">                            <span class="type">void</span> *cbcontext, <span class="type">void</span> *cbdata)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">void</span> *) (<span class="type">intptr_t</span>) remote_address, local_address, size);</span><br><span class="line"></span><br><span class="line">    cbfunc(btl, endpoint, local_address, <span class="literal">NULL</span>, cbcontext, cbdata, OPAL_SUCCESS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OPAL_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mca_btl_self_get</span><span class="params">(<span class="type">mca_btl_base_module_t</span> *btl, <span class="keyword">struct</span> <span class="type">mca_btl_base_endpoint_t</span> *endpoint,</span></span><br><span class="line"><span class="params">                            <span class="type">void</span> *local_address, <span class="type">uint64_t</span> remote_address,</span></span><br><span class="line"><span class="params">                            <span class="type">mca_btl_base_registration_handle_t</span> *local_handle,</span></span><br><span class="line"><span class="params">                            <span class="type">mca_btl_base_registration_handle_t</span> *remote_handle, <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">                            <span class="type">int</span> flags, <span class="type">int</span> order, <span class="type">mca_btl_base_rdma_completion_fn_t</span> cbfunc,</span></span><br><span class="line"><span class="params">                            <span class="type">void</span> *cbcontext, <span class="type">void</span> *cbdata)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(local_address, (<span class="type">void</span> *) (<span class="type">intptr_t</span>) remote_address, size);</span><br><span class="line"></span><br><span class="line">    cbfunc(btl, endpoint, local_address, <span class="literal">NULL</span>, cbcontext, cbdata, OPAL_SUCCESS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OPAL_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> openmpi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openmpi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openmpi[2] 模块化组件架构</title>
      <link href="/2025/09/08/openmpi-2-modular-component-architecture/"/>
      <url>/2025/09/08/openmpi-2-modular-component-architecture/</url>
      
        <content type="html"><![CDATA[<ol class="series-items"><li><a href="/2025/09/16/openmpi-0-openmpi-img-parse/" title="openmpi[0]-openmpi-img-parse">openmpi[0]-openmpi-img-parse</a></li><li><a href="/2025/09/08/openmpi-1-what-is-openmpi/" title="openmpi[1] 什么是openmpi">openmpi[1] 什么是openmpi</a></li><li><a href="/2025/09/08/openmpi-2-modular-component-architecture/" title="openmpi[2] 模块化组件架构">openmpi[2] 模块化组件架构</a></li><li><a href="/2025/09/08/openmpi-3-btl-mca-self/" title="openmpi[3] btl框架的self组件分析">openmpi[3] btl框架的self组件分析</a></li></ol><p>Open MPI 是一个高度可定制的系统；它可以通过配置文件、命令行参数和环境变量进行配置。Open MPI 配置系统的主要功能是通过模块化组件架构 (MCA) 实现的。</p><h2 id="一些术语"><a href="#一些术语" class="headerlink" title="一些术语"></a>一些术语</h2><p>模块化组件架构 (MCA) 是 Open MPI 大部分功能的支柱。它由一系列项目 、 框架 、 组件和模块在运行时组装以创建 MPI 实现。</p><p>MCA 参数 （也称为 MCA 变量 ）用于定制 Open MPI 在运行时的行为。</p><h3 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h3><p>Project本质上是 Open MPI 代码库中最高抽象层的划分。</p><p>但这里的Project可不是说的项目，而是指的Open MPI 代码库中主要的、顶层的代码部分</p><h3 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h3><p>MCA 框架在运行时管理零个或多个组件，并针对特定任务（例如，提供 MPI 集合操作功能）。虽然每个 MCA 框架仅支持一种类型的组件，但它可以支持多个该类型的组件。</p><p>比如btl framework仅支持btl类型的组件，但是它可以支持多个btl组件，比如openib、tcp、usnic等。</p><p>用户可能想自定义或者更改的framework如下：</p><ul><li>btl: Byte Transport Layer (字节传输层); 这些组件专门用作 PML(点对点) 组件的底层传输。</li><li>coll: 集合操作层 (Collection Operations Layer)；这些组件专门用于实现 MPI 集合操作。</li><li>io: MPI I&#x2F;O</li><li>mtl: MPI 匹配传输层 (MPI Matching Transport Layer)；这些组件专门用作 cm PML 组件的底层传输。</li><li>pml: 点对点消息传递层 (Point-to-point Messaging Layer) 。这些组件用于实现 MPI 点对点消息传递功能。</li></ul><h3 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h3><p>MCA 组件是框架正式接口的实现。它是一个独立的代码集合，可以捆绑成插件，并在运行时或编译时插入到 Open MPI 代码库中。</p><p>Open MPI 的Components概念的同义词是“plugin”或“add-on”。</p><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>Module是Component的一个实例（在 C++ 意义上 词“实例”；Component类似于 C++ 类）。例如，如果运行 Open MPI 应用程序的节点有两个以太网 NIC，Open MPI 应用程序将包含一个 TCP MPI 点对点 Component ，而是两个 TCP 点对点Modules 。</p><h3 id="MCA-参数"><a href="#MCA-参数" class="headerlink" title="MCA 参数"></a>MCA 参数</h3><p>MCA 参数 （有时称为 MCA 变量 ）是 Open MPI 运行时调优的基本单位。它们是简单的“键 &#x3D; 值”对，在 Open MPI 中广泛使用。开发人员使用的一般经验规则是：</p><ul><li>不要将重要值设为常数，而应将其设为 MCA 参数。</li><li>如果一个任务可以通过多种用户可辨别的方式实现，则尽可能多地实现，并使用 MCA 参数在运行时在它们之间进行选择。</li></ul><h2 id="设置MCA参数（变量）"><a href="#设置MCA参数（变量）" class="headerlink" title="设置MCA参数（变量）"></a>设置MCA参数（变量）</h2><p>MCA参数可以通过以下几种方式进行设置，按优先级列出：</p><ol><li>命令行</li><li>环境变量</li><li>mca参数文件</li><li>配置文件</li></ol><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><p>优先级最高的方法是在命令行中设置 MCA 参数。例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell$ mpirun --mca mpi_show_handle_leaks 1 -np 4 a.out</span><br></pre></td></tr></table></figure><p>这会在使用四个进程运行 a.out 之前，将 MCA 参数 mpi_show_handle_leaks 的值设置为 1。通常，命令行中使用的格式为 –mca <param_name> <value> 。</p><p>设置包含空格的值时，需要使用引号，以确保 Shell 能够将多个标记理解为一个值。例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell$ mpirun --mca param <span class="string">&quot;value with multiple words&quot;</span> ...</span><br></pre></td></tr></table></figure><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><h3 id="mca参数文件"><a href="#mca参数文件" class="headerlink" title="mca参数文件"></a>mca参数文件</h3><p>可以使用简单的文本文件来设置特定应用程序的 MCA 参数值。</p><p>mpirun –tune CLI 选项允许用户在单个文件中指定 MCA 参数和环境变量。</p><p>调整参数文件中设置的 MCA 参数将覆盖任何 MCA 全局参数文件中提供的参数（例如， $HOME&#x2F;.openmpi&#x2F;mca-params.conf )，但不是命令行或环境参数。</p><p>假设有一个已调整的参数文件名为 foo.conf ，它与应用程序 a.out 放在同一目录中。用户通常会以如下方式运行该应用程序：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell$ mpirun -np 2 a.out</span><br></pre></td></tr></table></figure><p>要使用 foo.conf 调整参数文件，此命令行更改为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell$ mpirun -np 2 --tune foo.conf a.out</span><br></pre></td></tr></table></figure><p>如果要使用多个文件，则可以将已调优的参数文件组合在一起。如果还有一个名为 bar.conf 的已调优参数文件，则可以按如下方式将其添加到命令行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell$ mpirun -np 2 --tune foo.conf,bar.conf a.out</span><br></pre></td></tr></table></figure><p>已调整文件的内容由一行或多行组成，每行包含零个或多个 -x 和 –mca 选项。不允许使用注释。例如，以下已调整文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-x envvar1=value1 -mca param1 value1 -x envvar2</span><br><span class="line">-mca param2 value2</span><br><span class="line">-x envvar3</span><br></pre></td></tr></table></figure><p>相当于:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell$ mpirun \</span><br><span class="line">    -x envvar1=value1 -mca param1 value1 -x envvar2 \</span><br><span class="line">    -mca param2 value2</span><br><span class="line">    -x envvar3 \</span><br><span class="line">    ...rest of mpirun <span class="built_in">command</span> line...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> openmpi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openmpi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openmpi[1] 什么是openmpi</title>
      <link href="/2025/09/08/openmpi-1-what-is-openmpi/"/>
      <url>/2025/09/08/openmpi-1-what-is-openmpi/</url>
      
        <content type="html"><![CDATA[<ol class="series-items"><li><a href="/2025/09/16/openmpi-0-openmpi-img-parse/" title="openmpi[0]-openmpi-img-parse">openmpi[0]-openmpi-img-parse</a></li><li><a href="/2025/09/08/openmpi-1-what-is-openmpi/" title="openmpi[1] 什么是openmpi">openmpi[1] 什么是openmpi</a></li><li><a href="/2025/09/08/openmpi-2-modular-component-architecture/" title="openmpi[2] 模块化组件架构">openmpi[2] 模块化组件架构</a></li><li><a href="/2025/09/08/openmpi-3-btl-mca-self/" title="openmpi[3] btl框架的self组件分析">openmpi[3] btl框架的self组件分析</a></li></ol><h2 id="什么是openmpi"><a href="#什么是openmpi" class="headerlink" title="什么是openmpi?"></a>什么是openmpi?</h2><p>MPI是一套通信标准，由MPI Forum创建并维护（MPI Forum是一个开放组织，由工业、学术界的高性能计算领域的专家组成）.<br>MPI是这样一种API：</p><ul><li>可移植</li><li>高性能的IPC通信</li></ul><p>MPI一般作为一个消息传递的中间件，上层应用程序可以通过调用MPI接口来执行消息传递。<br>MPI定义了一系列与平台无关的、高度抽象的API接口，用于进程之间的消息传递(这两个进程之间可以在不同主机，但主机之间需要有一个通信的通道, 比如eth)举一个最简单的例子，进程X是发送进程，只需提供消息内容（例如一个双精度数组）以及另一个接收进程的标识（例如进程Y），同时接收进程Y只需提供发送进程的标识（例如进程X），消息就可以从X传递给Y。<br>注意这个例子中，没有建立连接、没有字节流的转换、没有网络地址的交换，MPI将这些细节都抽象封装了起来，不仅仅是隐藏了复杂性，而且使应用程序能够兼容不同的平台、硬件以及网络类型。<br>MPI提供的通信模式：</p><ul><li>point to point</li><li>collective</li><li>broadcast</li></ul><h2 id="openmpi的功能和特性"><a href="#openmpi的功能和特性" class="headerlink" title="openmpi的功能和特性"></a>openmpi的功能和特性</h2><p>在这里我并不想讨论MPI的标准一致性，所以让我们跳过。</p><h3 id="模块化组件架构-MCA"><a href="#模块化组件架构-MCA" class="headerlink" title="模块化组件架构(MCA)"></a>模块化组件架构(MCA)</h3><ul><li>项目分层：OPAL（可移植性层）、OMPI（MPI API）、OSHMEM（OpenSHMEM API）</li><li>框架系统：BTL（字节传输层）、PML（点对点消息层）、Coll（集合操作）等</li><li>组件插件：支持运行时和编译时的组件选择</li></ul><p>关于更详细的框架系统我会在后面的章节介绍。</p><h3 id="多种传输协议的支持"><a href="#多种传输协议的支持" class="headerlink" title="多种传输协议的支持"></a>多种传输协议的支持</h3><p>得益于框架系统的分层架构，openmpi通过btl或coll层支持了多重传输协议，包括：</p><ul><li>self: 用于同一节点同一进程内的通信</li><li>共享内存：用于同一节点内进程间高效通信</li><li>TCP&#x2F;IP：通用网络传输</li><li>高性能网络：InfiniBand、Omni-Path、以太网等</li></ul><h3 id="加速器框架"><a href="#加速器框架" class="headerlink" title="加速器框架"></a>加速器框架</h3><p>新的加速器框架支持 CUDA 和 ROCm 设备，提供统一的设备抽象</p><h3 id="平台支持"><a href="#平台支持" class="headerlink" title="平台支持"></a>平台支持</h3><p>Open MPI 支持广泛的平台：</p><ul><li>操作系统：Linux、macOS、Cygwin、OpenBSD 等</li><li>架构：x86_64、ARM、PowerPC 等</li><li>运行时系统：Slurm、PBS、LSF、SGE 等</li></ul><p>还有一些其他我不关心的东西没有在此处列出，比如I&#x2F;O子系统。</p><h2 id="如何开始"><a href="#如何开始" class="headerlink" title="如何开始"></a>如何开始</h2><h3 id="安装openmpi"><a href="#安装openmpi" class="headerlink" title="安装openmpi"></a>安装openmpi</h3><p>你可以从源码编译安装openmpi，也可以使用包管理器安装。</p><p>这对一个稳定的发行版来说都很容易，比如Ubuntu、CentOS、Arch Linux等。</p><p>如果使用源码编译，你可以轻松的通过以下命令做到：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./autogen.pl &amp;&amp; ./configure --prefix=/opt/openmpi &amp;&amp; make -j64 &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>请注意，如果通过tarball下载的源码而不是git repo, 则不需要执行autogen.pl命令。</p><h3 id="编写MPI程序"><a href="#编写MPI程序" class="headerlink" title="编写MPI程序"></a>编写MPI程序</h3><p>先从简单的helloworld开始：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    MPI_Init(&amp;argc, &amp;argv);</span><br><span class="line">    <span class="type">int</span> rank, size;</span><br><span class="line">    <span class="type">char</span> hostname[<span class="number">256</span>];</span><br><span class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);</span><br><span class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;size);</span><br><span class="line">    gethostname(hostname, <span class="keyword">sizeof</span>(hostname));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from rank %d of %d on %s\n&quot;</span>, rank, size, hostname);</span><br><span class="line">    MPI_Finalize();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前不需要理解他们的含义，我们在这里只是作为演示。</p><p>运行以下命令进行编译：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mpicc -o helloworld helloworld.c</span><br></pre></td></tr></table></figure><h3 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h3><p>如果你只有一个机器，你可以直接运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mpirun -np 2 --mca btl self,sm helloworld</span><br></pre></td></tr></table></figure><p>如果你有多个机器，太棒了，可以体验用多个机器并发任务了。</p><p>首先需要保证他们都安装了openmpi, 并且helloworld都在同一个目录下。</p><p>然后编写一个host file去澄清他们的ip地址：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">192.168.1.101 slots=8</span><br><span class="line">192.168.1.102 slots=8</span><br></pre></td></tr></table></figure><p>slots表示每块板子能并行的核心数，通常是芯片的cpu核心数</p><p>现在开始运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mpirun -np 2 --hostfile hosts.txt /home/troy/helloworld</span><br></pre></td></tr></table></figure><p>Enjoy :)</p>]]></content>
      
      
      <categories>
          
          <category> openmpi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openmpi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sd与mmc刷写指南</title>
      <link href="/2025/08/01/sd%E4%B8%8Emmc%E5%88%B7%E5%86%99%E6%8C%87%E5%8D%97/"/>
      <url>/2025/08/01/sd%E4%B8%8Emmc%E5%88%B7%E5%86%99%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="Env"><a href="#Env" class="headerlink" title="Env"></a>Env</h2><p>Host: Ubuntu 22.04</p><p>GParted 1.3.1</p><h2 id="SD卡"><a href="#SD卡" class="headerlink" title="SD卡"></a>SD卡</h2><p>首先插入sd卡，打开GParted工具，没有可以下载一个：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">sudo</span> apt install gpart</span><br></pre></td></tr></table></figure><p>选择sd卡设备，我这里是sdb，因机器而异。</p><p>选择菜单栏的<code>设备</code>-&gt;<code>创建分区表</code>，选择msdos分区表。</p><p><a href="https://i.postimg.cc/rFV6F05D/2024-09-20-17-52-19.png"><img src="https://i.postimg.cc/rFV6F05D/2024-09-20-17-52-19.png" alt="2024-09-20-17-52-19.png"></a></p><p>创建完成之后，新建两个分区。</p><p>一个fat16的，用于放内核镜像和dtb文件以及uboot保存的env文件。</p><p><a href="https://postimg.cc/bSDT7QCh"><img src="https://i.postimg.cc/wMFGs2D7/2024-09-20-17-55-43.png" alt="2024-09-20-17-55-43.png"></a></p><p>一个ext4用来存放根文件系统。</p><p><a href="https://postimg.cc/w3yQTQ2K"><img src="https://i.postimg.cc/h4MysC7G/2024-09-20-17-55-55.png" alt="2024-09-20-17-55-55.png"></a></p><p>完成之后点击绿色小对勾，让更改生效。</p><p><a href="https://postimg.cc/Dm9dW4pS"><img src="https://i.postimg.cc/hPjC5991/2024-09-20-17-56-02.png" alt="2024-09-20-17-56-02.png"></a></p><p>之后便可以在<code>/dev</code>下看到对应的分区：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">ls</span> /dev/sdb*</span><br><span class="line">/dev/sdb  /dev/sdb1  /dev/sdb2</span><br></pre></td></tr></table></figure><p>下载uboot镜像：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">sudo</span> <span class="built_in">dd</span> <span class="keyword">if</span>=u-boot-sunxi-with-spl.bin of=/dev/sdb bs=1024 seek=8</span><br></pre></td></tr></table></figure><p>存放内核镜像和设备树：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">❯ sudo mount /dev/sdb1 /mnt</span><br><span class="line">❯ sudo cp arch/arm/boot/zImage /mnt</span><br><span class="line">❯ sudo cp arch/arm/boot/dts/allwinner/sun8i-a33-vstar.dtb /mnt</span><br><span class="line">❯ sudo umount /mnt</span><br></pre></td></tr></table></figure><p>存放根文件系统：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">sudo</span> mount /dev/sdb2 /mnt</span><br><span class="line">❯ <span class="built_in">sudo</span> tar -xvzf ubuntu22.04.tar.gz -C /mnt</span><br><span class="line">❯ <span class="built_in">sudo</span> umount /mnt</span><br></pre></td></tr></table></figure><h2 id="EMMC"><a href="#EMMC" class="headerlink" title="EMMC"></a>EMMC</h2><p>对于EMMC操作复杂一些，需要修改uboot，打开CONFIG_CMD_USB_MASS_STORAGE的配置项。</p><p>进入fel模式将uboot下载进入内存并运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">sudo</span> sunxi-fel uboot ./u-boot-sunxi-with-spl.bin</span><br></pre></td></tr></table></figure><p>在uboot自动启动内核前打断，并且输入如下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; ums 2 mmc 1</span><br></pre></td></tr></table></figure><p>这个命令是将mmc的1号设备通过usb 2号挂载出去。就相当于电脑插了个U盘。</p><p>我这里mmc的1号设备是emmc，usb2号是otg接口，需要根据实际情况修改。</p><p>使用如下命令可查询对应的接口号：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; mmc list</span><br><span class="line">=&gt; usb tree</span><br><span class="line"><span class="comment"># 或者是usb info</span></span><br></pre></td></tr></table></figure><p>然后电脑就能看到了<code>/dev/sdX</code>，随后的操作与SD卡相同。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>VirtualBox错误</title>
      <link href="/2025/08/01/VirtualBox%E9%94%99%E8%AF%AF-1/"/>
      <url>/2025/08/01/VirtualBox%E9%94%99%E8%AF%AF-1/</url>
      
        <content type="html"><![CDATA[<p>当我尝试启动虚拟机时遇到了如下错误：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Kernel driver not installed (rc=-1908)</span><br><span class="line"></span><br><span class="line">The VirtualBox Linux kernel driver is either not loaded or not set up correctly. Please try setting it up again by executing</span><br><span class="line"></span><br><span class="line">&#x27;/sbin/vboxconfig&#x27;</span><br><span class="line"></span><br><span class="line">as root.</span><br><span class="line"></span><br><span class="line">If your system has EFI Secure Boot enabled you may also need to sign the kernel modules (vboxdrv, vboxnetflt, vboxnetadp, vboxpci) before you can load them. Please see your Linux system&#x27;s documentation for more information.</span><br><span class="line"></span><br><span class="line">where: suplibOsInit what: 3 VERR_VM_DRIVER_NOT_INSTALLED (-1908) - The support driver is not installed. On linux, open returned ENOENT. </span><br></pre></td></tr></table></figure><p>尝试执行’&#x2F;sbin&#x2F;vboxconfig’：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">sudo</span> /sbin/vboxconfig</span><br><span class="line">vboxdrv.sh: Stopping VirtualBox services.</span><br><span class="line">vboxdrv.sh: Starting VirtualBox services.</span><br><span class="line">vboxdrv.sh: You must sign these kernel modules before using VirtualBox:</span><br><span class="line">  vboxdrv vboxnetflt vboxnetadp</span><br><span class="line">See the documentation <span class="keyword">for</span> your Linux distribution..</span><br><span class="line">vboxdrv.sh: Building VirtualBox kernel modules.</span><br><span class="line">vboxdrv.sh: failed: Look at /var/log/vbox-setup.log to find out what went wrong.</span><br><span class="line"></span><br><span class="line">There were problems setting up VirtualBox.  To re-start the set-up process, run</span><br><span class="line">  /sbin/vboxconfig</span><br><span class="line">as root.  If your system is using EFI Secure Boot you may need to sign the</span><br><span class="line">kernel modules (vboxdrv, vboxnetflt, vboxnetadp, vboxpci) before you can load</span><br><span class="line">them. Please see your Linux system<span class="string">&#x27;s documentation for more information.</span></span><br></pre></td></tr></table></figure><p>查看secure boot是否开启：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ mokutil --sb-state</span><br><span class="line"></span><br><span class="line">SecureBoot enabled</span><br></pre></td></tr></table></figure><p>进入BIOS关闭secure boot后重新执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">sudo</span> /sbin/vboxconfig</span><br><span class="line"></span><br><span class="line">vboxdrv.sh: Stopping VirtualBox services.</span><br><span class="line">vboxdrv.sh: Starting VirtualBox services.</span><br><span class="line">vboxdrv.sh: Building VirtualBox kernel modules.</span><br><span class="line">vboxdrv.sh: failed: Look at /var/log/vbox-setup.log to find out what went wrong.</span><br><span class="line"></span><br><span class="line">There were problems setting up VirtualBox.  To re-start the set-up process, run</span><br><span class="line">  /sbin/vboxconfig</span><br><span class="line">as root.  If your system is using EFI Secure Boot you may need to sign the</span><br><span class="line">kernel modules (vboxdrv, vboxnetflt, vboxnetadp, vboxpci) before you can load</span><br><span class="line">them. Please see your Linux system<span class="string">&#x27;s documentation for more information.</span></span><br></pre></td></tr></table></figure><p>一样的错误，尝试安装编译内核模块所需的软件包。通常需要 dkms 和 kernel-devel后一切正常：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">sudo</span> apt-get install dkms build-essential linux-headers-$(<span class="built_in">uname</span> -r)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>esp32初始化结构体问题</title>
      <link href="/2025/08/01/esp32/"/>
      <url>/2025/08/01/esp32/</url>
      
        <content type="html"><![CDATA[<p>在<code>c++</code>使用<code>espidf</code>进行<code>wifi</code>连接时，发现如下代码可以连接：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">wifi_config_t</span> wifi_config = &#123;</span><br><span class="line">            .sta = &#123;</span><br><span class="line">                    .ssid = <span class="string">&quot;HBDT-23F&quot;</span>,</span><br><span class="line">                    .password = <span class="string">&quot;hbishbis&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但如下代码不可连接：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">wifi_config_t</span> wifi_config;</span><br><span class="line"><span class="built_in">strcpy</span>(wifi_config.sta.ssid, <span class="string">&quot;HBDT-23F&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(wifi_config.sta.password, <span class="string">&quot;hbishbis&quot;</span>);</span><br></pre></td></tr></table></figure><p>经过排查发现<code>espidf</code>对于连接阶段除了<code>ssid</code>和<code>password</code>还使用到了其他变量，所以应该清零结构体内存：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">wifi_config_t</span> wifi_config&#123;&#125;;</span><br></pre></td></tr></table></figure><p>一个很低级的问题…记录下来时刻警醒。</p>]]></content>
      
      
      <categories>
          
          <category> mcu </category>
          
          <category> esp32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mcu </tag>
            
            <tag> esp32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IMPORTANT: lost blog notes</title>
      <link href="/2025/07/06/IMPORTANT-lost-blog-notes/"/>
      <url>/2025/07/06/IMPORTANT-lost-blog-notes/</url>
      
        <content type="html"><![CDATA[<h1 id="What-happened-to-my-blog"><a href="#What-happened-to-my-blog" class="headerlink" title="What happened to my blog?"></a>What happened to my blog?</h1><p>Due to unforeseen circumstances, some of the blog posts have been lost. I have only found the web page format, but the index for the homepage has been lost.</p><p>So there is the list:</p><h2 id="2025-year"><a href="#2025-year" class="headerlink" title="2025 year"></a>2025 year</h2><h3 id="April"><a href="#April" class="headerlink" title="April"></a>April</h3><h4 id="Day-10"><a href="#Day-10" class="headerlink" title="Day 10"></a>Day 10</h4><ul><li><a href="https://blog.troy-y.org/2025/04/10/vercel%E9%83%A8%E7%BD%B2twikoo%E5%90%8E%E8%AF%84%E8%AE%BA%E6%94%B6%E4%B8%8D%E5%88%B0%E9%80%9A%E7%9F%A5%E9%82%AE%E4%BB%B6%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/">Vercel 部署 Twikoo 后评论收不到通知邮件问题解决方法</a></li></ul><h4 id="Day-12"><a href="#Day-12" class="headerlink" title="Day 12"></a>Day 12</h4><ul><li><a href="https://blog.troy-y.org/2025/04/12/linux%E7%9A%84initcall%E6%9C%BA%E5%88%B6/">Linux 的 initcall 机制</a></li></ul><h4 id="Day-13"><a href="#Day-13" class="headerlink" title="Day 13"></a>Day 13</h4><ul><li><a href="https://blog.troy-y.org/2025/04/13/elf%E6%96%87%E4%BB%B6-0-section%E5%92%8Csegment%E7%9A%84%E5%8C%BA%E5%88%AB/">ELF 文件 -0- section 和 segment 的区别</a></li><li><a href="https://blog.troy-y.org/2025/04/13/linux-i2c%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90-0/">Linux I2C 驱动框架分析 -0</a></li><li><a href="https://blog.troy-y.org/2025/04/13/linux-i2c%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90-1/">Linux I2C 驱动框架分析 -1</a></li></ul><h4 id="Day-20"><a href="#Day-20" class="headerlink" title="Day 20"></a>Day 20</h4><ul><li><a href="https://blog.troy-y.org/2025/04/20/platform-device-driver-0/">Platform Device Driver -0</a></li><li><a href="https://blog.troy-y.org/2025/04/20/platform-device-driver-1/">Platform Device Driver -1</a></li></ul><h4 id="Day-24"><a href="#Day-24" class="headerlink" title="Day 24"></a>Day 24</h4><ul><li><a href="https://blog.troy-y.org/2025/04/24/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%9D%A2%E7%BB%8F-%E9%9A%8F%E6%84%8F%E9%9A%8F%E7%BC%98%E4%B8%8D%E5%AE%8C%E6%95%B4%E7%89%88/">嵌入式 Linux 面经 - 随意随缘不完整版</a></li></ul><h4 id="Day-26"><a href="#Day-26" class="headerlink" title="Day 26"></a>Day 26</h4><ul><li><a href="https://blog.troy-y.org/2025/04/26/Linux%E8%AE%BE%E5%A4%87%E6%A0%91-0-%E7%90%86%E8%A7%A3dtb%E6%A0%BC%E5%BC%8F/">Linux 设备树 -0- 理解 dtb 格式</a></li><li><a href="https://blog.troy-y.org/2025/04/26/Linux%E8%AE%BE%E5%A4%87%E6%A0%91-1-%E8%A7%A3%E6%9E%90%E8%AE%BE%E5%A4%87%E6%A0%91/">Linux 设备树 -1- 解析设备树</a></li><li><a href="https://blog.troy-y.org/2025/04/26/Uboot%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92bootargs%E7%BB%99Linux/">U-Boot 如何传递 bootargs 给 Linux</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo: Deploy github and lose CNAME</title>
      <link href="/2025/07/04/hexo-Deploy-github-and-lose-CNAME/"/>
      <url>/2025/07/04/hexo-Deploy-github-and-lose-CNAME/</url>
      
        <content type="html"><![CDATA[<h1 id="Issue"><a href="#Issue" class="headerlink" title="Issue"></a>Issue</h1><p>I deployed my hexo blog to github pages, but I lost the custom domain in github pages.</p><p>I tried to re-add the custom domain in the repository settings and I found this operation will add CNAME file under the repository root directory.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>So I copy this file(or create a new one and only put custom domain into this file) to the <code>source</code> directory of my hexo blog, and then commit and push it to the repository.</p><p>Everything works fine!</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nvim plugin - MakrdownPreview: can&#39;t preview</title>
      <link href="/2025/07/04/nvim-plugin-MakrdownPreview-can-t-preview/"/>
      <url>/2025/07/04/nvim-plugin-MakrdownPreview-can-t-preview/</url>
      
        <content type="html"><![CDATA[<h2 id="Env"><a href="#Env" class="headerlink" title="Env:"></a>Env:</h2><p>Nvim: v0.11.2 &amp; Lazyvim</p><p>Terminal: Kitty</p><p>OS: Arch Linux</p><h2 id="How-did-I-do"><a href="#How-did-I-do" class="headerlink" title="How did I do"></a>How did I do</h2><p>Create a .lua file in the following directory: <code>~/.config/nvim/lua/plugins/markdown-preview.lua</code></p><p>Then add the following code:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return &#123;</span><br><span class="line">&quot;iamcco/markdown-preview.nvim&quot;,</span><br><span class="line">cmd = &#123; &quot;MarkdownPreviewToggle&quot;, &quot;MarkdownPreview&quot;, &quot;MarkdownPreviewStop&quot; &#125;,</span><br><span class="line">ft = &#123; &quot;markdown&quot; &#125;,</span><br><span class="line">build = function()</span><br><span class="line">vim.fn[&quot;mkdp#util#install&quot;]()</span><br><span class="line">end,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Reopen nvim and run: <code>Lazy sync</code></p><p>Edit a markdown file:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># Hello</span></span><br><span class="line"><span class="section">## World</span></span><br><span class="line">![<span class="string">remote-img</span>](<span class="link">https://www.rust-lang.org/logos/rust-logo-512x512.png</span>)</span><br></pre></td></tr></table></figure><p>I got this message: <code>Nodejs v24.0.2</code> after run this command in nvim: <code>MarkdownPreview</code></p><p>Search in MarkdownPreview repo and found this issue: <a href="https://github.com/iamcco/markdown-preview.nvim/issues/695">https://github.com/iamcco/markdown-preview.nvim/issues/695</a></p><p>I tried like this issue and it worked!</p>]]></content>
      
      
      
        <tags>
            
            <tag> nvim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux挂载nfs根文件系统失败</title>
      <link href="/2025/01/04/linux%E6%8C%82%E8%BD%BDnfs%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A4%B1%E8%B4%A5/"/>
      <url>/2025/01/04/linux%E6%8C%82%E8%BD%BDnfs%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<p>挂在nfs根文件系统时出现如下报错：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[    1.939157] VFS: Cannot open root device <span class="string">&quot;nfs&quot;</span> or unknown-block(0,255): error -6</span><br><span class="line">[    1.946989] Please append a correct <span class="string">&quot;root=&quot;</span> boot option; here are the available partitions:</span><br><span class="line">[    1.955765] Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,255)</span><br><span class="line">[    1.964493] ---[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,255) ]---</span><br></pre></td></tr></table></figure><p>根据内核日志来看<code>bootargs</code>是设置正确的，经过多方排查是以下配置没开启：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CONFIG_ROOT_NFS</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tmux复制到系统剪切板</title>
      <link href="/2024/11/30/tmux%E5%A4%8D%E5%88%B6%E5%88%B0%E7%B3%BB%E7%BB%9F%E5%89%AA%E5%88%87%E6%9D%BF/"/>
      <url>/2024/11/30/tmux%E5%A4%8D%E5%88%B6%E5%88%B0%E7%B3%BB%E7%BB%9F%E5%89%AA%E5%88%87%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>tmux可以使用这个配置：<a href="https://github.com/gpakosz/.tmux">oh my tmux</a></p><p>然后在<code>.tmux.conf.local</code>中将以下选项设置为true：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -- clipboard -----------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># in copy mode, copying selection also copies to the OS clipboard</span></span><br><span class="line"><span class="comment">#   - true</span></span><br><span class="line"><span class="comment">#   - false (default)</span></span><br><span class="line"><span class="comment">#   - disabled</span></span><br><span class="line"><span class="comment"># on Linux, this requires xsel, xclip or wl-copy</span></span><br><span class="line">tmux_conf_copy_to_os_clipboard=<span class="literal">true</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lazyvim复制到剪切板</title>
      <link href="/2024/11/30/lazyvim%E5%A4%8D%E5%88%B6%E5%88%B0%E5%89%AA%E5%88%87%E6%9D%BF/"/>
      <url>/2024/11/30/lazyvim%E5%A4%8D%E5%88%B6%E5%88%B0%E5%89%AA%E5%88%87%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>在neovim(10.0.2)中，其实已经默认开启了yank插件，也就是复制的内容会自动传入剪切板。</p><p>那么为什么还会有这篇文章呢？因为lazyvim默认有这样一个配置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">opt.clipboard = vim.env.SSH_TTY and <span class="string">&quot;&quot;</span> or <span class="string">&quot;unnamedplus&quot;</span> -- Sync with system clipboard</span><br></pre></td></tr></table></figure><p>这句的意思查看你的shell是否是tty类型，如果是tty那么就不会进入系统剪切板。恰好ssh就是tty类型，所以ssh连接的shell在打开nvim复制的内容是不会进入到系统剪切板的。</p><p>进入系统剪切板的作用：<a href="https://blog.troy-y.org/2024/11/30/ssh%E5%8F%8C%E5%90%91%E5%A4%8D%E5%88%B6/">here</a></p><p>所以要在<code>~/.config/nvim/lua/config/option.lua</code>中覆盖这条默认设置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">opt.clipboard = <span class="string">&quot;unnamedplus&quot;</span></span><br></pre></td></tr></table></figure><p>这样即便tty也能够进入系统剪切板了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh双向复制</title>
      <link href="/2024/11/30/ssh%E5%8F%8C%E5%90%91%E5%A4%8D%E5%88%B6/"/>
      <url>/2024/11/30/ssh%E5%8F%8C%E5%90%91%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>在主机A通过ssh连接到主机B时，我们在A内复制的文本可以通过Ctrl+Shift+v粘贴到B，但是B内复制的却不能与A共享。</p><p>可能这里会造成一个疑惑：明明我复制ssh的shell信息也可以粘贴出来。其实这里复制复制的是终端上的字，并不是ssh的shell内复制，还是相当于本机复制。</p><p>这一点可以通过xsel工具做验证：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># A</span></span><br><span class="line">❯ xsel --clipboard --output</span><br><span class="line"></span><br><span class="line">Linux troy-server 6.8.0-49-generic <span class="comment">#49~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Wed Nov  6 17:42:15 UTC 2 x86_64 x86_64 x86_64 GNU/Linux</span></span><br><span class="line">\ No newline at end of selection</span><br><span class="line"><span class="comment"># B</span></span><br><span class="line">❯ xsel --clipboard --output    </span><br></pre></td></tr></table></figure><p>可以看到虽然A复制的B的终端输出信息，但是却没有进入B的剪切板，而是进入A的剪切板，说明复制的是终端上的字，并不是ssh的shell内复制。</p><p>如果这里做一个假设，在B的shell打开一个vim进行复制（已经配置好vim复制内容进入剪切板），此时B复制的内容A还能粘贴出来吗？答案是肯定不行的，因为进入的是B的剪切板而不是A的。</p><p>tmux也是同理，tmux中复制进入的是tmux的bufer，我们也可以配置成进入系统剪切板。但无论如何，开在B上面的tmux或vim进入的都是B的系统剪切板。所以这里要做的工作就是将A和B的系统剪切板共享。</p><h2 id="X11转发配置"><a href="#X11转发配置" class="headerlink" title="X11转发配置"></a>X11转发配置</h2><p>首先确保B上面安装了X11软件包(如果是server版本可能并没有安装)：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">sudo</span> apt install xorg xauth x11-apps xterm</span><br></pre></td></tr></table></figure><p>在B上面修改<code>/etc/ssh/sshd_config</code>以支持X11转发：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">X11Forwarding <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><p>重启sshd服务：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯<span class="built_in">sudo</span> systemctl restart sshd</span><br></pre></td></tr></table></figure><p>在A上面通过ssh连接启用X11转发有两种方式：</p><ul><li>方式1: <code>ssh -Y &lt;username&gt;@&lt;ip-addr&gt;</code></li><li>方式2: 添加<code>ForwardX11 yes</code>到config</li></ul><p>此时从A进入到B的shell中后，就可以运行如下命令测试x11是否转发：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xclock</span><br></pre></td></tr></table></figure><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p>在服务器配合这两个文档基本可以横着走：</p><p><a href="https://blog.troy-y.org/2024/11/30/tmux%E5%A4%8D%E5%88%B6%E5%88%B0%E7%B3%BB%E7%BB%9F%E5%89%AA%E5%88%87%E6%9D%BF/">tmux复制到剪切板</a><br><a href="https://blog.troy-y.org/2024/11/30/lazyvim%E5%A4%8D%E5%88%B6%E5%88%B0%E5%89%AA%E5%88%87%E6%9D%BF/">lazyvim复制到剪切板</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令行运行clash-verge</title>
      <link href="/2024/11/29/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8Cclash-verge/"/>
      <url>/2024/11/29/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8Cclash-verge/</url>
      
        <content type="html"><![CDATA[<p>由于太懒，不想配置clash core或者mihomo，就下了个clash verge，配置好之后断掉显示器启动电脑却发现clash-verge没有运行。</p><p>在Linux命令行中（tty, 没有display）是无法运行clash-verge的，如果直接运行，会出现：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ clash-verge</span><br><span class="line"></span><br><span class="line">(clash-verge:4357): Gtk-WARNING **: 20:22:40.304: cannot open display:</span><br></pre></td></tr></table></figure><p>使用虚拟显示器运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">sudo</span> apt install xvfb</span><br><span class="line">❯ Xvfb :1 -screen 0 1024x768x16 &amp;</span><br><span class="line">❯ <span class="built_in">export</span> DISPLAY=:1 </span><br><span class="line">❯ clash-verge &amp;</span><br></pre></td></tr></table></figure><p>此时还不能科学，需要等待1到3秒左右，等待完成后查询端口是否监听成功（verge监听7897）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ netstat -tuln | grep 7897</span><br><span class="line"></span><br><span class="line">tcp        0      0 127.0.0.1:7897          0.0.0.0:*               LISTEN</span><br><span class="line">udp        0      0 127.0.0.1:7897          0.0.0.0:*</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu网线连接开发板后无法上网</title>
      <link href="/2024/11/28/Ubuntu%E7%BD%91%E7%BA%BF%E8%BF%9E%E6%8E%A5%E5%BC%80%E5%8F%91%E6%9D%BF%E5%90%8E%E6%97%A0%E6%B3%95%E4%B8%8A%E7%BD%91/"/>
      <url>/2024/11/28/Ubuntu%E7%BD%91%E7%BA%BF%E8%BF%9E%E6%8E%A5%E5%BC%80%E5%8F%91%E6%9D%BF%E5%90%8E%E6%97%A0%E6%B3%95%E4%B8%8A%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ ip route</span><br><span class="line"></span><br><span class="line">default via 192.168.8.1 dev enx00e099a751b1 proto static metric 100</span><br><span class="line">default via 192.168.5.1 dev wlp1s0 proto dhcp metric 600</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中enx00e099a751b1是连接开发板的有线网卡，wlp1s0是无线网卡。<br>他们两个都走了default的默认路由。但是连接开发板的有线网卡是手动配置的静态IP，肯定不能上网的，如果由enx00e099a751b1去路由流量，肯定就不能上网了。<br>所以我们要删除这个路由，将enx00e099a751b1只路由192.168.8.x的流量。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">sudo</span> ip route del default via 192.168.8.1 dev enx00e099a751b1</span><br><span class="line">❯ <span class="built_in">sudo</span> ip route add 192.168.8.0/24 dev enx00e099a751b1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nextcloud aio + cloudflare tunnel</title>
      <link href="/2024/11/23/nextcloud-aio-cloudflare-tunnel/"/>
      <url>/2024/11/23/nextcloud-aio-cloudflare-tunnel/</url>
      
        <content type="html"><![CDATA[<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://blog.laoda.de/archives/docker-compose-install-nextcloud-aio">https://blog.laoda.de/archives/docker-compose-install-nextcloud-aio</a><br><a href="https://github.com/nextcloud/all-in-one">https://github.com/nextcloud/all-in-one</a><br><a href="https://github.com/nextcloud/all-in-one#how-to-change-the-default-location-of-nextclouds-datadir">https://github.com/nextcloud/all-in-one#how-to-change-the-default-location-of-nextclouds-datadir</a><br><a href="https://github.com/nextcloud/all-in-one/blob/main/reverse-proxy.md">https://github.com/nextcloud/all-in-one/blob/main/reverse-proxy.md</a><br><a href="https://help.nextcloud.com/t/using-nextcloud-aio-via-cloudflare-argo-tunnel/141376/4">https://help.nextcloud.com/t/using-nextcloud-aio-via-cloudflare-argo-tunnel/141376/4</a><br><a href="https://github.com/nextcloud/all-in-one/discussions/2845">https://github.com/nextcloud/all-in-one/discussions/2845</a><br><a href="https://github.com/nextcloud/all-in-one#how-to-run-nextcloud-behind-a-cloudflare-tunnel">https://github.com/nextcloud/all-in-one#how-to-run-nextcloud-behind-a-cloudflare-tunnel</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Google cloud console免费shell玩法</title>
      <link href="/2024/10/31/Goold-cloud-consle%E5%85%8D%E8%B4%B9shell%E7%8E%A9%E6%B3%95/"/>
      <url>/2024/10/31/Goold-cloud-consle%E5%85%8D%E8%B4%B9shell%E7%8E%A9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Prep"><a href="#Prep" class="headerlink" title="Prep"></a>Prep</h2><p>Google cloud console我并不清楚是个什么东西，由<a href="https://github.com/per1cycle">percycle</a>提供给我。直到现在，我只知道我能通过它创建12个shell配额。</p><p>此<code>shell</code>运行在<code>docker</code>中，并没有提供<code>公网IP</code>，这意味着可玩性大大降低，不能当作<code>server</code>使用。</p><p>目前已知的玩法：</p><ul><li>Tailscale exit node</li></ul><p>Link here: <a href="https://console.cloud.google.com/">https://console.cloud.google.com/</a></p><p><strong>PS:本文假设您已经注册了tailscale并且了解tailscale与tailscale exit node是什么</strong></p><h2 id="Tailscale"><a href="#Tailscale" class="headerlink" title="Tailscale"></a>Tailscale</h2><p>首先创建此文件以摆脱烦人的警告：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p ~/.cloudshell/</span><br><span class="line">$ <span class="built_in">touch</span> ~/.cloudshell/no-apt-get-warning</span><br></pre></td></tr></table></figure><p>使用如下命令安装tailscale:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -fsSL https://tailscale.com/install.sh | sh</span><br></pre></td></tr></table></figure><p>此时收到调用<code>tailscale up</code>进行登陆，但这里不要直接使用该命令，因为我们需要作为<code>exit node</code>使用，所以要通过如下命令:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> tailscale up --advertise-exit-node</span><br></pre></td></tr></table></figure><p>执行该命令后应该会收到一条提示，提示<code>tailscaled</code>并没有运行，这可能是因为<code>tailscaled</code>默认使用<code>systemd</code>启动，而这个容器并没有提供<code>systemd</code>。</p><p>可以直接调用<code>tailscaled</code>或者使用<code>service</code>启动：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> tailscaled</span><br><span class="line"><span class="comment"># $ sudo service tailscaled start</span></span><br></pre></td></tr></table></figure><p>重新运行up命令，此时应该收到一条提示登录的消息，在电脑上打开该链接进行登录。</p><p>登录之后需要在<code>tailscale</code>控制台打开该<code>exit node</code>：</p><p><a href="https://postimg.cc/k2m5Yh4G"><img src="https://i.postimg.cc/7ZCT6Fr3/2024-10-31-23-03-38.png" alt="2024-10-31-23-03-38.png"></a></p><p><a href="https://postimg.cc/gXQzVgQY"><img src="https://i.postimg.cc/gjkxP5K6/2024-10-31-23-04-11.png" alt="2024-10-31-23-04-11.png"></a></p><p>此时就应该将流量转发到<code>exit node</code>了，这个容器应该会根据你开的梯的IP地址所开启，我开的是台湾的梯，容器就是台湾的。这一点可以通过<code>ip138</code>确认是否流量转发成功:</p><p><a href="https://postimg.cc/PNDTGz0w"><img src="https://i.postimg.cc/2jc6Z0w2/2024-10-31-22-17-23.png" alt="2024-10-31-22-17-23.png"></a></p><p>此外，该容器没有外网ip，可以使用<code>tailscale</code>提供的局域网ip进行连接，不过关闭了密码连接，我们也不知道密码。可以使用<code>ssh key</code>进行连接，这点是很通常的操作，我留给你去自己完成。</p><p>提供成功<code>ssh</code>截图：</p><p><a href="https://postimg.cc/kB4rJQps"><img src="https://i.postimg.cc/CLCw4JC3/2024-10-31-22-39-31.png" alt="2024-10-31-22-39-31.png"></a></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://tailscale.com/download">https://tailscale.com/download</a><br><a href="https://tailscale.com/kb/1103/exit-nodes?tab=linux">https://tailscale.com/kb/1103/exit-nodes?tab=linux</a></p>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rk3568刷写openharmony4.1</title>
      <link href="/2024/10/29/rk3568%E5%88%B7%E5%86%99openharmony4-1/"/>
      <url>/2024/10/29/rk3568%E5%88%B7%E5%86%99openharmony4-1/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> upgrade_tool di -p parameter.txt</span><br><span class="line"><span class="built_in">sudo</span> upgrade_tool UL MiniLoaderAll.bin -noreset</span><br><span class="line"><span class="built_in">sudo</span> upgrade_tool di -u uboot.img &amp;&amp; <span class="built_in">sudo</span> upgrade_tool di -boot_linux boot_linux.img&amp;&amp; <span class="built_in">sudo</span> upgrade_tool di -system system.img &amp;&amp; <span class="built_in">sudo</span> upgrade_tool di -vendor vendor.img &amp;&amp; <span class="built_in">sudo</span> upgrade_tool di -userdata userdata.img &amp;&amp; <span class="built_in">sudo</span> upgrade_tool di -ramdisk ramdisk.img &amp;&amp; <span class="built_in">sudo</span> upgrade_tool di -resource resource.img &amp;&amp; <span class="built_in">sudo</span> upgrade_tool di -sys-prod sys_prod.img &amp;&amp; <span class="built_in">sudo</span> upgrade_tool di -chip-prod chip_prod.img &amp;&amp; <span class="built_in">sudo</span> upgrade_tool di -eng_system eng_system.img&amp;&amp; <span class="built_in">sudo</span> upgrade_tool di -updater updater.img &amp;&amp; <span class="built_in">sudo</span> upgrade_tool di -chip_ckm chip_ckm.img</span><br><span class="line"><span class="built_in">sudo</span> upgrade_tool rd </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> openHarmony </tag>
            
            <tag> rk3568 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu22.04.4LTS安装AMD显卡驱动</title>
      <link href="/2024/10/05/Ubuntu22-04-4LTS%E5%AE%89%E8%A3%85AMD%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8/"/>
      <url>/2024/10/05/Ubuntu22-04-4LTS%E5%AE%89%E8%A3%85AMD%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>AMD 7840HS core GPU driver: <a href="https://github.com/TroyMitchell911/Ubuntu-config/blob/main/deb/amdgpu-install_6.1.60103-1_all.deb">https://github.com/TroyMitchell911/Ubuntu-config/blob/main/deb/amdgpu-install_6.1.60103-1_all.deb</a> </p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[TMUX]复制内容到系统剪切板</title>
      <link href="/2024/10/05/TMUX-%E5%A4%8D%E5%88%B6%E5%86%85%E5%AE%B9%E5%88%B0%E7%B3%BB%E7%BB%9F%E5%89%AA%E5%88%87%E6%9D%BF/"/>
      <url>/2024/10/05/TMUX-%E5%A4%8D%E5%88%B6%E5%86%85%E5%AE%B9%E5%88%B0%E7%B3%BB%E7%BB%9F%E5%89%AA%E5%88%87%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>安装软件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install xclip  <span class="comment"># 或者使用 xsel</span></span><br></pre></td></tr></table></figure><p>在&#96;&#96;～&#x2F;.tmux.conf<code>或者</code>~&#x2F;.tmux.conf.local&#96;中添加如下内容：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bind-key -T copy-mode-vi y send-keys -X copy-pipe-and-cancel <span class="string">&quot;xclip -sel clip -i&quot;</span></span><br></pre></td></tr></table></figure><p>重新加载<code>tmux</code>配置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux source-file ~/.tmux.conf</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> tmux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[VIM]plug coc.nvim</title>
      <link href="/2024/10/03/VIM-plug-coc-nvim-1/"/>
      <url>/2024/10/03/VIM-plug-coc-nvim-1/</url>
      
        <content type="html"><![CDATA[<p>在coc.nvim更新到0.0.82之后，shortcut映射方式改变。</p><p>.vimrc配置如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>! CheckBackSpace() abort</span><br><span class="line">  <span class="built_in">let</span> col = col(<span class="string">&#x27;.&#x27;</span>) - 1</span><br><span class="line">  <span class="built_in">return</span> !col || getline(<span class="string">&#x27;.&#x27;</span>)[col - 1]  =~ <span class="string">&#x27;\s&#x27;</span></span><br><span class="line">endfunction</span><br><span class="line">inoremap &lt;silent&gt;&lt;<span class="built_in">expr</span>&gt; &lt;TAB&gt;</span><br><span class="line">      \ coc#pum#visible() ? coc#pum#next(1):</span><br><span class="line">      \ CheckBackSpace() ? <span class="string">&quot;\&lt;Tab&gt;&quot;</span> :</span><br><span class="line">      \ coc#refresh()</span><br><span class="line">inoremap &lt;<span class="built_in">expr</span>&gt;&lt;S-TAB&gt; coc#pum#visible() ? coc#pum#prev(1) : <span class="string">&quot;\&lt;C-h&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; below is for using ENTER for completion, I actually don&#x27;t like it, CTRL+Y works better for me, you can omit this part if you are like me</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">inoremap &lt;silent&gt;&lt;expr&gt; &lt;cr&gt; coc#pum#visible() &amp;&amp; coc#pum#info()[&#x27;index&#x27;] != -1 ? coc#pum#confirm() :</span></span><br><span class="line"><span class="string">        \ &quot;</span>\&lt;C-g&gt;u\&lt;CR&gt;\&lt;c-r&gt;=coc#on_enter()\&lt;CR&gt;<span class="string">&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何将sd卡或者emmc镜像导出</title>
      <link href="/2024/09/21/%E5%A6%82%E4%BD%95%E5%B0%86sd%E5%8D%A1%E6%88%96%E8%80%85emmc%E9%95%9C%E5%83%8F%E5%AF%BC%E5%87%BA/"/>
      <url>/2024/09/21/%E5%A6%82%E4%BD%95%E5%B0%86sd%E5%8D%A1%E6%88%96%E8%80%85emmc%E9%95%9C%E5%83%8F%E5%AF%BC%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="SD卡"><a href="#SD卡" class="headerlink" title="SD卡"></a>SD卡</h2><p>插入<code>sd卡</code>后，会在<code>/dev</code>下看到<code>sdX</code>的文件，我这里是<code>sdb</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">ls</span> /dev/sdb*</span><br><span class="line">/dev/sdb  /dev/sdb1  /dev/sdb2</span><br></pre></td></tr></table></figure><p>从这个信息可以知道镜像至少分区为了<code>boot</code>和<code>rootfs分区</code>.</p><p>使用dd命令导出：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">sudo</span> <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sdb of=sd.img bs=4M status=progress</span><br><span class="line">[<span class="built_in">sudo</span>] troy 的密码： </span><br><span class="line">63753420800字节（64 GB，59 GiB）已复制，652 s，97.8 MB/s </span><br><span class="line">记录了15218+1 的读入</span><br><span class="line">记录了15218+1 的写出</span><br><span class="line">63831015424字节（64 GB，59 GiB）已复制，653.304 s，97.7 MB/s</span><br></pre></td></tr></table></figure><p>导出后需要<a href="##%E7%BC%A9%E5%87%8F%E5%88%86%E5%8C%BA">缩减分区</a></p><h2 id="EMMC"><a href="#EMMC" class="headerlink" title="EMMC"></a>EMMC</h2><p>对于EMMC操作复杂一些，需要修改uboot，打开CONFIG_CMD_USB_MASS_STORAGE的配置项。</p><p>进入fel模式将uboot下载进入内存并运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">sudo</span> sunxi-fel uboot ./u-boot-sunxi-with-spl.bin</span><br></pre></td></tr></table></figure><p>在uboot自动启动内核前打断，并且输入如下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; ums 2 mmc 1</span><br></pre></td></tr></table></figure><p>这个命令是将mmc的1号设备通过usb 2号挂载出去。就相当于电脑插了个U盘。</p><p>我这里mmc的1号设备是emmc，usb2号是otg接口，需要根据实际情况修改。</p><p>使用如下命令可查询对应的接口号：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; mmc list</span><br><span class="line">=&gt; usb tree</span><br><span class="line"><span class="comment"># 或者是usb info</span></span><br></pre></td></tr></table></figure><p>然后电脑就能看到了<code>/dev/sdX</code>，随后的操作与SD卡相同。</p><h2 id="缩减分区"><a href="#缩减分区" class="headerlink" title="缩减分区"></a>缩减分区</h2><p>由于镜像中有多个分区，所以先关联到回环设备：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">sudo</span> losetup -Pf sd.img</span><br><span class="line">❯ <span class="built_in">ls</span> /dev/loop*p*</span><br><span class="line">/dev/loop15p1  /dev/loop15p2</span><br></pre></td></tr></table></figure><p>这里就挂出来了两个分区，<code>p1</code>是<code>boot</code>，<code>p2</code>是<code>rootfs</code>，我们仅需要将rootfs分区缩减，因为他是大头。</p><p>打开<code>Ubuntu</code>自带的磁盘工具，调整<code>rootfs</code>大小为最小:</p><p><a href="https://postimg.cc/mtbsrLJx"><img src="https://i.postimg.cc/yYRYvWTN/2024-09-21-11-30-46.png" alt="2024-09-21-11-30-46.png"></a></p><p>调整完成后如下图所示：</p><p><a href="https://postimg.cc/XGSM64dz"><img src="https://i.postimg.cc/ZR0J3qR4/2024-09-21-11-32-23.png" alt="2024-09-21-11-32-23.png"></a></p><p>已经成功调整了分区 <code>/dev/loop15p2</code> 的大小到 1.7GB，但 <code>sd.img</code> 仍然保持 60GB，原因是文件系统和分区的大小确实已经改变，但镜像文件本身的大小并没有自动缩减：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">sudo</span> fdisk -l /dev/loop15</span><br><span class="line">Disk /dev/loop15：59.45 GiB，63831015424 字节，124669952 个扇区</span><br><span class="line">单元：扇区 / 1 * 512 = 512 字节</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0x8c4a4ad7</span><br><span class="line"></span><br><span class="line">设备          启动  起点    末尾    扇区  大小 Id 类型</span><br><span class="line">/dev/loop15p1       2048   67583   65536   32M  6 FAT16</span><br><span class="line">/dev/loop15p2      67584 3588095 3520512  1.7G 83 Linux</span><br><span class="line">❯ <span class="built_in">ls</span> -lh sd.img</span><br><span class="line">-rw-r--r-- 1 root root 60G  9月 21 11:31 sd.img</span><br></pre></td></tr></table></figure><p>需要手动缩减镜像文件的大小，使其匹配实际使用的分区大小。</p><p> <code>/dev/loop15p2</code> 的结束位置是扇区 <code>3588095</code>，镜像文件的大小可以通过这个结束位置来确定。</p><p>由于每个扇区大小为 512 字节，可以计算出新的镜像文件大小：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">新镜像大小 = (最后一个扇区号 + 1) * 扇区大小</span><br></pre></td></tr></table></figure><p>最后一个扇区是 <code>3588095</code>，所以新的镜像大小为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">新镜像大小 = (3588095 + 1) * 512 = 1838080512 字节</span><br></pre></td></tr></table></figure><p>使用<code>truncate</code>缩减镜像：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">sudo</span> <span class="built_in">truncate</span> --size=$(( (<span class="number">3588095</span> + <span class="number">1</span>) * <span class="number">512</span> )) sd.img</span><br><span class="line">❯ <span class="built_in">ls</span> -lh sd.img</span><br><span class="line">-rw-r--r-- 1 root root 1.8G  9月 21 11:35 sd.img</span><br></pre></td></tr></table></figure><p>完成后解除回环设备关联：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">sudo</span> losetup -d /dev/loop15</span><br></pre></td></tr></table></figure><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>将刚才制作好的镜像烧写进入，这里以sd卡为例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">sudo</span> <span class="built_in">dd</span> <span class="keyword">if</span>=sd.img of=/dev/sdb status=progress</span><br><span class="line">1827463680字节（1.8 GB，1.7 GiB）已复制，230 s，7.9 MB/s </span><br><span class="line">记录了3588096+0 的读入</span><br><span class="line">记录了3588096+0 的写出</span><br><span class="line">1837105152字节（1.8 GB，1.7 GiB）已复制，230.959 s，8.0 MB/s</span><br></pre></td></tr></table></figure><p>启动系统查看是否正确。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@a33-vstar:~# lsblk</span><br><span class="line">NAME         MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS</span><br><span class="line">mmcblk0      179:0    0 59.4G  0 disk </span><br><span class="line">├─mmcblk0p1  179:1    0   32M  0 part </span><br><span class="line">└─mmcblk0p2  179:2    0  1.7G  0 part /</span><br><span class="line">mmcblk1      179:8    0  3.7G  0 disk </span><br><span class="line">├─mmcblk1p1  179:9    0   32M  0 part </span><br><span class="line">└─mmcblk1p2  179:10   0  3.7G  0 part </span><br><span class="line">mmcblk1boot0 179:16   0    2M  1 disk </span><br><span class="line">mmcblk1boot1 179:24   0    2M  1 disk </span><br><span class="line">root@a33-vstar:~# <span class="built_in">df</span> -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/root       1.4G  568M  741M  44% /</span><br><span class="line">tmpfs           232M     0  232M   0% /dev/shm</span><br><span class="line">tmpfs            93M  2.8M   90M   3% /run</span><br><span class="line">tmpfs           5.0M     0  5.0M   0% /run/lock</span><br><span class="line">tmpfs            47M     0   47M   0% /run/user/0</span><br></pre></td></tr></table></figure><p>可以看到mmcblk0p2确实变成了1.7G，但是剩余的空间并没有使用到，此时就需要扩展文件系统分区：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@a33-vstar:~# <span class="built_in">sudo</span> parted /dev/mmcblk0 --script resizepart 2 100%</span><br><span class="line">Kernel not configured <span class="keyword">for</span> semaphores (System V IPC). Not using udev synchronisation code.</span><br><span class="line">root@a33-vstar:~# <span class="built_in">sudo</span> resize2fs /dev/mmcblk0p2</span><br><span class="line">resize2fs 1.46.5 (30-Dec-2021)</span><br><span class="line">Filesystem at /dev/mmcblk0p2 is mounted on /; on-line resizing required</span><br><span class="line">old_desc_blocks = 1, new_desc_blocks = 4</span><br><span class="line">The filesystem on /dev/mmcblk0p2 is now 15575296 (4k) blocks long.</span><br><span class="line">root@a33-vstar:~# lsblk</span><br><span class="line">NAME         MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS</span><br><span class="line">mmcblk0      179:0    0 59.4G  0 disk </span><br><span class="line">├─mmcblk0p1  179:1    0   32M  0 part </span><br><span class="line">└─mmcblk0p2  179:2    0 59.4G  0 part /</span><br><span class="line">mmcblk1      179:8    0  3.7G  0 disk </span><br><span class="line">├─mmcblk1p1  179:9    0   32M  0 part </span><br><span class="line">└─mmcblk1p2  179:10   0  3.7G  0 part </span><br><span class="line">mmcblk1boot0 179:16   0    2M  1 disk </span><br><span class="line">mmcblk1boot1 179:24   0    2M  1 disk</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> linux </tag>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[rootfs]制作Ubuntu根文件系统</title>
      <link href="/2024/09/20/rootfs-%E5%88%B6%E4%BD%9CUbuntu%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/09/20/rootfs-%E5%88%B6%E4%BD%9CUbuntu%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p><strong>Requirements</strong></p><ol><li>An x86_64 machine with Ubuntu or another Linux distribution installed.</li><li><code>debootstrap</code> tool.</li><li>Internet connection.</li><li>Basic knowledge of using the terminal.</li></ol><p><strong>Steps to Create Ubuntu 20.04 Rootfs for ARMhf</strong></p><p><strong>1. Install Required Tools</strong></p><p>First, ensure that <code>debootstrap</code> and <code>qemu-user-static</code> are installed. <code>qemu-user-static</code> allows you to run ARM binaries on your x86_64 machine.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install debootstrap qemu-user-static</span><br></pre></td></tr></table></figure><p><strong>2. Create a Directory for the Rootfs</strong></p><p>Create a directory where the root filesystem will be built.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/ubuntu-armhf-rootfs</span><br></pre></td></tr></table></figure><p><strong>3. Run Debootstrap</strong></p><p>Use <code>debootstrap</code> to create the root filesystem. Specify the architecture (<code>armhf</code>), the Ubuntu release (<code>focal</code>), and the target directory.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo debootstrap --arch=armhf --foreign focal ./ubuntu-armhf-rootfs https://mirrors.bfsu.edu.cn/ubuntu-ports/</span><br></pre></td></tr></table></figure><p><strong>4. Copy QEMU Binary</strong></p><p>Copy the <code>qemu-arm-static</code> binary into the <code>usr/bin</code> directory of the new rootfs to enable emulation.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo cp /usr/bin/qemu-arm-static ./ubuntu-armhf-rootfs/usr/bin/</span><br></pre></td></tr></table></figure><p><strong>5. Chroot into the New Rootfs</strong></p><p>Change root into the new root filesystem to complete the second stage of debootstrap.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chroot ./ubuntu-armhf-rootfs</span><br></pre></td></tr></table></figure><p><strong>6. Complete Debootstrap Second Stage</strong></p><p>Inside the chroot environment, run the second stage of debootstrap.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/debootstrap/debootstrap --second-stage</span><br></pre></td></tr></table></figure><p><strong>7. Configure the Rootfs</strong></p><p>Now configure the basic settings of your new root filesystem.</p><p>- <strong>Set the hostname:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;ubuntu-armhf&quot; &gt; /etc/hostname</span><br></pre></td></tr></table></figure><p>- <strong>Set up the hosts file:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOL &gt; /etc/hosts</span><br><span class="line">127.0.0.1   localhost</span><br><span class="line">127.0.1.1   ubuntu-armhf</span><br><span class="line">EOL</span><br></pre></td></tr></table></figure><p>- <strong>Create fstab:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOL &gt; /etc/fstab</span><br><span class="line">proc            /proc           proc    defaults        0       0</span><br><span class="line">sysfs           /sys            sysfs   defaults        0       0</span><br><span class="line">devpts          /dev/pts        devpts  gid=5,mode=620  0       0</span><br><span class="line">tmpfs           /run            tmpfs   defaults        0       0</span><br><span class="line">tmpfs           /run/lock       tmpfs   nodev,nosuid,noexec 0   0</span><br><span class="line">EOL</span><br></pre></td></tr></table></figure><p>- <strong>Set up networking:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOL &gt; /etc/network/interfaces</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet dhcp</span><br><span class="line">EOL</span><br></pre></td></tr></table></figure><p>- <strong>Set the root password:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure><p>- <strong>Create a user:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adduser ubuntu</span><br><span class="line">usermod -aG sudo ubuntu</span><br></pre></td></tr></table></figure><p>- <strong>Install essential packages:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install sudo nano ssh net-tools network-manager usbutils</span><br></pre></td></tr></table></figure><p><strong>8. Exit the Chroot</strong></p><p>Exit the chroot environment.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><p><strong>9. Clean Up</strong></p><p>Remove the <code>qemu-arm-static</code> binary from the rootfs.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo rm ./ubuntu-armhf-rootfs/usr/bin/qemu-arm-static</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[全志A33-Vstar]Kernel</title>
      <link href="/2024/09/20/%E5%85%A8%E5%BF%97A33-Vstar-Kernel/"/>
      <url>/2024/09/20/%E5%85%A8%E5%BF%97A33-Vstar-Kernel/</url>
      
        <content type="html"><![CDATA[<p><strong>本文章基于该uboot启动</strong>：<a href="https://blog.troy-y.org/2024/09/13/%E5%85%A8%E5%BF%97A33-Uboot/">传送门</a></p><h2 id="Env"><a href="#Env" class="headerlink" title="Env"></a>Env</h2><p>cpu: allwinner a33<br>board: vstar<br>host: ubuntu 22.04</p><p>需要安装交叉编译工具链：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">sudo</span> apt install gcc-arm-none-eabi</span><br></pre></td></tr></table></figure><h2 id="mainline"><a href="#mainline" class="headerlink" title="mainline"></a>mainline</h2><p>首先下载主线kernel的源码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ git <span class="built_in">clone</span> git@github.com:torvalds/linux.git</span><br></pre></td></tr></table></figure><p>配置文件的话，在<code>arch/arm/configs</code>目录下只有一个<code>sunxi_defconfig</code>是我们能够使用的，那么就使用这个配置文件作为基准。</p><p>设备树就选择sinlinx的，与vstar开发板相近。</p><p>与uboot套路类似，先拷贝一份配置文件和设备树作为vstar开发板的：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">cp</span> <span class="built_in">arch</span>/arm/configs/sunxi_defconfig <span class="built_in">arch</span>/arm/configs/a33_vstar_defconfig</span><br><span class="line">❯ <span class="built_in">cp</span> <span class="built_in">arch</span>/arm/boot/dts/allwinner/sun8i-a33-sinlinx-sina33.dts <span class="built_in">arch</span>/arm/boot/dts/allwinner/sun8i-a33-vstar.dts</span><br></pre></td></tr></table></figure><p>修改Makefile支持该设备树：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">diff --git a/arch/arm/boot/dts/allwinner/Makefile b/arch/arm/boot/dts/allwinner/Makefile</span><br><span class="line">index cd0d044882cf..d548f4a2621a 100644</span><br><span class="line">--- a/arch/arm/boot/dts/allwinner/Makefile</span><br><span class="line">+++ b/arch/arm/boot/dts/allwinner/Makefile</span><br><span class="line">@@ -215,6 +215,7 @@ dtb-$(CONFIG_MACH_SUN8I) += \</span><br><span class="line">        sun8i-a33-olinuxino.dtb \</span><br><span class="line">        sun8i-a33-q8-tablet.dtb \</span><br><span class="line">        sun8i-a33-sinlinx-sina33.dtb \</span><br><span class="line">+       sun8i-a33-vstar.dtb \</span><br><span class="line">        sun8i-a83t-allwinner-h8homlet-v2.dtb \</span><br><span class="line">        sun8i-a83t-bananapi-m3.dtb \</span><br><span class="line">        sun8i-a83t-cubietruck-plus.dtb \</span><br></pre></td></tr></table></figure><p>使用刚才拷贝的配置文件进行编译：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- a33_vstar_defconfig</span><br><span class="line">❯ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j16</span><br></pre></td></tr></table></figure><p>可以看到镜像文件和设备树都已经生成：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">ls</span> <span class="built_in">arch</span>/arm/boot/zImage</span><br><span class="line"><span class="built_in">arch</span>/arm/boot/zImage</span><br><span class="line">❯ <span class="built_in">ls</span> <span class="built_in">arch</span>/arm/boot/dts/allwinner/sun8i-a33-vstar.dtb</span><br><span class="line"><span class="built_in">arch</span>/arm/boot/dts/allwinner/sun8i-a33-vstar.dtb</span><br></pre></td></tr></table></figure><p>使用<a href="https://blog.troy-y.org/2024/09/20/sd%E4%B8%8Emmc%E5%88%B7%E5%86%99%E6%8C%87%E5%8D%97/">这篇文章</a>的技巧将kernel和dtb装入sd卡boot分区，装入emmc的boot分区也是可以的。</p><p><strong>PS：其实这里使用tftp更加合理，但在家中没有网口环境，所以只能退而求其次这样调试了。</strong></p><p>在uboot中执行如下命令查看boot分区：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; fatls mmc 0:1</span><br><span class="line">    65536   uboot.env</span><br><span class="line">    23345   sun8i-a33-vstar.dtb</span><br><span class="line">  5496008   zImage</span><br><span class="line"></span><br><span class="line">3 file(s), 0 <span class="built_in">dir</span>(s)</span><br></pre></td></tr></table></figure><p>现在文件已经装好了，就差装载地址了，在uboot中查看kernel的加载地址和dtb的加载地址：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; <span class="built_in">printenv</span> kernel_addr_r </span><br><span class="line">kernel_addr_r=0x42000000</span><br><span class="line">=&gt; <span class="built_in">printenv</span> fdt_addr_r </span><br><span class="line">fdt_addr_r=0x43000000</span><br></pre></td></tr></table></figure><p>可以确定内核的加载地址是<code>0x42000000</code>，设备树的加载地址是<code>0x43000000</code>.</p><p>使用load命令加载：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; load mmc 0:1 0x42000000 zImage</span><br><span class="line">5496008 bytes <span class="built_in">read</span> <span class="keyword">in</span> 229 ms (22.9 MiB/s)</span><br><span class="line">=&gt; load mmc 0:1 0x43000000 sun8i-a33-vstar.dtb</span><br><span class="line">23345 bytes <span class="built_in">read</span> <span class="keyword">in</span> 3 ms (7.4 MiB/s)</span><br></pre></td></tr></table></figure><p>由于内核镜像是经过压缩的，所以这里使用<code>bootz</code>命令进行启动：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; bootz 0x42000000 - 0x43000000</span><br><span class="line">Kernel image @ 0x42000000 [ 0x000000 - 0x53dcc8 ]</span><br><span class="line"><span class="comment">## Flattened Device Tree blob at 43000000</span></span><br><span class="line">   Booting using the fdt blob at 0x43000000</span><br><span class="line">Working FDT <span class="built_in">set</span> to 43000000</span><br><span class="line">   Loading Device Tree to 49ff7000, end 49fffb30 ... OK</span><br><span class="line">Working FDT <span class="built_in">set</span> to 49ff7000</span><br><span class="line"></span><br><span class="line">Starting kernel ...</span><br><span class="line"></span><br><span class="line">cyclic <span class="keyword">function</span> video_init took too long: 27000us vs 5000us max</span><br><span class="line">[    0.000000] Booting Linux on physical CPU 0x0</span><br><span class="line">[    0.000000] Linux version 6.11.0-rc6-00309-gd2742e387fe4 (troy@troy-WUJIE14-PRO) (arm-linux-gnueabihf-gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0, GNU ld (GNU Bin</span><br><span class="line">utils <span class="keyword">for</span> Ubuntu) 2.38) <span class="comment">#4 SMP Fri Sep 20 22:58:32 CST 2024</span></span><br><span class="line">[    0.000000] CPU: ARMv7 Processor [410fc075] revision 5 (ARMv7), cr=10c5387d</span><br><span class="line">[    0.000000] CPU: div instructions available: patching division code</span><br><span class="line">[    0.000000] CPU: PIPT / VIPT nonaliasing data cache, VIPT aliasing instruction cache</span><br><span class="line">[    0.000000] OF: fdt: Machine model: Sinlinx SinA33</span><br><span class="line">[    0.000000] Memory policy: Data cache writealloc</span><br><span class="line">[    0.000000] cma: Reserved 16 MiB at 0x5d000000 on node -1</span><br><span class="line">[    0.000000] Zone ranges:</span><br><span class="line">[    0.000000]   Normal   [mem 0x0000000040000000-0x000000005dffffff]</span><br><span class="line">[    0.000000]   HighMem  empty</span><br><span class="line">[    0.000000] Movable zone start <span class="keyword">for</span> each node</span><br><span class="line">[    0.000000] Early memory node ranges</span><br><span class="line">[    0.000000]   node   0: [mem 0x0000000040000000-0x000000005dffffff]</span><br><span class="line">[    0.000000] Initmem setup node 0 [mem 0x0000000040000000-0x000000005dffffff]</span><br><span class="line">[    0.000000] psci: probing <span class="keyword">for</span> conduit method from DT.</span><br><span class="line">[    0.000000] psci: Using PSCI v0.1 Function IDs from DT</span><br><span class="line">[    0.000000] percpu: Embedded 13 pages/cpu s20876 r8192 d24180 u53248</span><br><span class="line">[    0.000000] Kernel <span class="built_in">command</span> line: </span><br><span class="line">[    0.000000] Dentry cache <span class="built_in">hash</span> table entries: 65536 (order: 6, 262144 bytes, linear)</span><br><span class="line">[    0.000000] Inode-cache <span class="built_in">hash</span> table entries: 32768 (order: 5, 131072 bytes, linear)</span><br><span class="line">[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: 122880</span><br><span class="line">[    0.000000] mem auto-init: stack:off, heap alloc:off, heap free:off</span><br><span class="line">[    0.000000] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=4, Nodes=1</span><br><span class="line">[    0.000000] rcu: Hierarchical RCU implementation.</span><br><span class="line">[    0.000000] rcu:     RCU restricting CPUs from NR_CPUS=8 to nr_cpu_ids=4.</span><br><span class="line">[    0.000000] rcu: RCU calculated value of scheduler-enlistment delay is 10 jiffies.</span><br><span class="line">[    0.000000] rcu: Adjusting geometry <span class="keyword">for</span> rcu_fanout_leaf=16, nr_cpu_ids=4</span><br><span class="line">[    0.000000] NR_IRQS: 16, nr_irqs: 16, preallocated irqs: 16</span><br><span class="line">[    0.000000] GIC: Using <span class="built_in">split</span> EOI/Deactivate mode</span><br><span class="line">[    0.000000] rcu: srcu_init: Setting srcu_struct sizes based on contention.</span><br><span class="line">[    0.000000] arch_timer: cp15 timer(s) running at 24.00MHz (phys).</span><br><span class="line">[    0.000000] clocksource: arch_sys_counter: mask: 0xffffffffffffff max_cycles: 0x588fe9dc0, max_idle_ns: 440795202592 ns</span><br><span class="line">[    0.000002] sched_clock: 56 bits at 24MHz, resolution 41ns, wraps every 4398046511097ns</span><br><span class="line">[    0.000018] Switching to timer-based delay loop, resolution 41ns</span><br><span class="line">[    0.000214] clocksource: timer: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 79635851949 ns</span><br><span class="line">[    0.000716] Console: colour dummy device 80x30</span><br><span class="line">[    0.000737] printk: legacy console [tty0] enabled</span><br><span class="line">[    0.001150] Calibrating delay loop (skipped), value calculated using timer frequency.. 48.00 BogoMIPS (lpj=240000)</span><br><span class="line">[    0.001186] CPU: Testing write buffer coherency: ok</span><br><span class="line">[    0.001256] pid_max: default: 32768 minimum: 301</span><br><span class="line">[    0.001462] Mount-cache <span class="built_in">hash</span> table entries: 1024 (order: 0, 4096 bytes, linear)</span><br><span class="line">[    0.001501] Mountpoint-cache <span class="built_in">hash</span> table entries: 1024 (order: 0, 4096 bytes, linear)</span><br><span class="line">[    0.002532] /cpus/cpu@0 missing clock-frequency property</span><br><span class="line">[    0.002602] /cpus/cpu@1 missing clock-frequency property</span><br><span class="line">[    0.002636] /cpus/cpu@2 missing clock-frequency property</span><br><span class="line">[    0.002669] /cpus/cpu@3 missing clock-frequency property</span><br><span class="line">[    0.002694] CPU0: thread -1, cpu 0, socket 0, mpidr 80000000</span><br><span class="line">[    0.003911] Setting up static identity map <span class="keyword">for</span> 0x40100000 - 0x40100060</span><br><span class="line">[    0.004138] rcu: Hierarchical SRCU implementation.</span><br><span class="line">[    0.004168] rcu:     Max phase no-delay instances is 1000.</span><br><span class="line">[    0.004475] Timer migration: 1 hierarchy levels; 8 children per group; 1 crossnode level</span><br><span class="line">[    0.005197] smp: Bringing up secondary CPUs ...</span><br><span class="line">[    0.006381] CPU1: thread -1, cpu 1, socket 0, mpidr 80000001</span><br><span class="line">[    0.007615] CPU2: thread -1, cpu 2, socket 0, mpidr 80000002</span><br><span class="line">[    0.008778] CPU3: thread -1, cpu 3, socket 0, mpidr 80000003</span><br><span class="line">[    0.008903] smp: Brought up 1 node, 4 CPUs</span><br><span class="line">[    0.008972] SMP: Total of 4 processors activated (192.00 BogoMIPS).</span><br><span class="line">[    0.008993] CPU: All CPU(s) started <span class="keyword">in</span> HYP mode.</span><br><span class="line">[    0.009008] CPU: Virtualization extensions available.</span><br><span class="line">[    0.009739] Memory: 455244K/491520K available (8192K kernel code, 954K rwdata, 2404K rodata, 1024K init, 261K bss, 18116K reserved, 16384K cma-reserved, 0K high</span><br><span class="line">mem)</span><br><span class="line">[    0.010473] devtmpfs: initialized</span><br><span class="line">[    0.016216] VFP support v0.3: implementor 41 architecture 2 part 30 variant 7 rev 5</span><br><span class="line">[    0.016523] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 19112604462750000 ns</span><br><span class="line">[    0.016574] futex <span class="built_in">hash</span> table entries: 1024 (order: 4, 65536 bytes, linear)</span><br><span class="line">[    0.017387] pinctrl core: initialized pinctrl subsystem</span><br><span class="line">[    0.019573] NET: Registered PF_NETLINK/PF_ROUTE protocol family</span><br><span class="line">[    0.020760] DMA: preallocated 256 KiB pool <span class="keyword">for</span> atomic coherent allocations</span><br><span class="line">[    0.021844] thermal_sys: Registered thermal governor <span class="string">&#x27;step_wise&#x27;</span></span><br><span class="line">[    0.022011] hw-breakpoint: found 5 (+1 reserved) breakpoint and 4 watchpoint registers.</span><br><span class="line">[    0.022063] hw-breakpoint: maximum watchpoint size is 8 bytes.</span><br><span class="line">[    0.026636] platform 1c0c000.lcd-controller: Fixed dependency cycle(s) with /soc/drc@1e70000</span><br><span class="line">[    0.029751] platform 1e00000.display-frontend: Fixed dependency cycle(s) with /soc/display-backend@1e60000</span><br><span class="line">[    0.030124] platform 1e00000.display-frontend: Fixed dependency cycle(s) with /soc/display-backend@1e60000</span><br><span class="line">[    0.030236] platform 1e60000.display-backend: Fixed dependency cycle(s) with /soc/drc@1e70000</span><br><span class="line">[    0.030272] platform 1e60000.display-backend: Fixed dependency cycle(s) with /soc/display-frontend@1e00000</span><br><span class="line">[    0.030575] platform 1e60000.display-backend: Fixed dependency cycle(s) with /soc/drc@1e70000</span><br><span class="line">[    0.030674] platform 1c0c000.lcd-controller: Fixed dependency cycle(s) with /soc/drc@1e70000</span><br><span class="line">[    0.030773] platform 1e70000.drc: Fixed dependency cycle(s) with /soc/lcd-controller@1c0c000</span><br><span class="line">[    0.030874] platform 1e70000.drc: Fixed dependency cycle(s) with /soc/display-backend@1e60000</span><br><span class="line">[    0.033511] platform 1c0c000.lcd-controller: Fixed dependency cycle(s) with /panel</span><br><span class="line">[    0.033627] platform panel: Fixed dependency cycle(s) with /soc/lcd-controller@1c0c000</span><br><span class="line">[    0.037105] SCSI subsystem initialized</span><br><span class="line">[    0.037662] usbcore: registered new interface driver usbfs</span><br><span class="line">[    0.037724] usbcore: registered new interface driver hub</span><br><span class="line">[    0.037801] usbcore: registered new device driver usb</span><br><span class="line">[    0.038063] mc: Linux media interface: v0.10</span><br><span class="line">[    0.038129] videodev: Linux video capture interface: v2.00</span><br><span class="line">[    0.038229] pps_core: LinuxPPS API ver. 1 registered</span><br><span class="line">[    0.038250] pps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo Giometti &lt;giometti@linux.it&gt;</span><br><span class="line">[    0.038287] PTP clock support registered</span><br><span class="line">[    0.038843] Advanced Linux Sound Architecture Driver Initialized.</span><br><span class="line">[    0.040004] clocksource: Switched to clocksource arch_sys_counter</span><br><span class="line">[    0.049575] NET: Registered PF_INET protocol family</span><br><span class="line">[    0.049898] IP idents <span class="built_in">hash</span> table entries: 8192 (order: 4, 65536 bytes, linear)</span><br><span class="line">[    0.051275] tcp_listen_portaddr_hash <span class="built_in">hash</span> table entries: 512 (order: 0, 4096 bytes, linear)</span><br><span class="line">[    0.051335] Table-perturb <span class="built_in">hash</span> table entries: 65536 (order: 6, 262144 bytes, linear)</span><br><span class="line">[    0.051366] TCP established <span class="built_in">hash</span> table entries: 4096 (order: 2, 16384 bytes, linear)</span><br><span class="line">[    0.051427] TCP <span class="built_in">bind</span> <span class="built_in">hash</span> table entries: 4096 (order: 4, 65536 bytes, linear)</span><br><span class="line">[    0.051643] TCP: Hash tables configured (established 4096 <span class="built_in">bind</span> 4096)</span><br><span class="line">[    0.051791] UDP <span class="built_in">hash</span> table entries: 256 (order: 1, 8192 bytes, linear)</span><br><span class="line">[    0.051856] UDP-Lite <span class="built_in">hash</span> table entries: 256 (order: 1, 8192 bytes, linear)</span><br><span class="line">[    0.052082] NET: Registered PF_UNIX/PF_LOCAL protocol family</span><br><span class="line">[    0.052808] RPC: Registered named UNIX socket transport module.</span><br><span class="line">[    0.052855] RPC: Registered udp transport module.</span><br><span class="line">[    0.052873] RPC: Registered tcp transport module.</span><br><span class="line">[    0.052888] RPC: Registered tcp-with-tls transport module.</span><br><span class="line">[    0.052904] RPC: Registered tcp NFSv4.1 backchannel transport module.</span><br><span class="line">[    0.054149] workingset: timestamp_bits=30 max_order=17 bucket_order=0</span><br><span class="line">[    0.055164] NFS: Registering the id_resolver key <span class="built_in">type</span></span><br><span class="line">[    0.055249] Key <span class="built_in">type</span> id_resolver registered</span><br><span class="line">[    0.055269] Key <span class="built_in">type</span> id_legacy registered</span><br><span class="line">[    0.055406] Block layer SCSI generic (bsg) driver version 0.4 loaded (major 246)</span><br><span class="line">[    0.055436] io scheduler mq-deadline registered</span><br><span class="line">[    0.055455] io scheduler kyber registered</span><br><span class="line">[    0.055487] io scheduler bfq registered</span><br><span class="line">[    0.123068] Serial: 8250/16550 driver, 8 ports, IRQ sharing disabled</span><br><span class="line">[    0.132571] panel-simple panel: Specify missing connector_type</span><br><span class="line">[    0.140190] lima 1c40000.gpu: gp - mali400 version major 1 minor 1</span><br><span class="line">[    0.140335] lima 1c40000.gpu: pp0 - mali400 version major 1 minor 1</span><br><span class="line">[    0.140452] lima 1c40000.gpu: pp1 - mali400 version major 1 minor 1</span><br><span class="line">[    0.140513] lima 1c40000.gpu: l2_cache0 64K, 4-way, 64byte cache line, 64bit external bus</span><br><span class="line">[    0.140619] lima 1c40000.gpu: bus rate = 200000000</span><br><span class="line">[    0.140646] lima 1c40000.gpu: mod rate = 384000000</span><br><span class="line">[    0.140761] lima 1c40000.gpu: error -ENODEV: _opp_set_regulators: no regulator (mali) found</span><br><span class="line">[    0.141326] lima 1c40000.gpu: Failed to register cooling device</span><br><span class="line">[    0.141920] [drm] Initialized lima 1.1.0 <span class="keyword">for</span> 1c40000.gpu on minor 0</span><br><span class="line">[    0.146975] CAN device driver interface</span><br><span class="line">[    0.150247] sun6i-rtc 1f00000.rtc: registered as rtc0</span><br><span class="line">[    0.150323] sun6i-rtc 1f00000.rtc: setting system clock to 1970-01-01T00:43:53 UTC (2633)</span><br><span class="line">[    0.150930] i2c_dev: i2c /dev entries driver</span><br><span class="line">[    0.153101] sunxi-wdt 1c20ca0.watchdog: Watchdog enabled (<span class="built_in">timeout</span>=16 sec, nowayout=0)</span><br><span class="line">[    0.154435] sun4i-ss 1c15000.crypto-engine: Die ID 5</span><br><span class="line">[    0.155623] usbcore: registered new interface driver usbhid</span><br><span class="line">[    0.155654] usbhid: USB HID core driver</span><br><span class="line">[    0.161519] cedrus 1c0e000.video-codec: Device registered as /dev/video0</span><br><span class="line">[    0.165699] NET: Registered PF_PACKET protocol family</span><br><span class="line">[    0.165755] can: controller area network core</span><br><span class="line">[    0.165827] NET: Registered PF_CAN protocol family</span><br><span class="line">[    0.165851] can: raw protocol</span><br><span class="line">[    0.165869] can: broadcast manager protocol</span><br><span class="line">[    0.165891] can: netlink gateway - max_hops=1</span><br><span class="line">[    0.166091] Key <span class="built_in">type</span> dns_resolver registered</span><br><span class="line">[    0.166263] Registering SWP/SWPB emulation handler</span><br><span class="line">[    0.188378] gpio gpiochip0: Static allocation of GPIO base is deprecated, use dynamic allocation.</span><br><span class="line">[    0.190314] sun8i-a23-r-pinctrl 1f02c00.pinctrl: initialized sunXi PIO driver</span><br><span class="line">[    0.191090] gpio gpiochip1: Static allocation of GPIO base is deprecated, use dynamic allocation.</span><br><span class="line">[    0.193964] sun8i-a33-pinctrl 1c20800.pinctrl: initialized sunXi PIO driver</span><br><span class="line">[    0.194633] sun8i-a33-pinctrl 1c20800.pinctrl: supply vcc-pb not found, using dummy regulator</span><br><span class="line">[    0.216310] 1c28000.serial: ttyS0 at MMIO 0x1c28000 (irq = 140, base_baud = 1500000) is a U6_16550A</span><br><span class="line">[    0.216423] printk: legacy console [ttyS0] enabled</span><br><span class="line">[    1.162066] sun8i-a33-pinctrl 1c20800.pinctrl: supply vcc-pd not found, using dummy regulator</span><br><span class="line">[    1.171186] sun4i-drm display-engine: bound 1e00000.display-frontend (ops 0xc095450c)</span><br><span class="line">[    1.179400] sun4i-drm display-engine: bound 1e60000.display-backend (ops 0xc0953c78)</span><br><span class="line">[    1.187285] sun4i-drm display-engine: bound 1e70000.drc (ops 0xc09537a8)</span><br><span class="line">[    1.194715] sun4i-drm display-engine: bound 1c0c000.lcd-controller (ops 0xc0952418)</span><br><span class="line">[    1.203810] [drm] Initialized sun4i-drm 1.0.0 <span class="keyword">for</span> display-engine on minor 1</span><br><span class="line">[    1.212105] usb_phy_generic usb_phy_generic.1.auto: dummy supplies not allowed <span class="keyword">for</span> exclusive requests (<span class="built_in">id</span>=vbus)</span><br><span class="line">[    1.225635] ehci-platform 1c1a000.usb: EHCI Host Controller</span><br><span class="line">[    1.231359] ehci-platform 1c1a000.usb: new USB bus registered, assigned bus number 1</span><br><span class="line">[    1.232634] sun8i-a23-r-pinctrl 1f02c00.pinctrl: supply vcc-pl not found, using dummy regulator</span><br><span class="line">[    1.232655] ohci-platform 1c1a400.usb: Generic Platform OHCI controller</span><br><span class="line">[    1.232680] ohci-platform 1c1a400.usb: new USB bus registered, assigned bus number 2</span><br><span class="line">[    1.262744] sunxi-rsb 1f03400.rsb: RSB running at 3000000 Hz</span><br><span class="line">[    1.268854] axp20x-rsb sunxi-rsb-3a3: AXP20x variant AXP223 found</span><br><span class="line">[    1.269008] ohci-platform 1c1a400.usb: irq 144, io mem 0x01c1a400</span><br><span class="line">[    1.278800] input: axp20x-pek as /devices/platform/soc/1f03400.rsb/sunxi-rsb-3a3/axp221-pek/input/input0</span><br><span class="line">[    1.291724] axp20x-adc axp22x-adc: DMA mask not <span class="built_in">set</span></span><br><span class="line">[    1.297302] ehci-platform 1c1a000.usb: irq 143, io mem 0x01c1a000</span><br><span class="line">[    1.297733] axp20x-battery-power-supply axp20x-battery-power-supply: DMA mask not <span class="built_in">set</span></span><br><span class="line">[    1.312539] axp20x-ac-power-supply axp20x-ac-power-supply: DMA mask not <span class="built_in">set</span></span><br><span class="line">[    1.324341] axp20x-rsb sunxi-rsb-3a3: AXP20X driver loaded</span><br><span class="line">[    1.330230] ehci-platform 1c1a000.usb: USB 2.0 started, EHCI 1.00</span><br><span class="line">[    1.332049] input: 1c22800.lradc as /devices/platform/soc/1c22800.lradc/input/input1</span><br><span class="line">[    1.337352] hub 1-0:1.0: USB hub found</span><br><span class="line">[    1.348018] hub 1-0:1.0: 1 port detected</span><br><span class="line">[    1.358445] sun8i-a33-pinctrl 1c20800.pinctrl: supply vcc-pf not found, using dummy regulator</span><br><span class="line">[    1.358514] clk: Disabling unused clocks</span><br><span class="line">[    1.358756] hub 2-0:1.0: USB hub found</span><br><span class="line">[    1.358820] hub 2-0:1.0: 1 port detected</span><br><span class="line">[    1.358836] sun8i-a33-pinctrl 1c20800.pinctrl: supply vcc-pc not found, using dummy regulator</span><br><span class="line">[    1.387380] ALSA device list:</span><br><span class="line">[    1.390398]   No soundcards found.</span><br><span class="line">[    1.394999] sunxi-mmc 1c0f000.mmc: Got CD GPIO</span><br><span class="line">[    1.419939] sunxi-mmc 1c11000.mmc: initialized, max. request size: 16384 KB</span><br><span class="line">[    1.423106] sunxi-mmc 1c0f000.mmc: initialized, max. request size: 16384 KB</span><br><span class="line">[    1.434628] /dev/root: Can<span class="string">&#x27;t open blockdev</span></span><br><span class="line"><span class="string">[    1.438774] VFS: Cannot open root device &quot;&quot; or unknown-block(0,0): error -6</span></span><br><span class="line"><span class="string">[    1.445782] Please append a correct &quot;root=&quot; boot option; here are the available partitions:</span></span><br><span class="line"><span class="string">[    1.454156] List of all bdev filesystems:</span></span><br><span class="line"><span class="string">[    1.458168]  ext3</span></span><br><span class="line"><span class="string">[    1.458174]  ext2</span></span><br><span class="line"><span class="string">[    1.460115]  ext4</span></span><br><span class="line"><span class="string">[    1.462045]  vfat</span></span><br><span class="line"><span class="string">[    1.463974] </span></span><br><span class="line"><span class="string">[    1.467258] mmc1: host does not support reading read-only switch, assuming write-enable</span></span><br><span class="line"><span class="string">[    1.467391] Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)</span></span><br><span class="line"><span class="string">[    1.467401] CPU: 3 UID: 0 PID: 1 Comm: swapper/0 Not tainted 6.11.0-rc6-00309-gd2742e387fe4 #4</span></span><br><span class="line"><span class="string">[    1.467411] Hardware name: Allwinner sun8i Family</span></span><br><span class="line"><span class="string">[    1.467416] Call trace: </span></span><br><span class="line"><span class="string">[    1.467430]  unwind_backtrace from show_stack+0x10/0x14</span></span><br><span class="line"><span class="string">[    1.467465]  show_stack from dump_stack_lvl+0x50/0x64</span></span><br><span class="line"><span class="string">[    1.467484]  dump_stack_lvl from panic+0x10c/0x344</span></span><br><span class="line"><span class="string">[    1.467497]  panic from mount_root_generic+0x1d4/0x278</span></span><br><span class="line"><span class="string">[    1.467513]  mount_root_generic from prepare_namespace+0x1fc/0x258</span></span><br><span class="line"><span class="string">[    1.467527]  prepare_namespace from kernel_init+0x1c/0x12c</span></span><br><span class="line"><span class="string">[    1.467542]  kernel_init from ret_from_fork+0x14/0x28</span></span><br><span class="line"><span class="string">[    1.467554] Exception stack(0xde821fb0 to 0xde821ff8)</span></span><br><span class="line"><span class="string">[    1.467565] 1fa0:                                     00000000 00000000 00000000 00000000</span></span><br><span class="line"><span class="string">[    1.467574] 1fc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000</span></span><br><span class="line"><span class="string">[    1.467582] 1fe0: 00000000 00000000 00000000 00000000 00000013 00000000</span></span><br><span class="line"><span class="string">[    1.564419] ---[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0) ]---</span></span><br></pre></td></tr></table></figure><p>内核直接报了<code>panic</code>，经过定位，可以确定如下一条依据：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[    1.445782] Please append a correct <span class="string">&quot;root=&quot;</span> boot option; here are the available partitions:</span><br></pre></td></tr></table></figure><p>这里的意思就是我们没有指定根文件系统，那一定是bootargs出了问题，复位进入uboot，查看bootargs的参数：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; <span class="built_in">printenv</span> bootargs</span><br><span class="line"><span class="comment">## Error: &quot;bootargs&quot; not defined</span></span><br></pre></td></tr></table></figure><p>居然没有这个环境变量，想到了armbian是有对a33进行支持的，我们可以去脱一下armbian的bootargs。</p><p>下载<a href="https://github.com/armbian/community/releases/download/24.11.0-trunk.66/Armbian_community_24.11.0-trunk.66_Lime-a33_bookworm_current_6.6.44_minimal.img.xz">armbian</a>的镜像之后通过<code>balenaEtcher</code>工具刷入sd卡，进入系统后提取<code>boot</code>分区中的<code>boot.scr</code>。</p><p>该脚本中有这么一句话：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setenv bootargs <span class="string">&quot;root=<span class="variable">$&#123;rootdev&#125;</span> rootwait rootfstype=<span class="variable">$&#123;rootfstype&#125;</span> <span class="variable">$&#123;consoleargs&#125;</span> hdmi.audio=EDID:0 disp.screen0_output_mode=<span class="variable">$&#123;disp_mode&#125;</span> consoleblank=0 loglevel=<span class="variable">$&#123;verbosity&#125;</span> ubootpart=<span class="variable">$&#123;partuuid&#125;</span> ubootsource=<span class="variable">$&#123;devtype&#125;</span> usb-storage.quirks=<span class="variable">$&#123;usbstoragequirks&#125;</span> <span class="variable">$&#123;extraargs&#125;</span> <span class="variable">$&#123;extraboardargs&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>在<code>armbian</code>的<code>uboot</code>中一句句对照env，并且删减一些无关项后得到如下<code>bootargs</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; setenv bootargs <span class="string">&#x27;earlycon earlyprintk root=/dev/mmcblk0p2 rootwait rw rootfstype=ext4 console=ttyS2,115200 consoleblank=0 loglevel=8&#x27;</span></span><br><span class="line">=&gt; <span class="built_in">printenv</span> bootargs </span><br><span class="line">bootargs=earlycon earlyprintk root=/dev/mmcblk0p2 rootwait rw rootfstype=ext4 console=ttyS2,115200 consoleblank=0 loglevel=8</span><br><span class="line">=&gt; saveenv</span><br><span class="line">Saving Environment to FAT... OK</span><br></pre></td></tr></table></figure><p>重新加载并且启动后发现log到Starting kernel就停止了：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; load mmc 0:1 0x42000000 zImage</span><br><span class="line">5496008 bytes <span class="built_in">read</span> <span class="keyword">in</span> 229 ms (22.9 MiB/s)</span><br><span class="line">=&gt; load mmc 0:1 0x43000000 sun8i-a33-vstar.dtb</span><br><span class="line">23345 bytes <span class="built_in">read</span> <span class="keyword">in</span> 2 ms (11.1 MiB/s)</span><br><span class="line">=&gt; bootz 0x42000000 - 0</span><br><span class="line">Kernel image @ 0x42000000 [ 0x000000 - 0x53dcc8 ]</span><br><span class="line">ERROR: Did not find a cmdline Flattened Device Tree</span><br><span class="line">Could not find a valid device tree</span><br><span class="line">=&gt; bootz 0x42000000 - 0x43000000</span><br><span class="line">Kernel image @ 0x42000000 [ 0x000000 - 0x53dcc8 ]</span><br><span class="line"><span class="comment">## Flattened Device Tree blob at 43000000</span></span><br><span class="line">   Booting using the fdt blob at 0x43000000</span><br><span class="line">Working FDT <span class="built_in">set</span> to 43000000</span><br><span class="line">   Loading Device Tree to 49ff7000, end 49fffb30 ... OK</span><br><span class="line">Working FDT <span class="built_in">set</span> to 49ff7000</span><br><span class="line"></span><br><span class="line">Starting kernel ...</span><br><span class="line"></span><br><span class="line">cyclic <span class="keyword">function</span> video_init took too long: 27000us vs 5000us max</span><br></pre></td></tr></table></figure><h3 id="修改串口"><a href="#修改串口" class="headerlink" title="修改串口"></a>修改串口</h3><p>这很容易判断，我们硬件电气连接的是uart2, 肯定是串口的问题了，查看设备树：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">cat</span> <span class="built_in">arch</span>/arm/boot/dts/allwinner/sun8i-a33-vstar.dts | grep serial</span><br><span class="line">serial0 = &amp;uart0;</span><br><span class="line">stdout-path = <span class="string">&quot;serial0:115200n8&quot;</span>;</span><br></pre></td></tr></table></figure><p>果然，设备树中是串口0,为了避免和sd卡引脚复用冲突（<strong>该部分在uboot已经说明过</strong>）, 将其修改成uart2,并且我们的bootargs中指定的也是uart2.</p><p>修改后的差异：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">diff --git a/arch/arm/boot/dts/allwinner/sun8i-a33-vstar.dts b/arch/arm/boot/dts/allwinner/sun8i-a33-vstar.dts</span><br><span class="line">index 0c82ff3c7cb4..7bb29d78c77f 100644</span><br><span class="line">--- a/arch/arm/boot/dts/allwinner/sun8i-a33-vstar.dts</span><br><span class="line">+++ b/arch/arm/boot/dts/allwinner/sun8i-a33-vstar.dts</span><br><span class="line">@@ -54,11 +54,11 @@ / &#123;</span><br><span class="line"> compatible = <span class="string">&quot;sinlinx,sina33&quot;</span>, <span class="string">&quot;allwinner,sun8i-a33&quot;</span>;</span><br><span class="line"> </span><br><span class="line"> aliases &#123;</span><br><span class="line">-serial0 = &amp;uart0;</span><br><span class="line">+serial2 = &amp;uart2;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> chosen &#123;</span><br><span class="line">-stdout-path = <span class="string">&quot;serial0:115200n8&quot;</span>;</span><br><span class="line">+stdout-path = <span class="string">&quot;serial2:115200n8&quot;</span>;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> panel &#123;</span><br><span class="line">@@ -261,6 +261,12 @@ tcon0_out_panel: endpoint@0 &#123;</span><br><span class="line"> &amp;uart0 &#123;</span><br><span class="line"> pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"> pinctrl-0 = &lt;&amp;uart0_pb_pins&gt;;</span><br><span class="line">+status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">+&#125;;</span><br><span class="line">+</span><br><span class="line">+&amp;uart2 &#123;</span><br><span class="line">+pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">+pinctrl-0 = &lt;&amp;uart2_pins&gt;;</span><br><span class="line"> status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line">@@ -273,3 +279,10 @@ &amp;usbphy &#123;</span><br><span class="line"> status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"> usb1_vbus-supply = &lt;&amp;reg_vcc5v0&gt;; /* USB1 VBUS is always on */</span><br><span class="line"> &#125;;</span><br><span class="line">+</span><br><span class="line">+&amp;pio &#123;</span><br><span class="line">+uart2_pins: uart2-pins &#123;</span><br><span class="line">+pins = <span class="string">&quot;PB0&quot;</span>, <span class="string">&quot;PB1&quot;</span>;</span><br><span class="line">+<span class="keyword">function</span> = <span class="string">&quot;uart2&quot;</span>;</span><br><span class="line">+&#125;;</span><br><span class="line">+&#125;;</span><br></pre></td></tr></table></figure><p>重新启动后可以正常看到输出了！</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[    1.242405] Waiting <span class="keyword">for</span> root device /dev/mmcblk0p2...</span><br><span class="line">[    1.278711] mmc1: host does not support reading read-only switch, assuming write-enable</span><br><span class="line">[    1.296810] mmc1: new high speed SDXC card at address 59b4</span><br><span class="line">[    1.307496] mmcblk1: mmc1:59b4 SD64G 59.4 GiB</span><br><span class="line">[    1.326969]  mmcblk1: p1 p2</span><br><span class="line">[    1.381752] mmc0: new DDR MMC card at address 0001</span><br><span class="line">[    1.387723] mmcblk0: mmc0:0001 004G60 3.69 GiB</span><br><span class="line">[    1.405833]  mmcblk0: p1 p2</span><br><span class="line">[    1.414082] mmcblk0boot0: mmc0:0001 004G60 2.00 MiB</span><br><span class="line">[    1.421045] mmcblk0boot1: mmc0:0001 004G60 2.00 MiB</span><br><span class="line">[    1.447615] usb 1-1: new high-speed USB device number 2 using ehci-platform</span><br><span class="line">[    1.462789] EXT4-fs (mmcblk0p2): recovery complete</span><br><span class="line">[    1.467843] EXT4-fs (mmcblk0p2): mounted filesystem 3cdb3fe9-0a84-41be-9519-ec406d029db6 r/w with ordered data mode. Quota mode: disabled.</span><br><span class="line">[    1.480404] VFS: Mounted root (ext4 filesystem) on device 179:10.</span><br><span class="line">[    1.487217] devtmpfs: error mounting -2</span><br><span class="line">[    1.496557] Freeing unused kernel image (initmem) memory: 1024K</span><br><span class="line">[    1.502730] Run /sbin/init as init process</span><br><span class="line">[    1.506831]   with arguments:</span><br><span class="line">[    1.509826]     /sbin/init</span><br><span class="line">[    1.512536]     earlyprintk</span><br><span class="line">[    1.515329]   with environment:</span><br><span class="line">[    1.518489]     HOME=/</span><br><span class="line">[    1.520938]     TERM=linux</span><br><span class="line">[    1.523983] Run /etc/init as init process</span><br><span class="line">[    1.528010]   with arguments:</span><br><span class="line">[    1.531062]     /etc/init</span><br><span class="line">[    1.533975]     earlyprintk</span><br><span class="line">[    1.536766]   with environment:</span><br><span class="line">[    1.539921]     HOME=/</span><br><span class="line">[    1.542366]     TERM=linux</span><br><span class="line">[    1.545366] Run /bin/init as init process</span><br><span class="line">[    1.549385]   with arguments:</span><br><span class="line">[    1.552349]     /bin/init</span><br><span class="line">[    1.554966]     earlyprintk</span><br><span class="line">[    1.557768]   with environment:</span><br><span class="line">[    1.560905]     HOME=/</span><br><span class="line">[    1.563261]     TERM=linux</span><br><span class="line">[    1.565979] Run /bin/sh as init process</span><br><span class="line">[    1.569826]   with arguments:</span><br><span class="line">[    1.572790]     /bin/sh</span><br><span class="line">[    1.575233]     earlyprintk</span><br><span class="line">[    1.578042]   with environment:</span><br><span class="line">[    1.581179]     HOME=/</span><br><span class="line">[    1.583537]     TERM=linux</span><br><span class="line">[    1.586247] Kernel panic - not syncing: No working init found.  Try passing init= option to kernel. See Linux Documentation/admin-guide/init.rst <span class="keyword">for</span> guidance.</span><br><span class="line">[    1.600399] CPU: 1 UID: 0 PID: 1 Comm: swapper/0 Not tainted 6.11.0-rc6-00309-gd2742e387fe4-dirty <span class="comment">#5</span></span><br><span class="line">[    1.609523] Hardware name: Allwinner sun8i Family</span><br><span class="line">[    1.614222] Call trace: </span><br><span class="line">[    1.614238]  unwind_backtrace from show_stack+0x10/0x14</span><br><span class="line">[    1.622013]  show_stack from dump_stack_lvl+0x50/0x64</span><br><span class="line">[    1.627074]  dump_stack_lvl from panic+0x10c/0x344</span><br><span class="line">[    1.631869]  panic from _cpu_down+0x0/0x6a0</span><br><span class="line">[    1.636155] ---[ end Kernel panic - not syncing: No working init found.  Try passing init= option to kernel. See Linux Documentation/admin-guide/init.rst <span class="keyword">for</span> gu</span><br><span class="line">idance. ]---</span><br></pre></td></tr></table></figure><h3 id="固定mmc序号"><a href="#固定mmc序号" class="headerlink" title="固定mmc序号"></a>固定mmc序号</h3><p>但这里还是出现了<code>pannic</code>，重点观察到如下内容：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[    1.242405] Waiting <span class="keyword">for</span> root device /dev/mmcblk0p2...</span><br><span class="line">[    1.278711] mmc1: host does not support reading read-only switch, assuming write-enable</span><br><span class="line">[    1.296810] mmc1: new high speed SDXC card at address 59b4</span><br><span class="line">[    1.307496] mmcblk1: mmc1:59b4 SD64G 59.4 GiB</span><br></pre></td></tr></table></figure><p>这里说是等待mmcblk0设备但是sd卡确实mmc1, 并且我每次复位sd卡的序号都不一样，可能是mmc0也可能是mmc1, 这可不行，因为rootfs的分区是我们在bootargs里面定死了的，所以只能固定mmc序号。</p><p>修改设备树：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">diff --git a/arch/arm/boot/dts/allwinner/sun8i-a33-vstar.dts b/arch/arm/boot/dts/allwinner/sun8i-a33-vstar.dts</span><br><span class="line">index f89a005227d9..95a7c7f394b8 100644</span><br><span class="line">--- a/arch/arm/boot/dts/allwinner/sun8i-a33-vstar.dts</span><br><span class="line">+++ b/arch/arm/boot/dts/allwinner/sun8i-a33-vstar.dts</span><br><span class="line">@@ -55,6 +55,10 @@ / &#123;</span><br><span class="line"> </span><br><span class="line">        aliases &#123;</span><br><span class="line">                serial2 = &amp;uart2;</span><br><span class="line">+               /* SD Card */</span><br><span class="line">+               mmc0 = &amp;mmc0;</span><br><span class="line">+               /* emmc */</span><br><span class="line">+               mmc1 = &amp;mmc2;</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        chosen &#123;</span><br></pre></td></tr></table></figure><h3 id="TODO-详细解释为何这样修改就可以固定序号"><a href="#TODO-详细解释为何这样修改就可以固定序号" class="headerlink" title="TODO : 详细解释为何这样修改就可以固定序号"></a>TODO : 详细解释为何这样修改就可以固定序号</h3><p>重新烧录可以看到无论重启多少次，mmc的序号都是固定不变的：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[    1.244304] Waiting <span class="keyword">for</span> root device /dev/mmcblk0p2...</span><br><span class="line">[    1.284821] mmc0: host does not support reading read-only switch, assuming write-enable</span><br><span class="line">[    1.294664] mmc0: new high speed SDXC card at address 59b4</span><br><span class="line">[    1.307075] mmcblk0: mmc0:59b4 SD64G 59.4 GiB</span><br><span class="line">[    1.323511]  mmcblk0: p1 p2</span><br></pre></td></tr></table></figure><p>接下来就是紧急制作一个文件系统：<a href="https://blog.troy-y.org/2024/09/20/rootfs-%E5%88%B6%E4%BD%9CUbuntu%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">传送门</a></p><p>制作好根文件系统之后将根文件系统的内容放入rootfs分区，不知道怎么放可以参考这里：<a href="https://blog.troy-y.org/2024/09/20/sd%E4%B8%8Emmc%E5%88%B7%E5%86%99%E6%8C%87%E5%8D%97/">传送门</a></p><p>重新启动就已经可以进入根文件系统了：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Ubuntu 22.04 LTS a33-vstar ttyS2</span><br><span class="line"></span><br><span class="line">a33-vstar login: root</span><br><span class="line">Password: </span><br><span class="line">Welcome to Ubuntu 22.04 LTS (GNU/Linux 6.11.0-rc6-00311-g9be470523bd2-dirty armv7l)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com</span><br><span class="line"> * Management:     https://landscape.canonical.com</span><br><span class="line"> * Support:        https://ubuntu.com/advantage</span><br><span class="line">Last login: Thu Apr  7 19:28:32 UTC 2022 on ttyS2</span><br><span class="line">root@a33-vstar:~# <span class="built_in">uname</span></span><br><span class="line">Linux</span><br><span class="line">root@a33-vstar:~# <span class="built_in">uname</span> -a</span><br><span class="line">Linux a33-vstar 6.11.0-rc6-00311-g9be470523bd2-dirty <span class="comment">#6 SMP Fri Sep 20 23:40:53 CST 2024 armv7l armv7l armv7l GNU/Linux</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> kernel </tag>
            
            <tag> a33 </tag>
            
            <tag> allwinner </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux分区恢复</title>
      <link href="/2024/09/13/Linux%E5%88%86%E5%8C%BA%E6%81%A2%E5%A4%8D/"/>
      <url>/2024/09/13/Linux%E5%88%86%E5%8C%BA%E6%81%A2%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<p>在删除U盘分区的时候，忘了插U盘，直接把Ubuntu的efi分区删掉了。</p><p>直接原地红温…</p><p>不过还好删除的是分区不是数据，还有的救…</p><p><strong>注意这时候千万不要重启系统！！！</strong></p><p>查看分区挂载：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ lsblk</span><br><span class="line">NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS</span><br><span class="line">...</span><br><span class="line">nvme0n1     259:0    0 953.9G  0 disk </span><br><span class="line">└─nvme0n1p2 259:2    0 953.4G  0 part /</span><br></pre></td></tr></table></figure><p>已经看不见p1了，但是！</p><p>执行如下命令安装众神之父<code>testdisk</code>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">sudo</span> apt install testdisk </span><br></pre></td></tr></table></figure><p>这个工具非常好用，可以自定义检测分区表，并且检测丢失的分区：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">sudo</span> testdisk /dev/nvme0n1</span><br></pre></td></tr></table></figure><p>进入如下界面, 这里是选择磁盘，我只有一个盘，所以就直接按enter了：</p><p><a href="https://postimg.cc/DWBKtmzw"><img src="https://i.postimg.cc/26f8LZRh/2024-09-13-14-24-41.png" alt="2024-09-13-14-24-41.png"></a></p><p>选择磁盘后需要选择你的磁盘分区表类型，Intel是自动选择，按道理应该是GPT分区，但是不太自信，所以选择了Intel进入：</p><p><a href="https://postimg.cc/qg7vjFWy"><img src="https://i.postimg.cc/nV49cbkR/2024-09-13-14-24-47.png" alt="2024-09-13-14-24-47.png"></a></p><p>这里显示检测到了GPT分区，直接按Enter进入：</p><p><a href="https://postimg.cc/jCCRz7Jh"><img src="https://i.postimg.cc/qBxgHcJW/2024-09-13-14-25-08.png" alt="2024-09-13-14-25-08.png"></a></p><p>在如下界面中直接选中Analyse回车：</p><p><a href="https://postimg.cc/Kkww74d9"><img src="https://i.postimg.cc/J0z8LkKW/2024-09-13-14-48-06.png" alt="2024-09-13-14-48-06.png"></a></p><p>随后检测到分区结构如下，直接选择Quick Search回车：</p><p><a href="https://postimg.cc/bsX4sD0r"><img src="https://i.postimg.cc/qMgrD2zs/2024-09-13-14-51-29.png" alt="2024-09-13-14-51-29.png"></a></p><p>接下来检测到一个可恢复分区FAT，回车进入后选择Write，选择Write只会重写你的分区信息，而不会删除你的分区数据，所以大可放心。</p><p>选择Write之后会询问你是否确认，输入Y即可。</p><p><a href="https://postimg.cc/VSNV3jwG"><img src="https://i.postimg.cc/3wjQ0BcT/2024-09-13-14-25-12.png" alt="2024-09-13-14-25-12.png"></a></p><p>写入之后重启系统，就可以看到心心念念的efi了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ lsblk</span><br><span class="line">NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS</span><br><span class="line">...</span><br><span class="line">nvme0n1     259:0    0 953.9G  0 disk </span><br><span class="line">├─nvme0n1p1 259:1    0   512M  0 part /boot/efi</span><br><span class="line">└─nvme0n1p2 259:2    0 953.4G  0 part /</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[全志A33-Vstar]Uboot</title>
      <link href="/2024/09/13/%E5%85%A8%E5%BF%97A33-Uboot/"/>
      <url>/2024/09/13/%E5%85%A8%E5%BF%97A33-Uboot/</url>
      
        <content type="html"><![CDATA[<h2 id="Env"><a href="#Env" class="headerlink" title="Env"></a>Env</h2><p>cpu: allwinner a33<br>board: vstar<br>host: ubuntu 22.04</p><p>需要安装交叉编译工具链：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">sudo</span> apt install gcc-arm-linux-gnueabihf</span><br></pre></td></tr></table></figure><h2 id="FEL模式"><a href="#FEL模式" class="headerlink" title="FEL模式"></a>FEL模式</h2><p>通过FEL模式可以启动uboot或将内核镜像等文件下载到内存，是个很方便的功能。</p><p>若要使用fel系列的工具，需要先安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">sudo</span> apt-get install sunxi-tools</span><br></pre></td></tr></table></figure><p>vstar开发板进入fel的方式有两种：</p><ul><li>按住power键不松手，随后按reset，等待1s后放开power键</li><li>按住vol + 键不松手，随后按reset，连续短按5-10次power键后有一个灯闪烁一下，此时松开vol+键即可进入。</li></ul><p>fel烧写uboot命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">sudo</span> sunxi-fel uboot ./u-boot-sunxi-with-spl.bin</span><br></pre></td></tr></table></figure><h2 id="uboot-sunxi仓库试错"><a href="#uboot-sunxi仓库试错" class="headerlink" title="uboot-sunxi仓库试错"></a>uboot-sunxi仓库试错</h2><p><strong>该章节并没有成功，所以如果想学习可以看看，只是想移植uboot就可以跳到下一个章节</strong></p><p>要移植uboot首先想到的肯定是全志的uboot仓库，先拉下来代码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ git <span class="built_in">clone</span> https://github.com/linux-sunxi/u-boot-sunxi </span><br><span class="line">❯ <span class="built_in">cd</span> u-boot-sunxi </span><br></pre></td></tr></table></figure><p>使用一个A33芯片的板子的config进行配置并编译，经过测试, A33-OLinuXino_defconfig这个配置文件没支持emmc，只支持了sd，这里选择sinlinx的config，与vstar开发板相近：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- Sinlinx_SinA33_defconfig</span><br><span class="line">❯ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j16</span><br></pre></td></tr></table></figure><p>编译遇到如下错误，看起来很熟悉，好像当年搞f1c200s的时候也遇见了这个错误…</p><p>给lichee pi的仓库提交了pr，但已经过去了一年多，也没有理我…</p><p>该错误可通过该pr修复：<a href="https://github.com/Lichee-Pi/u-boot/pull/7">我是PR</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usr/bin/ld: scripts/dtc/dtc-parser.tab.o:(.bss+0x10): multiple definition of `yylloc<span class="string">&#x27;; scripts/dtc/dtc-lexer.lex.o:(.bss+0x0): first defined here</span></span><br><span class="line"><span class="string">  UPD     include/generated/version_autogenerated.h</span></span><br><span class="line"><span class="string">  CC      lib/asm-offsets.s</span></span><br><span class="line"><span class="string">  CC      arch/arm/lib/asm-offsets.s</span></span><br><span class="line"><span class="string">collect2: error: ld returned 1 exit status</span></span><br><span class="line"><span class="string">make[2]: *** [scripts/Makefile.host:106：scripts/dtc/dtc] 错误 1</span></span><br><span class="line"><span class="string">make[2]: *** 正在等待未完成的任务....</span></span><br></pre></td></tr></table></figure><p>继续编译，到了最后阶段却遇到了如下错误：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  MKSUNXI spl/sunxi-spl.bin</span><br><span class="line">  BINMAN  u-boot-sunxi-with-spl.bin</span><br><span class="line">binman: No module named _libfdt</span><br><span class="line">make: *** [Makefile:1348：u-boot-sunxi-with-spl.bin] 错误 1</span><br></pre></td></tr></table></figure><p>检查python是否有这个module:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ python -m pip list | grep pylibfdt</span><br><span class="line">pylibfdt                           1.7.0.post1</span><br></pre></td></tr></table></figure><p>这时候已经开始怀疑是这个module的版本问题了，在<a href="https://pypi.org/project/pylibfdt/#history">这里</a>找到了历史版本信息，逐个尝试安装还是不行…</p><p>最终在<a href="https://lore.kernel.org/buildroot/bug-11706-163@https.bugs.busybox.net%2F/T/">这里</a>找到了问题的原因，是python版本的问题。</p><p>在<a href="https://blog.csdn.net/qq_34752070/article/details/125182978">这里</a>找到了问题的解决方案，重新链接后解决问题。</p><p>连接开发板串口0之后通过进入fel启动uboot：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ git <span class="built_in">clone</span> git@github.com:u-boot/u-boot.git</span><br><span class="line">❯ <span class="built_in">sudo</span> sunxi-fel uboot ./u-boot-sunxi-with-spl.bin</span><br></pre></td></tr></table></figure><p>之后发现emmc和sd卡都无法使用…</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; mmc dev 0</span><br><span class="line">Card did not respond to voltage <span class="keyword">select</span>!</span><br><span class="line">=&gt; mmc dev 1</span><br><span class="line">Card did not respond to voltage <span class="keyword">select</span>!</span><br><span class="line">=&gt; mmc dev 0</span><br><span class="line">MMC: no card present</span><br><span class="line">=&gt; mmc dev 1</span><br><span class="line">Card did not respond to voltage <span class="keyword">select</span>!</span><br></pre></td></tr></table></figure><p><strong>fuck you allwinner! mainline start!</strong></p><h2 id="mainline"><a href="#mainline" class="headerlink" title="mainline"></a>mainline</h2><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>拉取uboot主线代码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ git <span class="built_in">clone</span> git@github.com:u-boot/u-boot.git </span><br><span class="line">❯ <span class="built_in">cd</span> u-boot</span><br></pre></td></tr></table></figure><p>依旧使用之前的Sinlinx的配置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- Sinlinx_SinA33_defconfig</span><br><span class="line">❯ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j16</span><br></pre></td></tr></table></figure><p>这次发现日志到MMC就结束了：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">U-Boot 2024.10-rc4-g5f0449324136-dirty (Sep 14 2024 - 15:47:46 +0800) Allwinner Technology</span><br><span class="line"></span><br><span class="line">CPU:   Allwinner A33 (SUN8I 1667)</span><br><span class="line">Model: Sinlinx SinA33</span><br><span class="line">DRAM:  512 MiB</span><br><span class="line">Core:  64 devices, 21 uclasses, devicetree: separate</span><br><span class="line">WDT:   Not starting watchdog@1c20ca0</span><br><span class="line">MMC: </span><br></pre></td></tr></table></figure><p>这里一开始一直怀疑uboot卡死了，排查一段时间后发现其实并不是。</p><p>可以观察到<code>Model: Sinlinx SinA33</code>这一行，按找这个查找对应设备树：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ find -name <span class="string">&quot;*.dts*&quot;</span> -<span class="built_in">exec</span> grep -n <span class="string">&quot;Sinlinx SinA33&quot;</span> &#123;&#125; +</span><br><span class="line">./arch/arm/dts/sun8i-a33-sinlinx-sina33.dts:53:model = <span class="string">&quot;Sinlinx SinA33&quot;</span>;</span><br><span class="line">./dts/upstream/src/arm/allwinner/sun8i-a33-sinlinx-sina33.dts:53:model = <span class="string">&quot;Sinlinx SinA33&quot;</span>;</span><br></pre></td></tr></table></figure><p>查到两个dts，查询dtb:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">ls</span> ./arch/arm/dts/sun8i-a33-sinlinx-sina33.dtb</span><br><span class="line">./arch/arm/dts/sun8i-a33-sinlinx-sina33.dtb</span><br><span class="line">❯ <span class="built_in">ls</span> ./dts/upstream/src/arm/allwinner/sun8i-a33-sinlinx-sina33.dtb</span><br><span class="line"><span class="built_in">ls</span>: 无法访问 <span class="string">&#x27;./dts/upstream/src/arm/allwinner/sun8i-a33-sinlinx-sina33.dtb&#x27;</span>: 没有那个文件或目录</span><br></pre></td></tr></table></figure><p>可以确定就是<code>./arch/arm/dts/sun8i-a33-sinlinx-sina33.dtb</code>这个文件，查询其对应的dts可以发现指定的就是uart0：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aliases &#123;</span><br><span class="line">serial0 = &amp;uart0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">chosen &#123;</span><br><span class="line">stdout-path = <span class="string">&quot;serial0:115200n8&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>查看uart0节点及其对应的gpio：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// ./arch/arm/dts/sun8i-a33-sinlinx-sina33.dts</span><br><span class="line">&amp;uart0 &#123;</span><br><span class="line">pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">pinctrl-0 = &lt;&amp;uart0_pb_pins&gt;;</span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//./arch/arm/dts/sun8i-a33.dtsi</span><br><span class="line">&amp;pio &#123;</span><br><span class="line">compatible = <span class="string">&quot;allwinner,sun8i-a33-pinctrl&quot;</span>;</span><br><span class="line">interrupts = &lt;GIC_SPI 15 IRQ_TYPE_LEVEL_HIGH&gt;,</span><br><span class="line">     &lt;GIC_SPI 17 IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line"></span><br><span class="line">uart0_pb_pins: uart0-pb-pins &#123;</span><br><span class="line">pins = <span class="string">&quot;PB0&quot;</span>, <span class="string">&quot;PB1&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> = <span class="string">&quot;uart0&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里指定了uart0的引脚使用PB0作tx，PB1作rx，查看原理图这两个引脚原来在是uart2,将uart2的引脚复用成uart0了</p><p><a href="https://postimg.cc/TK34JS2T"><img src="https://i.postimg.cc/dV2cwPzZ/2024-09-14-16-44-32.png" alt="2024-09-14-16-44-32.png"></a></p><p>那么这样就可以分析出来原因了，由于chosen指定的输出端口是uart0,所以在没有uart2的gpio复用成uart0的功能之前，就由uart0默认的对应引脚PF2 PF4输出，复用之后就使用了uart2的gpio作uart0。</p><p>连接上uart2之后果然可以看到完整log，但这里还是修改一下吧。</p><h3 id="串口修改"><a href="#串口修改" class="headerlink" title="串口修改"></a>串口修改</h3><p>在修改之前，先复制一份dts和配置文件，作为我们自己的vstar的：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">cp</span> ./arch/arm/dts/sun8i-a33-sinlinx-sina33.dts ./arch/arm/dts/sun8i-a33-vstar.dts</span><br><span class="line">❯ <span class="built_in">cp</span> ./configs/Sinlinx_SinA33_defconfig ./configs/VStar_A33_defconfig</span><br></pre></td></tr></table></figure><p>修改Makefile支持dts:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile</span><br><span class="line">index 2d931c23fc8..1cf745f8027 100644</span><br><span class="line">--- a/arch/arm/dts/Makefile</span><br><span class="line">+++ b/arch/arm/dts/Makefile</span><br><span class="line">@@ -607,6 +607,7 @@ dtb-$(CONFIG_MACH_SUN8I_A33) += \</span><br><span class="line">        sun8i-a33-olinuxino.dtb \</span><br><span class="line">        sun8i-a33-q8-tablet.dtb \</span><br><span class="line">        sun8i-a33-sinlinx-sina33.dtb \</span><br><span class="line">+       sun8i-a33-vstar.dtb \</span><br><span class="line">        sun8i-r16-bananapi-m2m.dtb \</span><br><span class="line">        sun8i-r16-nintendo-nes-classic.dtb \</span><br><span class="line">        sun8i-r16-nintendo-super-nes-classic.dtb \</span><br></pre></td></tr></table></figure><p>修改config选择生成镜像内的设备树文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ diff configs/VStar_A33_defconfig configs/Sinlinx_SinA33_defconfig</span><br><span class="line">3c3</span><br><span class="line">&lt; CONFIG_DEFAULT_DEVICE_TREE=<span class="string">&quot;sun8i-a33-vstar&quot;</span></span><br><span class="line">---</span><br><span class="line">&gt; CONFIG_DEFAULT_DEVICE_TREE=<span class="string">&quot;sun8i-a33-sinlinx-sina33&quot;</span></span><br></pre></td></tr></table></figure><p>使用自己的配置文件编译一次：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- VStar_A33_defconfig</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># configuration written to .config</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">❯ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j16</span><br></pre></td></tr></table></figure><p>编译成功，现在来修改dts以让他全部走uart2,这样uart0就没有任何输出了。</p><p>不然明明连接的uart2,结果uart0显示一段感觉怪怪的。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">diff --git a/arch/arm/dts/sun8i-a33-vstar.dts b/arch/arm/dts/sun8i-a33-vstar.dts</span><br><span class="line">index d54a067fc76..23d73f4f62f 100644</span><br><span class="line">--- a/arch/arm/dts/sun8i-a33-vstar.dts</span><br><span class="line">+++ b/arch/arm/dts/sun8i-a33-vstar.dts</span><br><span class="line">@@ -54,11 +54,11 @@</span><br><span class="line"> compatible = <span class="string">&quot;sinlinx,sina33&quot;</span>, <span class="string">&quot;allwinner,sun8i-a33&quot;</span>;</span><br><span class="line"> </span><br><span class="line"> aliases &#123;</span><br><span class="line">-serial0 = &amp;uart0;</span><br><span class="line">+serial2 = &amp;uart2;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> chosen &#123;</span><br><span class="line">-stdout-path = <span class="string">&quot;serial0:115200n8&quot;</span>;</span><br><span class="line">+stdout-path = <span class="string">&quot;serial2:115200n8&quot;</span>;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> panel &#123;</span><br><span class="line">@@ -261,6 +261,12 @@</span><br><span class="line"> &amp;uart0 &#123;</span><br><span class="line"> pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"> pinctrl-0 = &lt;&amp;uart0_pb_pins&gt;;</span><br><span class="line">+status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">+&#125;;</span><br><span class="line">+</span><br><span class="line">+&amp;uart0 &#123;</span><br><span class="line">+pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">+pinctrl-0 = &lt;&amp;uart2_pins&gt;;</span><br><span class="line"> status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line">@@ -273,3 +279,10 @@</span><br><span class="line"> status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"> usb1_vbus-supply = &lt;&amp;reg_vcc5v0&gt;; /* USB1 VBUS is always on */</span><br><span class="line"> &#125;;</span><br><span class="line">+</span><br><span class="line">+&amp;pio &#123;</span><br><span class="line">+uart2_pins: uart2-pins &#123;</span><br><span class="line">+pins = <span class="string">&quot;PB0&quot;</span>, <span class="string">&quot;PB1&quot;</span>;</span><br><span class="line">+<span class="keyword">function</span> = <span class="string">&quot;uart2&quot;</span>;</span><br><span class="line">+&#125;;</span><br><span class="line">+&#125;;</span><br><span class="line">diff --git a/configs/VStar_A33_defconfig b/configs/VStar_A33_defconfig</span><br><span class="line">index a428e68725f..c6ea136733c 100644</span><br><span class="line">--- a/configs/VStar_A33_defconfig</span><br><span class="line">+++ b/configs/VStar_A33_defconfig</span><br><span class="line">@@ -15,6 +15,7 @@ CONFIG_VIDEO_LCD_BL_PWM=<span class="string">&quot;PH0&quot;</span></span><br><span class="line"> CONFIG_CMD_DFU=y</span><br><span class="line"> CONFIG_DFU_RAM=y</span><br><span class="line"> CONFIG_FASTBOOT_CMD_OEM_FORMAT=y</span><br><span class="line">+CONFIG_CONS_INDEX=3</span><br><span class="line"> CONFIG_USB_EHCI_HCD=y</span><br><span class="line"> CONFIG_USB_OHCI_HCD=y</span><br><span class="line"> CONFIG_USB_MUSB_GADGET=y</span><br></pre></td></tr></table></figure><h3 id="网口使能"><a href="#网口使能" class="headerlink" title="网口使能"></a>网口使能</h3><p>查看原理图可以发现网口使用了rtl8152芯片，这个芯片通过usb通讯，所以dts中根本就不用改动，config中使能该驱动就可以：</p><p><a href="https://postimg.cc/w12Gtj8D"><img src="https://i.postimg.cc/YSBKsvdD/2024-09-14-17-12-17.png" alt="2024-09-14-17-12-17.png"></a></p><p>在menuconfig中使能该驱动，以下是使能该驱动之后config文件的变更：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ diff defconfig configs/VStar_A33_defconfig</span><br><span class="line">22,23d21</span><br><span class="line">&lt; CONFIG_USB_HOST_ETHER=y</span><br><span class="line">&lt; CONFIG_USB_ETHER_RTL8152=y</span><br></pre></td></tr></table></figure><p>重新编译下载，使用dhcp获取ip:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; dhcp</span><br><span class="line">musb-hdrc: peripheral reset irq lost!</span><br><span class="line">high speed config <span class="comment">#2: 2 mA, Ethernet Gadget, using RNDIS</span></span><br><span class="line">USB RNDIS network up!</span><br><span class="line">BOOTP broadcast 1</span><br><span class="line">BOOTP broadcast 2</span><br><span class="line">BOOTP broadcast 3</span><br><span class="line">BOOTP broadcast 4</span><br></pre></td></tr></table></figure><p>什么鬼，看起来走了另一个网口，但是哪来的网口，唯一怀疑的就是usb口的otg模式，rndis协议模拟网口了。</p><p>查看设备树果然有这么一个节点，将其改成disabled：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&amp;usb_otg &#123;</span><br><span class="line">dr_mode = <span class="string">&quot;peripheral&quot;</span>;</span><br><span class="line">status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>重新编译下载发现dhcp显示没有网口，那么看来网口无法识别，注意到uboot启动时有一行显示mac地址无效：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Error: r8152_eth No valid MAC address found.</span><br></pre></td></tr></table></figure><p>在<a href="https://blog.csdn.net/weixin_43479963/article/details/107073502">这里</a>找到了资料，什么！？ mac还需要购买后通过专用工具烧写，去你的吧，这篇博文就从驱动修改入手直接写入了mac地址，但他那是linux的驱动，跟我们这里还是查很多的，我们这里就没有write函数，自己实现起来费力不讨好，而且rtl8152的register的datasheet没有找到，所以这里我们从read入手。</p><p>首先在read函数中加入打印函数，查看一下获取到的mac地址，果然全是0。</p><p>那么很简单，既然读不到mac，那么我就造一个：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">diff --git a/drivers/usb/eth/r8152.c b/drivers/usb/eth/r8152.c</span><br><span class="line">index e3f20e08c33..672b8dac8a6 100644</span><br><span class="line">--- a/drivers/usb/eth/r8152.c</span><br><span class="line">+++ b/drivers/usb/eth/r8152.c</span><br><span class="line">@@ -625,10 +625,14 @@ static int r8152_read_mac(struct r8152 *tp, unsigned char *macaddr)</span><br><span class="line">        int ret;</span><br><span class="line">        unsigned char enetaddr[8] = &#123;0&#125;;</span><br><span class="line"> </span><br><span class="line">        ret = pla_ocp_read(tp, PLA_IDR, 8, enetaddr);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; 0)</span><br><span class="line">                <span class="built_in">return</span> ret;</span><br><span class="line"> </span><br><span class="line">+       <span class="keyword">if</span>(is_zero_ethaddr(enetaddr) || !is_valid_ethaddr(enetaddr))</span><br><span class="line">+               net_random_ethaddr(enetaddr);</span><br><span class="line">+</span><br><span class="line">        memcpy(macaddr, enetaddr, ETH_ALEN);</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line"> &#125;</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure><p>添加的内容就是判断如果mac地址无效的情况下伪造一个fake-mac，这样就可以了。</p><p>重新编译烧写，果然没有那一行报错了，通过dhcp命令动态获取ip:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; dhcp</span><br><span class="line">BOOTP broadcast 1</span><br><span class="line">DHCP client bound to address 192.168.230.34 (36 ms)</span><br><span class="line">*** Warning: no boot file name; using <span class="string">&#x27;C0A8E622.img&#x27;</span></span><br><span class="line">Using r8152_eth device</span><br><span class="line">TFTP from server 192.168.230.1; our IP address is 192.168.230.34</span><br><span class="line">Filename <span class="string">&#x27;C0A8E622.img&#x27;</span>.</span><br><span class="line">Load address: 0x42000000</span><br><span class="line">Loading: *</span><br><span class="line">TFTP error: <span class="string">&#x27;File not found&#x27;</span> (1)</span><br><span class="line">Not retrying...</span><br></pre></td></tr></table></figure><p>这次果然成功获取到ip了，这下可以使用tftp网络获取内核了，调试方便很多。</p><p>但是这里报了一些找不到文件的错误，这是uboot机制，设置一个环境变量就可以解决了</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; setenv <span class="built_in">autoload</span> no</span><br></pre></td></tr></table></figure><p>由于是fel模式，烧写进入的是ram，掉电会丢失，所以saveenv保存不了参数，那么直接把autoload环境变量做到uboot源码里面也是可以的。</p><p>只需要修改<code>include/configs/sunxi-common.h</code>文件即可：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">diff --git a/include/configs/sunxi-common.h b/include/configs/sunxi-common.h</span><br><span class="line">index b29a25d5617..fefc2e291eb 100644</span><br><span class="line">--- a/include/configs/sunxi-common.h</span><br><span class="line">+++ b/include/configs/sunxi-common.h</span><br><span class="line">@@ -297,6 +297,7 @@</span><br><span class="line">        <span class="string">&quot;uuid_gpt_system=&quot;</span> UUID_GPT_SYSTEM <span class="string">&quot;\0&quot;</span> \</span><br><span class="line">        <span class="string">&quot;partitions=&quot;</span> PARTS_DEFAULT <span class="string">&quot;\0&quot;</span> \</span><br><span class="line">        BOOTCMD_SUNXI_COMPAT \</span><br><span class="line">-       BOOTENV</span><br><span class="line">+       BOOTENV \</span><br><span class="line">+       <span class="string">&quot;autoload=no&quot;</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">#endif /* _SUNXI_COMMON_CONFIG_H */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> uboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu使用命令行修改分辨率</title>
      <link href="/2024/09/12/Ubuntu%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BF%AE%E6%94%B9%E5%88%86%E8%BE%A8%E7%8E%87/"/>
      <url>/2024/09/12/Ubuntu%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BF%AE%E6%94%B9%E5%88%86%E8%BE%A8%E7%8E%87/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xrandr</span><br><span class="line">Screen 0: minimum 320 x 200, current 1920 x 1080, maximum 3840 x 2160</span><br><span class="line">HDMI-1 connected primary 1920x1080+0+0 (normal left inverted right x axis y axis) 477mm x 268mm</span><br><span class="line">   1920x1080     60.00*+</span><br><span class="line">   1680x1050     60.00  </span><br><span class="line">   1280x1024     60.00  </span><br><span class="line">   ...</span><br><span class="line">eDP-1 connected (normal left inverted right x axis y axis)</span><br><span class="line">   1366x768      60.00*+</span><br><span class="line">   1280x720      60.00  </span><br><span class="line">   1024x768      60.00  </span><br><span class="line">   ...</span><br><span class="line">$ xrandr --output HDMI-1 --mode 1920x1080</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker上传至hub</title>
      <link href="/2024/09/06/docker%E4%B8%8A%E4%BC%A0%E8%87%B3hub/"/>
      <url>/2024/09/06/docker%E4%B8%8A%E4%BC%A0%E8%87%B3hub/</url>
      
        <content type="html"><![CDATA[<h2 id="将已有容器提交为镜像"><a href="#将已有容器提交为镜像" class="headerlink" title="将已有容器提交为镜像"></a>将已有容器提交为镜像</h2><p>如果你当前有的是一个正在运行的<code>Docker</code>容器，而不是镜像，你可以将这个容器保存为镜像，然后再上传到 <code>Docker Hub</code>。</p><p>可以使用<code>docker commit</code>命令，将当前容器保存为一个新的 Docker 镜像：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ docker commit &lt;container-id&gt; &lt;new-image-name&gt;</span><br></pre></td></tr></table></figure><p>如果你的容器 ID 是 <code>abc123</code>，并且你想把它保存为名为 <code>my-app-image</code> 的镜像：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ docker commit abc123 my-app-image</span><br></pre></td></tr></table></figure><p><strong>如果你需要附加信息，可以使用-m选项添加你要提交的信息</strong></p><p>使用<code>docker images</code>可以查看生成的镜像。</p><h2 id="标记镜像"><a href="#标记镜像" class="headerlink" title="标记镜像"></a>标记镜像</h2><p>现在已经有了一个镜像，即便没有，是容器的话，经过上一步骤也应该有了镜像，现在需要给镜像打标签标记版本：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ docker tag &lt;new-image-name&gt; &lt;hub-username&gt;/&lt;repository-name&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure><h2 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h2><p>现在可以将标记的镜像推送到<code>docker hub</code>了:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ docker push &lt;hub-username&gt;/&lt;repository-name&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure><h2 id="多个标记"><a href="#多个标记" class="headerlink" title="多个标记"></a>多个标记</h2><p>在 <code>Docker Hub </code>中，你可以为同一个镜像创建多个标签（<code>tags</code>），例如 <code>latest</code>、<code>v1.1</code>、<code>v1.2 </code>等，这样可以标识不同的版本，同时保持 <code>latest </code>作为最新版本的标识。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ docker tag &lt;new-image-name&gt; &lt;hub-username&gt;/&lt;repository-name&gt;:latest</span><br><span class="line">❯ docker tag &lt;new-image-name&gt; &lt;hub-username&gt;/&lt;repository-name&gt;:v1.1</span><br><span class="line">❯ docker push &lt;hub-username&gt;/&lt;repository-name&gt;:latest</span><br><span class="line">❯ docker push myusername/&lt;repository-name&gt;:v1.1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用pxelinux启动内核</title>
      <link href="/2024/09/06/%E4%BD%BF%E7%94%A8pxelinux%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/"/>
      <url>/2024/09/06/%E4%BD%BF%E7%94%A8pxelinux%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="Env"><a href="#Env" class="headerlink" title="Env"></a>Env</h2><p>Board: BPI-F3 based on k1 of SpaceMit</p><p><strong>Note: 本文默认已经在主机待建成功tftp服务</strong></p><h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h2><h3 id="设置IP"><a href="#设置IP" class="headerlink" title="设置IP"></a>设置IP</h3><p>在主机上查询<code>ip</code>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ ifconfig</span><br><span class="line">enx00e099a751b1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.230.28  netmask 255.255.255.0  broadcast 192.168.230.255</span><br><span class="line">        inet6 fe80::7d95:76be:c484:17b6  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether 00:e0:99:a7:51:b1  txqueuelen 1000  (以太网)</span><br><span class="line">        RX packets 223389  bytes 75866217 (75.8 MB)</span><br><span class="line">        RX errors 0  dropped 94  overruns 0  frame 0</span><br><span class="line">        TX packets 196725  bytes 223909969 (223.9 MB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p>得到主机<code>ip</code>是<code>192.168.230.28</code>，板子<code>ip</code>确保在一个局域网内就好。</p><p>接下来进入<code>uboot</code>设置<code>ip</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; setenv ipaddr 192.168.230.4</span><br><span class="line">=&gt; setenv serverip 192.168.230.28</span><br><span class="line">=&gt; [ 723.486] <span class="built_in">printenv</span> ipaddr </span><br><span class="line">ipaddr=192.168.230.4</span><br><span class="line">=&gt; [ 727.153] <span class="built_in">printenv</span> serverip</span><br><span class="line">serverip=192.168.230.28</span><br><span class="line">=&gt; saveenv</span><br></pre></td></tr></table></figure><h3 id="配置pxe文件"><a href="#配置pxe文件" class="headerlink" title="配置pxe文件"></a>配置pxe文件</h3><p>在主机上进入<code>tftp</code>文件夹，目录结构如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ tree</span><br><span class="line">.</span><br><span class="line">├── Image</span><br><span class="line">├── k1-x_deb1.dtb</span><br><span class="line">└── pxelinux.cfg</span><br><span class="line">    └── 01-fe-fe-fe-81-b4-a8</span><br><span class="line"></span><br><span class="line">1 directory, 3 files</span><br></pre></td></tr></table></figure><p>其中<code>pxelinux.cfg</code>是存放<code>pxe配置文件</code>的文件夹，由于<code>TFTP</code>服务可能会被多个开发板使用，因此<code>PXE配置文件</code>的名称取决于<code>U-boot</code>参数(板的硬件地址&#x2F; IP地址)。</p><p>优先级最高的是<code>mac</code>地址，在<code>uboot</code>中查看<code>mac</code>地址：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; [ 898.685] <span class="built_in">printenv</span> ethaddr </span><br><span class="line">ethaddr=FE:FE:FE:81:B4:A8</span><br></pre></td></tr></table></figure><p>所以<code>cfg</code>的名字就应该是:  <code>01-fe-fe-fe-81-b4-a8</code></p><p>这个<code>01</code>我也不知道什么意思，反正必须加上。</p><p>接下来就是修改 <code>01-fe-fe-fe-81-b4-a8</code>这个文件了，文件内容格式跟<a href="https://blog.troy-y.org/2024/08/26/%E9%87%8E%E7%81%ABuboot%E4%BD%BF%E7%94%A8extboot%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8%E6%B5%81%E7%A8%8B/#cfg%E6%96%87%E4%BB%B6">extlinux</a>是一模一样的，这里不再赘述。</p><p>文件内容如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">cat</span> pxelinux.cfg/01-fe-fe-fe-81-b4-a8</span><br><span class="line">default linux</span><br><span class="line"></span><br><span class="line">label linux</span><br><span class="line">kernel Image</span><br><span class="line">fdt k1-x_deb1.dtb</span><br><span class="line">append earlycon=sbi earlyprintk quiet splash plymouth.ignore-serial-consoles plymouth.prefer-fbcon console=ttyS0,115200 loglevel=8 clk_ignore_unused swiotlb=65536 rdinit=/init workqueue.default_affinity_scope=system root=/dev/mmcblk2p6 rootwait rootfstype=ext4</span><br></pre></td></tr></table></figure><h2 id="pxe启动"><a href="#pxe启动" class="headerlink" title="pxe启动"></a>pxe启动</h2><p>在<code>uboot</code>中执行如下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pxe get</span><br><span class="line">pxe boot</span><br></pre></td></tr></table></figure><p>经过以上命令按道理来说就可以启动内核了，但是发现启动到一半卡死了，看<code>log</code>发现貌似是设备树没有加载，他使用了一个地址<code>0x7deb2e10</code>的设备树：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=&gt; [1976.087] pxe get</span><br><span class="line">missing environment variable: pxeuuid</span><br><span class="line">[1978.023] Retrieving file: pxelinux.cfg/01-fe-fe-fe-81-b4-a8</span><br><span class="line">[1978.171] ethernet@cac80000 Waiting for PHY auto negotiation to complete...... done</span><br><span class="line">[1981.637] emac_adjust_link link:1 speed:1000 duplex:full</span><br><span class="line">[1981.659] Using ethernet@cac80000 device</span><br><span class="line">[1981.660] TFTP from server 192.168.230.28; our IP address is 192.168.230.4</span><br><span class="line">Filename &#x27;pxelinux.cfg/01-fe-fe-fe-81-b4-a8&#x27;.</span><br><span class="line">Load address: 0xc200000</span><br><span class="line">Loading: #</span><br><span class="line">         [1981.682] 39.1 KiB/s</span><br><span class="line">done</span><br><span class="line">Bytes transferred = 322 (142 hex)</span><br><span class="line">[1981.685] Config file &#x27;&lt;NULL&gt;&#x27; found</span><br><span class="line">=&gt; [1982.858] pxe boot</span><br><span class="line">1:      linux</span><br><span class="line">[1984.100] Retrieving file: Image</span><br><span class="line">[1984.244] ethernet@cac80000 Waiting for PHY auto negotiation to complete...... done</span><br><span class="line">[1987.710] emac_adjust_link link:1 speed:1000 duplex:full</span><br><span class="line">[1987.732] Using ethernet@cac80000 device</span><br><span class="line">[1987.733] TFTP from server 192.168.230.28; our IP address is 192.168.230.4</span><br><span class="line">Filename &#x27;Image&#x27;.</span><br><span class="line">Load address: 0x11000000</span><br><span class="line">Loading: #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #################################################################</span><br><span class="line">         #####</span><br><span class="line">         [2011.448] 1.4 MiB/s</span><br><span class="line">done</span><br><span class="line">Bytes transferred = 34423808 (20d4400 hex)</span><br><span class="line">[2011.451] append: earlycon=sbi earlyprintk quiet splash plymouth.ignore-serial-consoles plymouth.prefer-fbcon console=ttyS0,115200 loglevel=8 clk_igno</span><br><span class="line">re_unused swiotlb=65536 rdinit=/init workqueue.default_affinity_scope=system root=/dev/mmcblk2p6 rootwait rootfstype=ext4</span><br><span class="line">[2011.475] Moving Image from 0x11000000 to 0x200000, end=2358000</span><br><span class="line">[2011.493] ## Flattened Device Tree blob at 7deb2e10</span><br><span class="line">[2011.495]    Booting using the fdt blob at 0x7deb2e10</span><br><span class="line">[2011.500]    Loading Device Tree to 000000007dd8f000, end 000000007dd9cf27 ... OK</span><br></pre></td></tr></table></figure><p>这就很奇怪了，但运气使然，在<code>uboot</code>中发现了这么一个变量：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt;  <span class="built_in">printenv</span> fdtcontroladdr </span><br><span class="line">fdtcontroladdr=7deb2e10</span><br></pre></td></tr></table></figure><p>这和刚才在内存中加载的设备树的地址一模一样，但尝试将他清空再执行<code>pxe</code>，same thing，看来有点运气，但不多。</p><p>经过查询资料发现，<code>pxe</code>会将<code>conf</code>指定的<code>Image</code>加载到<code>kernel_addr_r</code>处，将<code>dtb</code>加载到<code>fdt_addr_r</code>处，那么是否我们的<code>uboot</code>默认只设置了<code>kernel</code>的地址而没有<code>dtb</code>的地址，在<code>uboot</code>中输入以下指令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; [  58.262] <span class="built_in">printenv</span> kernel_addr_r </span><br><span class="line">kernel_addr_r=0x11000000</span><br><span class="line">=&gt; [  59.428] <span class="built_in">printenv</span> dtb_addr_r    </span><br><span class="line"><span class="comment">## Error: &quot;dtb_addr_r&quot; not defined</span></span><br></pre></td></tr></table></figure><p>果然..，增加<code>fdt_addr_r</code>变量：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; <span class="built_in">printenv</span> dtb_addr </span><br><span class="line">dtb_addr=0x31000000</span><br><span class="line">=&gt; setenv fdt_addr_r 0x31000000</span><br><span class="line">=&gt; saveenv</span><br><span class="line">Saving Environment to MMC... Writing to MMC(2)... OK</span><br></pre></td></tr></table></figure><p>此时再通过<code>pxe</code>启动就没有任何问题了。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://blog.csdn.net/weixin_35808698/article/details/117274748">https://blog.csdn.net/weixin_35808698/article/details/117274748</a></p>]]></content>
      
      
      <categories>
          
          <category> uboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenHarmony标准系统认证</title>
      <link href="/2024/09/04/OpenHarmony%E6%A0%87%E5%87%86%E7%B3%BB%E7%BB%9F%E8%AE%A4%E8%AF%81/"/>
      <url>/2024/09/04/OpenHarmony%E6%A0%87%E5%87%86%E7%B3%BB%E7%BB%9F%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p><strong>该部分在Windows上完成</strong></p><p>确保<code>python</code>版本为<code>3.7</code>以上，<code>3.7.8</code>是推荐的，但不是绝对的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python --version</span><br><span class="line">Python 3.7.8</span><br></pre></td></tr></table></figure><p>安装包：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple setuptools</span><br><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyserial</span><br><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple rsa</span><br><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple python-dateutil</span><br></pre></td></tr></table></figure><h2 id="Acts应用兼容性测试"><a href="#Acts应用兼容性测试" class="headerlink" title="Acts应用兼容性测试"></a>Acts应用兼容性测试</h2><p>在<a href="https://www.openharmony.cn/certification/document/xts/">这里</a>选择<code>OH</code>对应的版本的套件和资源文件。</p><p>需要注意的一点就是，<code>Acts</code>套件如果是<code>arm32</code>可以直接下载，但是其他的需要在<code>OH</code>源代码目录进行编译。</p><p>由于这里是arm64, 所以要编译一下<code>Acts</code>套件。</p><p>进入<code>OH</code>的源码根目录后：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="built_in">test</span>/xts/acts</span><br><span class="line">$ ./build.sh product_name=rk3568 system_size=standard</span><br></pre></td></tr></table></figure><p>编译完成后生成目录：</p><pre><code>- 测试用例输出目录: out/rk3568/suites/acts/testcases- 测试框架&amp;用例整体输出目录: out/rk3568/suites/acts</code></pre><p>复制<code>out/rk3568/suites/acts</code>到主机：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">cp</span> -r acts ~/VirtualBox\ VMsWin10/share/oh</span><br></pre></td></tr></table></figure><p>解压下载的资源文件压缩包到<code>acts</code>文件夹里面。</p><p>完成之后目录如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ tree -L 1</span><br><span class="line">.</span><br><span class="line">├── config</span><br><span class="line">├── resource</span><br><span class="line">├── run.bat</span><br><span class="line">├── run.sh</span><br><span class="line">├── testcases</span><br><span class="line">└── tools</span><br><span class="line"></span><br><span class="line">4 directories, 2 files</span><br></pre></td></tr></table></figure><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.openharmony.cn/certification/document/guid">https://www.openharmony.cn/certification/document/guid</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> openHarmony </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rk3568移植主线内核</title>
      <link href="/2024/09/03/rk3568%E7%A7%BB%E6%A4%8D%E4%B8%BB%E7%BA%BF%E5%86%85%E6%A0%B8/"/>
      <url>/2024/09/03/rk3568%E7%A7%BB%E6%A4%8D%E4%B8%BB%E7%BA%BF%E5%86%85%E6%A0%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="Env"><a href="#Env" class="headerlink" title="Env"></a>Env</h2><p>Board: Lubancat-2io</p><p>这篇文章需要用到之前移植的<a href="https://blog.troy-y.org/2024/08/26/rk3568%E7%A7%BB%E6%A4%8Duboot-1/">uboot</a>和<a href="https://blog.troy-y.org/2024/08/26/%E9%87%8E%E7%81%ABuboot%E4%BD%BF%E7%94%A8extboot%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8%E6%B5%81%E7%A8%8B/">extlinux</a>的基础知识。</p><h2 id="Get-source"><a href="#Get-source" class="headerlink" title="Get source"></a>Get source</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ git <span class="built_in">clone</span> git@github.com:torvalds/linux.git </span><br></pre></td></tr></table></figure><p>查看一下<code>dts</code>的内容：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">ls</span> <span class="built_in">arch</span>/arm64/boot/dts/rockchip/rk3568* | grep lubancat</span><br><span class="line"><span class="built_in">arch</span>/arm64/boot/dts/rockchip/rk3568-lubancat-2.dts</span><br></pre></td></tr></table></figure><p>主线是有<code>lubancat-2</code>的设备树的，这就很大的方便了我们，可以稍作修改设备树即可完美在<code>2io</code>上全适配。</p><h2 id="内核config配置"><a href="#内核config配置" class="headerlink" title="内核config配置"></a>内核config配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">ls</span> <span class="built_in">arch</span>/arm64/configs</span><br><span class="line">defconfig  hardening.config   virt.config</span><br></pre></td></tr></table></figure><p>这里并没有<code>rk3568 evb</code>板子的配置文件，所以我们就先使用<code>defconfig</code>就好，遇到什么问题再解决什么问题。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- defconfig</span><br><span class="line">❯ make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j32</span><br><span class="line">❯ <span class="built_in">ls</span> <span class="built_in">arch</span>/arm64/boot/dts/rockchip/rk3568-lubancat-2.dtb</span><br><span class="line"><span class="built_in">arch</span>/arm64/boot/dts/rockchip/rk3568-lubancat-2.dtb</span><br><span class="line">❯ <span class="built_in">ls</span> <span class="built_in">arch</span>/arm64/boot/Image</span><br><span class="line"><span class="built_in">arch</span>/arm64/boot/Image</span><br></pre></td></tr></table></figure><p>依据<a href="https://blog.troy-y.org/2024/08/26/%E9%87%8E%E7%81%ABuboot%E4%BD%BF%E7%94%A8extboot%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8%E6%B5%81%E7%A8%8B/">extlinux</a>的经验，有了内核和设备树之后，我们只需要<code>extlinux.conf</code>文件即可。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">mkdir</span> -p extboot &amp;&amp; <span class="built_in">cp</span> <span class="built_in">arch</span>/arm64/boot/dts/rockchip/rk3568-lubancat-2.dtb extboot &amp;&amp; <span class="built_in">cp</span> <span class="built_in">arch</span>/arm64/boot/Image extboot/Image-master</span><br><span class="line">❯ <span class="built_in">mkdir</span> -p extboot/extlinux/extlinux.conf</span><br></pre></td></tr></table></figure><p>在<code>extboot/extlinux/extlinux.conf</code>文件中写入如下内容：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">label rockchip-master</span><br><span class="line">    kernel /Image-master</span><br><span class="line">    fdt /rk3568-lubancat-2.dtb</span><br><span class="line">    append root=dev/mmcblk0p3 earlyprintk console=ttyFIQ0 console=tty1 consoleblank=0 loglevel=7 rootwait rw rootfstype=ext4 cgroup_enable=cpuset cgroup_memory=1 cgroup_enable=memory swapaccount=1 switolb=1 coherent_pool=1m</span><br></pre></td></tr></table></figure><p>其中<code>append</code>的<code>bootargs</code>来自于<code>lubancat</code>的<code>extlinux.conf</code>，创建好之后查看一下目录文件结构：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ tree extboot</span><br><span class="line">.</span><br><span class="line">├── extlinux</span><br><span class="line">│   ├── extlinux.conf</span><br><span class="line">├── Image-master</span><br><span class="line">├── rk3568-lubancat-2.dtb</span><br><span class="line"></span><br><span class="line">1 directory, 3 files</span><br></pre></td></tr></table></figure><p>一切无误后，就可以生成boot分区的镜像了，注意，这个操作不要在<code>extboot</code>文件夹下操作，否则就会递归：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ genext2fs -b 32768 -B $((<span class="number">64</span>*<span class="number">1024</span>*<span class="number">1024</span>/<span class="number">32768</span>)) -d ./extboot -i 8192 -U boot.img</span><br></pre></td></tr></table></figure><p>刷写进入系统后查看到如下<code>log</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">Found /extlinux/extlinux.conf</span><br><span class="line">Retrieving file: /extlinux/extlinux.conf</span><br><span class="line">929 bytes <span class="built_in">read</span> <span class="keyword">in</span> 3 ms (301.8 KiB/s)</span><br><span class="line">3:      rockchip-6.10</span><br><span class="line">Retrieving file: /Image-6.10</span><br><span class="line">24766472 bytes <span class="built_in">read</span> <span class="keyword">in</span> 153 ms (154.4 MiB/s)</span><br><span class="line">append: dev/mmcblk0p3 earlyprintk console=ttyFIQ0 console=tty1 consoleblank=0 loglevel=7 rootwait rw rootfstype=ext4 cgroup_enable=cpuset cgroup_memory</span><br><span class="line">=1 cgroup_enable=memory swapaccount=1 switolb=1 coherent_pool=1m</span><br><span class="line">Retrieving file: /rk3568-lubancat-2.dtb</span><br><span class="line">60473 bytes <span class="built_in">read</span> <span class="keyword">in</span> 3 ms (19.2 MiB/s)</span><br><span class="line">Fdt Ramdisk skip relocation</span><br><span class="line">No misc partition</span><br><span class="line"><span class="comment">## Flattened Device Tree blob at 0x0a100000</span></span><br><span class="line">   Booting using the fdt blob at 0x0a100000</span><br><span class="line">   Using Device Tree <span class="keyword">in</span> place at 000000000a100000, end 000000000a111c38</span><br><span class="line">can<span class="string">&#x27;t found rockchip,drm-logo, use rockchip,fb-logo</span></span><br><span class="line"><span class="string">WARNING: could not set reg FDT_ERR_BADOFFSET.</span></span><br><span class="line"><span class="string">failed to reserve fb-loader-logo memory</span></span><br><span class="line"><span class="string">WARNING: could not set reg FDT_ERR_BADOFFSET.</span></span><br><span class="line"><span class="string">Adding bank: 0x00200000 - 0x08400000 (size: 0x08200000)</span></span><br><span class="line"><span class="string">Adding bank: 0x09400000 - 0xf0000000 (size: 0xe6c00000)</span></span><br><span class="line"><span class="string">Adding bank: 0x1f0000000 - 0x200000000 (size: 0x10000000)</span></span><br><span class="line"><span class="string">Total: 494.4/538.906 ms</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Starting kernel ...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I/TC: Secondary CPU 1 initializing</span></span><br><span class="line"><span class="string">I/TC: Secondary CPU 1 switching to normal world boot</span></span><br><span class="line"><span class="string">I/TC: Secondary CPU 2 initializing</span></span><br><span class="line"><span class="string">I/TC: Secondary CPU 2 switching to normal world boot</span></span><br><span class="line"><span class="string">I/TC: Secondary CPU 3 initializing</span></span><br><span class="line"><span class="string">I/TC: Secondary CPU 3 switching to normal world boot</span></span><br></pre></td></tr></table></figure><p>然后就没有然后了…，看起来应该是<code>earlycon</code>不对，并且<code>console</code>也没起来，不然不应该什么输出都没有的。</p><p>查看主线内核下的设备树文件发现chosen节点一穷二白：</p><p><img src="https://i.imghippo.com/files/QsQIj1725352719.png" alt="chosen"></p><p>参照鲁班猫的<code>sdk</code>的设备树可以发现<code>earlycon</code>被指定了一个<code>uart8250</code>:</p><p><img src="https://i.imghippo.com/files/6o5uV1725353015.png" alt="chosen"></p><p>参照鲁班猫的<code>sdk</code>的设备树编写<code>extlinux.conf</code>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">label rockchip-master</span><br><span class="line">    kernel /Image-master</span><br><span class="line">    fdt /rk3568-lubancat-2.dtb</span><br><span class="line">    append root=dev/mmcblk0p3 earlycon=uart8250,mmio32,0xfe660000 console=ttyFIQ0 console=tty1 consoleblank=0 loglevel=7 rootwait rw rootfstype=ext4 cgroup_enable=cpuset cgroup_memory=1 cgroup_enable=memory swapaccount=1 switolb=1 coherent_pool=1m</span><br></pre></td></tr></table></figure><p>重新制作镜像后烧写，发现确实在<code>CPU switch</code>之前就能看到<code>log</code>了，但是之后却没有。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[    0.000000] GICv3: MBI range [229:259]</span><br><span class="line">[    0.000000] GICv3: MBI range [289:319]</span><br><span class="line">[    0.000000] GICv3: Using MBI frame 0x00000000fd410000</span><br><span class="line">[    0.000000] Root IRQ handler: gic_handle_irq</span><br><span class="line">[    0.000000] GICv3: GICv3 features: 16 PPIs</span><br><span class="line">[    0.000000] GICv3: GICD_CTRL.DS=0, SCR_EL3.FIQ=1</span><br><span class="line">[    0.000000] GICv3: CPU0: found redistributor 0 region 0:0x00000000fd460000</span><br><span class="line">[    0.000000] ITS: No ITS available, not enabling LPIs</span><br><span class="line">[    0.000000] rcu: srcu_init: Setting srcu_struct sizes based on contention.</span><br><span class="line">[    0.000000] arch_timer: cp15 timer(s) running at 24.00MHz (phys).</span><br><span class="line">[    0.000000] clocksource: arch_sys_counter: mask: 0xffffffffffffff max_cycles: 0x588fe9dc0, max_idle_ns: 440795202592 ns</span><br><span class="line">[    0.000001] sched_clock: 56 bits at 24MHz, resolution 41ns, wraps every 4398046511097ns</span><br><span class="line">[    0.001817] Console: colour dummy device 80x25</span><br><span class="line">[    0.002270] printk: legacy console [tty1] enabled</span><br><span class="line">[    0.002741] printk: legacy bootconsole [uart8250] disabled</span><br><span class="line">I/TC: Secondary CPU 1 initializing</span><br><span class="line">I/TC: Secondary CPU 1 switching to normal world boot</span><br><span class="line">I/TC: Secondary CPU 2 initializing</span><br><span class="line">I/TC: Secondary CPU 2 switching to normal world boot</span><br><span class="line">I/TC: Secondary CPU 3 initializing</span><br><span class="line">I/TC: Secondary CPU 3 switching to normal world boot</span><br></pre></td></tr></table></figure><p>在<code>extlinux.conf</code>文件中定义了这么一句话<code>console=ttyFIQ0</code>，并且在鲁班猫<code>sdk</code>里面能够看到该节点并且有对应的驱动:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">cat</span> <span class="built_in">arch</span>/arm64/boot/dts/rockchip/rk3568-lubancat-2.dtsi | grep fiq-debug</span><br><span class="line">fiq-debugger &#123;</span><br><span class="line">compatible = <span class="string">&quot;rockchip,fiq-debugger&quot;</span>;</span><br><span class="line">❯ find -name <span class="string">&quot;*.c&quot;</span> -<span class="built_in">exec</span> grep -n <span class="string">&quot;rockchip,fiq-debugger&quot;</span> &#123;&#125; +</span><br><span class="line">./drivers/soc/rockchip/rk_fiq_debugger.c:894:&#123; .compatible = <span class="string">&quot;rockchip,fiq-debugger&quot;</span>, &#125;,</span><br></pre></td></tr></table></figure><p>在主线内核的设备树和驱动里面都是没有这g些东西的，所以直接将<code>ttyFIQ0</code>改成<code>ttyS2,1500000</code>就行了，不走这个驱动了。</p><p>这两个硬件上是一个东西，更改后的<code>conf</code>文件如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">label rockchip-master</span><br><span class="line">    kernel /Image-master</span><br><span class="line">    fdt /rk3568-lubancat-2.dtb</span><br><span class="line">    append root=dev/mmcblk0p3 earlycon=uart8250,mmio32,0xfe660000 console=ttyS2,1500000 consoleblank=0 loglevel=7 rootwait rw rootfstype=ext4 cgroup_enable=cpuset cgroup_memory=1 cgroup_enable=memory swapaccount=1 switolb=1 coherent_pool=1m</span><br></pre></td></tr></table></figure><p>重新打包镜像并烧写，可以发现<code>log</code>全部都有了但是无法进入系统：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[    0.998974] mmcblk1rpmb: mmc1:0001 SC6311 4.00 MiB, chardev (239:0)</span><br><span class="line">[   10.939202] platform fe2b0000.mmc: deferred probe pending: platform: <span class="built_in">wait</span> <span class="keyword">for</span> supplier /i2c@fdd40000/pmic@20/regulators/LDO_REG5</span><br><span class="line">[   10.940228] platform fe720000.saradc: deferred probe pending: platform: <span class="built_in">wait</span> <span class="keyword">for</span> supplier /i2c@fdd40000/pmic@20/regulators/LDO_REG7</span><br><span class="line">[   10.941259] platform hdmi-sound: deferred probe pending: asoc-simple-card: parse error</span><br><span class="line">[   10.941969] platform fdc20000.syscon:io-domains: deferred probe pending: platform: <span class="built_in">wait</span> <span class="keyword">for</span> supplier /i2c@fdd40000/pmic@20/regulators/SWITCH_REG1</span><br><span class="line">[   10.943105] platform fe0a0000.hdmi: deferred probe pending: platform: <span class="built_in">wait</span> <span class="keyword">for</span> supplier /i2c@fdd40000/pmic@20/regulators/LDO_REG9</span><br></pre></td></tr></table></figure><p>看起来是<code>regulator</code>的问题，查询设备树中<code>pmic</code>节点芯片对应的是<code>rk809</code>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&amp;i2c0 &#123;</span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">rk809: pmic@20 &#123;</span><br><span class="line">compatible = <span class="string">&quot;rockchip,rk809&quot;</span>;</span><br><span class="line">reg = &lt;0x20&gt;;</span><br><span class="line">interrupt-parent = &lt;&amp;gpio0&gt;;</span><br><span class="line">interrupts = &lt;RK_PA3 IRQ_TYPE_LEVEL_LOW&gt;;</span><br><span class="line">assigned-clocks = &lt;&amp;cru I2S1_MCLKOUT_TX&gt;;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>该设备是一个<code>i2c</code>设备，查找该设备对应的驱动：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ find -name <span class="string">&quot;*.c&quot;</span> -<span class="built_in">exec</span> grep -n <span class="string">&quot;rockchip,rk809&quot;</span> &#123;&#125; +</span><br><span class="line">./drivers/mfd/rk8xx-i2c.c:230:&#123; .compatible = <span class="string">&quot;rockchip,rk809&quot;</span>, .data = &amp;rk809_data &#125;,</span><br><span class="line">❯ <span class="built_in">cat</span> ./drivers/mfd/Makefile | grep rk8xx</span><br><span class="line">obj-$(CONFIG_MFD_RK8XX)+= rk8xx-core.o</span><br><span class="line">obj-$(CONFIG_MFD_RK8XX_I2C)+= rk8xx-i2c.o</span><br><span class="line">obj-$(CONFIG_MFD_RK8XX_SPI)+= rk8xx-spi.o</span><br></pre></td></tr></table></figure><p>所以我们需要打开<code>CONFIG_MFD_RK8XX</code>和<code>CONFIG_MFD_RK8XX_I2C</code>这两个驱动配置。</p><p>烧录到开发板中发现依旧卡死，但是<code>log</code>发生了变化：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[    1.015937] dwmmc_rockchip fe2b0000.mmc: Version ID is 270a</span><br><span class="line">[    1.016498] dwmmc_rockchip fe2b0000.mmc: DW MMC controller at irq 73,32 bit host data width,256 deep fifo</span><br><span class="line">[   11.158200] platform fe720000.saradc: deferred probe pending: rockchip-saradc: failed to get regulator</span><br><span class="line">[   11.159081] platform hdmi-sound: deferred probe pending: asoc-simple-card: parse error</span><br><span class="line">[   11.159808] platform fdc20000.syscon:io-domains: deferred probe pending: (reason unknown)</span><br><span class="line">[   11.159863] dwmmc_rockchip fe2b0000.mmc: IDMAC supports 32-bit address mode.</span><br><span class="line">[   11.160624] platform fe0a0000.hdmi: deferred probe pending: (reason unknown)</span><br><span class="line">[   11.161303] dwmmc_rockchip fe2b0000.mmc: Using internal DMA controller.</span><br><span class="line">[   11.162464] dwmmc_rockchip fe2b0000.mmc: Version ID is 270a</span><br><span class="line">[   11.163053] dwmmc_rockchip fe2b0000.mmc: DW MMC controller at irq 73,32 bit host data width,256 deep fifo</span><br></pre></td></tr></table></figure><p>根据多年卡死经验直接判断是根文件系统无法挂载，但是换回之前鲁班猫的内核就又好了，说明不是文件系统的原因。</p><p>进入<code>uboot</code>查看<code>emmc</code>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; mmc list</span><br><span class="line">dwmmc@fe2b0000: 1</span><br><span class="line">dwmmc@fe2c0000: 2</span><br><span class="line">sdhci@fe310000: 0 (eMMC)</span><br><span class="line">=&gt; mmc info</span><br><span class="line">Device: sdhci@fe310000</span><br><span class="line">Manufacturer ID: ea</span><br><span class="line">OEM: 2d00</span><br><span class="line">Name: SC631 </span><br><span class="line">Timing Interface: HS200</span><br><span class="line">Tran Speed: 200000000</span><br><span class="line">Rd Block Len: 512</span><br><span class="line">MMC version 5.1</span><br><span class="line">High Capacity: Yes</span><br><span class="line">Capacity: 29.1 GiB</span><br><span class="line">Bus Width: 8-bit</span><br><span class="line">Erase Group Size: 512 KiB</span><br><span class="line">HC WP Group Size: 8 MiB</span><br><span class="line">User Capacity: 29.1 GiB WRREL</span><br><span class="line">Boot Capacity: 4 MiB ENH</span><br><span class="line">RPMB Capacity: 4 MiB ENH</span><br></pre></td></tr></table></figure><p>可以看到<code>emmc</code>走的是<code>sdhci</code>，查看设备树发现<code>aliases</code>居然把<code>sdhci</code>搞成了<code>mmc1</code>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aliases &#123;</span><br><span class="line">ethernet0 = &amp;gmac0;</span><br><span class="line">ethernet1 = &amp;gmac1;</span><br><span class="line">mmc0 = &amp;sdmmc0;</span><br><span class="line">mmc1 = &amp;sdhci;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调换<code>sdhci</code>和<code>sdmmc0</code>的顺序：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aliases &#123;</span><br><span class="line">ethernet0 = &amp;gmac0;</span><br><span class="line">ethernet1 = &amp;gmac1;</span><br><span class="line">mmc1 = &amp;sdmmc0;</span><br><span class="line">mmc0 = &amp;sdhci;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时成功进入系统：</p><p><img src="https://i.imghippo.com/files/aqjXi1725354302.png" alt="system"></p>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
          <category> rockchip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> kernel </tag>
            
            <tag> rk3568 </tag>
            
            <tag> rockchip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rk3568的minipcie无法使用usb功能</title>
      <link href="/2024/08/30/rk3568%E7%9A%84minipcie%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8usb%E5%8A%9F%E8%83%BD/"/>
      <url>/2024/08/30/rk3568%E7%9A%84minipcie%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8usb%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">From a8f5220957ebf1e7b45b9093319e4a5a9da13024 Mon Sep 17 00:00:00 2001</span><br><span class="line">From: Troy Mitchell &lt;TroyMitchell988@gmail.com&gt;</span><br><span class="line">Date: Fri, 30 Aug 2024 14:11:28 +0800</span><br><span class="line">Subject: [PATCH 1/1] modify rk3568-hbis-p68.dtsi: add usb hub regulator</span><br><span class="line"> node and the controling gpio that enables the hub.</span><br><span class="line"></span><br><span class="line">Signed-off-by: Troy Mitchell &lt;TroyMitchell988@gmail.com&gt;</span><br><span class="line">---</span><br><span class="line"> .../rk3568/kernel/dts/rk3568-hbis-p68.dtsi    | 86 +++++++++++++++++--</span><br><span class="line"> 1 file changed, 81 insertions(+), 5 deletions(-)</span><br><span class="line"></span><br><span class="line">diff --git a/device/board/hihope/rk3568/kernel/dts/rk3568-hbis-p68.dtsi b/device/board/hihope/rk3568/kernel/dts/rk3568-hbis-p68.dtsi</span><br><span class="line">index 7bc2f81..fa5c3d4 100644</span><br><span class="line">--- a/device/board/hihope/rk3568/kernel/dts/rk3568-hbis-p68.dtsi</span><br><span class="line">+++ b/device/board/hihope/rk3568/kernel/dts/rk3568-hbis-p68.dtsi</span><br><span class="line">@@ -38,9 +38,9 @@</span><br><span class="line"> &#125;;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line">-dc_5v: dc-5v &#123;</span><br><span class="line">+dc_12v: dc-12v &#123;</span><br><span class="line"> compatible = <span class="string">&quot;regulator-fixed&quot;</span>;</span><br><span class="line">-regulator-name = <span class="string">&quot;dc_5v&quot;</span>;</span><br><span class="line">+regulator-name = <span class="string">&quot;dc_12v&quot;</span>;</span><br><span class="line"> regulator-always-on;</span><br><span class="line"> regulator-boot-on;</span><br><span class="line"> regulator-min-microvolt = &lt;5000000&gt;;</span><br><span class="line">@@ -54,7 +54,7 @@</span><br><span class="line"> regulator-boot-on;</span><br><span class="line"> regulator-min-microvolt = &lt;5000000&gt;;</span><br><span class="line"> regulator-max-microvolt = &lt;5000000&gt;;</span><br><span class="line">-vin-supply = &lt;&amp;dc_5v&gt;;</span><br><span class="line">+vin-supply = &lt;&amp;dc_12v&gt;;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> vcc3v3_sys: vcc3v3-sys &#123;</span><br><span class="line">@@ -66,7 +66,17 @@</span><br><span class="line"> regulator-max-microvolt = &lt;3300000&gt;;</span><br><span class="line"> vin-supply = &lt;&amp;vcc5v0_sys&gt;;</span><br><span class="line"> &#125;;</span><br><span class="line">-</span><br><span class="line">+</span><br><span class="line">+vcc5v0_usb: vcc5v0-usb &#123;</span><br><span class="line">+compatible = <span class="string">&quot;regulator-fixed&quot;</span>;</span><br><span class="line">+regulator-name = <span class="string">&quot;vcc5v0_usb&quot;</span>;</span><br><span class="line">+regulator-always-on;</span><br><span class="line">+regulator-boot-on;</span><br><span class="line">+regulator-min-microvolt = &lt;5000000&gt;;</span><br><span class="line">+regulator-max-microvolt = &lt;5000000&gt;;</span><br><span class="line">+vin-supply = &lt;&amp;dc_12v&gt;;</span><br><span class="line">+&#125;;</span><br><span class="line">+/*</span><br><span class="line"> vcc5v0_usb20_host: vcc5v0-usb20-host-regulator &#123;</span><br><span class="line"> compatible = <span class="string">&quot;regulator-fixed&quot;</span>;</span><br><span class="line"> enable-active-high;</span><br><span class="line">@@ -98,6 +108,51 @@</span><br><span class="line"> pinctrl-0 = &lt;&amp;vcc5v0_otg_vbus_en&gt;;</span><br><span class="line"> regulator-name = <span class="string">&quot;vcc5v0_otg_vbus&quot;</span>;</span><br><span class="line"> &#125;;</span><br><span class="line">+*/</span><br><span class="line">+</span><br><span class="line">+vcc5v0_usb20_hub: vcc5v0-usb20-hub-regulator &#123;</span><br><span class="line">+compatible = <span class="string">&quot;regulator-fixed&quot;</span>;</span><br><span class="line">+enable-active-high;</span><br><span class="line">+gpio = &lt;&amp;gpio3 RK_PA6 GPIO_ACTIVE_HIGH&gt;;</span><br><span class="line">+pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">+pinctrl-0 = &lt;&amp;usb20_hub_pwr_en&gt;;</span><br><span class="line">+regulator-name = <span class="string">&quot;vcc5v0_usb20_hub&quot;</span>;</span><br><span class="line">+regulator-always-on;</span><br><span class="line">+vin-supply = &lt;&amp;vcc5v0_usb&gt;;</span><br><span class="line">+&#125;;</span><br><span class="line">+</span><br><span class="line">+vcc5v0_usb30_host: vcc5v0-usb30-host-regulator &#123;</span><br><span class="line">+compatible = <span class="string">&quot;regulator-fixed&quot;</span>;</span><br><span class="line">+enable-active-high;</span><br><span class="line">+gpio = &lt;&amp;gpio0 RK_PD6 GPIO_ACTIVE_HIGH&gt;;</span><br><span class="line">+pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">+pinctrl-0 = &lt;&amp;usb30_host1_pwr_en&gt;;</span><br><span class="line">+regulator-name = <span class="string">&quot;vcc5v0_usb30_host&quot;</span>;</span><br><span class="line">+regulator-always-on;</span><br><span class="line">+vin-supply = &lt;&amp;vcc5v0_usb&gt;;</span><br><span class="line">+&#125;;</span><br><span class="line">+</span><br><span class="line">+vcc5v0_usb20_host: vcc5v0-usb20-host-regulator &#123;</span><br><span class="line">+compatible = <span class="string">&quot;regulator-fixed&quot;</span>;</span><br><span class="line">+enable-active-high;</span><br><span class="line">+gpio = &lt;&amp;gpio0 RK_PD5 GPIO_ACTIVE_HIGH&gt;;</span><br><span class="line">+pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">+pinctrl-0 = &lt;&amp;usb20_host2_pwr_en&gt;;</span><br><span class="line">+regulator-name = <span class="string">&quot;vcc5v0_usb20_host2&quot;</span>;</span><br><span class="line">+regulator-always-on;</span><br><span class="line">+vin-supply = &lt;&amp;vcc5v0_usb&gt;;</span><br><span class="line">+&#125;;</span><br><span class="line">+</span><br><span class="line">+vcc5v0_otg_vbus: vcc5v0-otg-vbus-regulator &#123;</span><br><span class="line">+compatible = <span class="string">&quot;regulator-fixed&quot;</span>;</span><br><span class="line">+enable-active-high;</span><br><span class="line">+gpio = &lt;&amp;gpio0 RK_PD4 GPIO_ACTIVE_HIGH&gt;;</span><br><span class="line">+pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">+pinctrl-0 = &lt;&amp;usb_otg_vbus_en&gt;;</span><br><span class="line">+regulator-name = <span class="string">&quot;vcc5v0_otg&quot;</span>;</span><br><span class="line">+vin-supply = &lt;&amp;vcc5v0_usb&gt;;</span><br><span class="line">+&#125;;</span><br><span class="line">+</span><br><span class="line"> </span><br><span class="line"> mini_pcie_3v3: mini-pcie-3v3-regulator &#123;</span><br><span class="line"> compatible = <span class="string">&quot;regulator-fixed&quot;</span>;</span><br><span class="line">@@ -1173,7 +1228,27 @@</span><br><span class="line"> rockchip,pins = &lt;0 RK_PB0 RK_FUNC_GPIO &amp;pcfg_pull_none&gt;;</span><br><span class="line"> &#125;;</span><br><span class="line"> &#125;;</span><br><span class="line">-</span><br><span class="line">+</span><br><span class="line">+usb &#123;</span><br><span class="line">+usb20_hub_pwr_en: usb20-hub-pwr-en &#123;</span><br><span class="line">+rockchip,pins = &lt;3 RK_PA6 RK_FUNC_GPIO &amp;pcfg_pull_none&gt;;</span><br><span class="line">+&#125;;</span><br><span class="line">+</span><br><span class="line">+usb30_host1_pwr_en: usb30-host1-pwr-en &#123;</span><br><span class="line">+rockchip,pins =&lt;0 RK_PD6 RK_FUNC_GPIO &amp;pcfg_pull_none&gt;;</span><br><span class="line">+&#125;;</span><br><span class="line">+</span><br><span class="line">+usb20_host2_pwr_en: usb20-host2-pwr-en &#123;</span><br><span class="line">+rockchip,pins = &lt;0 RK_PD5 RK_FUNC_GPIO &amp;pcfg_pull_none&gt;;</span><br><span class="line">+&#125;;</span><br><span class="line">+</span><br><span class="line">+usb_otg_vbus_en: usb-otg-vbus-en &#123;</span><br><span class="line">+rockchip,pins = &lt;0 RK_PD4 RK_FUNC_GPIO &amp;pcfg_pull_none&gt;;</span><br><span class="line">+&#125;;</span><br><span class="line">+&#125;;</span><br><span class="line">+</span><br><span class="line">+</span><br><span class="line">+/*</span><br><span class="line"> usb &#123;</span><br><span class="line"> vcc5v0_usb20_host_en: vcc5v0-usb20-host-en &#123;</span><br><span class="line"> rockchip,pins = &lt;0 RK_PD5 RK_FUNC_GPIO &amp;pcfg_pull_none&gt;;</span><br><span class="line">@@ -1187,6 +1262,7 @@</span><br><span class="line"> rockchip,pins = &lt;0 RK_PD3 RK_FUNC_GPIO &amp;pcfg_pull_none&gt;;</span><br><span class="line"> &#125;;</span><br><span class="line"> &#125;;</span><br><span class="line">+*/</span><br><span class="line"> /*</span><br><span class="line"> usb &#123;</span><br><span class="line"> vcc5v0_usb20_host_en: vcc5v0-usb20-host-en &#123;</span><br><span class="line">-- </span><br><span class="line">2.34.1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
          <category> rockchip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rk3568 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>野火uboot使用extboot启动内核流程</title>
      <link href="/2024/08/26/%E9%87%8E%E7%81%ABuboot%E4%BD%BF%E7%94%A8extboot%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8%E6%B5%81%E7%A8%8B/"/>
      <url>/2024/08/26/%E9%87%8E%E7%81%ABuboot%E4%BD%BF%E7%94%A8extboot%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>查看野火<code>uboot</code>参数:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; <span class="built_in">printenv</span> bootcmd</span><br><span class="line">bootcmd=run distro_bootcmd;boot_android <span class="variable">$&#123;devtype&#125;</span> <span class="variable">$&#123;devnum&#125;</span>;boot_fit;bootrkp;</span><br></pre></td></tr></table></figure><p>可以看到第一个命令是<code>distro_bootcmd</code>，事实上，野火的<code>extboot</code>也就是从这里启动的:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; <span class="built_in">printenv</span> distro_bootcmd </span><br><span class="line">distro_bootcmd=<span class="keyword">for</span> target <span class="keyword">in</span> <span class="variable">$&#123;boot_targets&#125;</span>; <span class="keyword">do</span> run bootcmd_<span class="variable">$&#123;target&#125;</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>关于<code>distro_bootcmd</code>更详细的内容可以查看：<a href="https://blog.troy-y.org/2024/08/23/Rockchip-%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87uboot-distro-cmd/">https://blog.troy-y.org/2024/08/23/Rockchip-%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87uboot-distro-cmd/</a></p><p>这里直接进入到<code>bootcmd_mmc0</code>，也就是从<code>emmc</code>启动，<code>sd</code>卡大同小异:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; <span class="built_in">printenv</span> bootcmd_mmc0</span><br><span class="line">bootcmd_mmc0=setenv devnum 0; run mmc_boot</span><br></pre></td></tr></table></figure><p>可以看到<code>bootcmd_mmc0</code>就是设置好<code>devnum</code>变量，然后执行了<code>mmc_boot</code>，这是为了将<code>sd</code>卡和<code>emmc</code>进行抽象，查看<code>mmc_boot</code>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; <span class="built_in">printenv</span> mmc_boot</span><br><span class="line">mmc_boot=<span class="keyword">if</span> mmc dev <span class="variable">$&#123;devnum&#125;</span>; <span class="keyword">then</span> setenv devtype mmc; run scan_dev_for_boot_part; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>在<code>mmc_boot</code>阶段，设置了变量<code>devtype</code>为<code>mmc</code>，然后执行<code>scan_dev_for_boot_part</code>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; <span class="built_in">printenv</span> scan_dev_for_boot_part</span><br><span class="line">scan_dev_for_boot_part=part list <span class="variable">$&#123;devtype&#125;</span> <span class="variable">$&#123;devnum&#125;</span> -bootable devplist; <span class="built_in">env</span> exists devplist || setenv devplist 1; <span class="keyword">for</span> distro_bootpart <span class="keyword">in</span> <span class="variable">$&#123;devplist&#125;</span>;</span><br><span class="line"> <span class="keyword">do</span> <span class="keyword">if</span> fstype <span class="variable">$&#123;devtype&#125;</span> <span class="variable">$&#123;devnum&#125;</span>:<span class="variable">$&#123;distro_bootpart&#125;</span> bootfstype; <span class="keyword">then</span> run scan_dev_for_boot; <span class="keyword">fi</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="scan-dev-for-boot-part"><a href="#scan-dev-for-boot-part" class="headerlink" title="scan_dev_for_boot_part"></a>scan_dev_for_boot_part</h2><p>在<code>scan_dev_for_boot_part</code>阶段就比较复杂了，在uboot中不方便查看，我们转到头文件查看：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// path: ./include/config_distro_bootcmd.h</span></span><br><span class="line"><span class="string">&quot;scan_dev_for_boot_part=&quot;</span>                                         \</span><br><span class="line"><span class="string">&quot;part list $&#123;devtype&#125; $&#123;devnum&#125; -bootable devplist; &quot;</span>     \</span><br><span class="line"><span class="string">&quot;env exists devplist || setenv devplist 1; &quot;</span>              \</span><br><span class="line"><span class="string">&quot;for distro_bootpart in $&#123;devplist&#125;; do &quot;</span>                 \</span><br><span class="line"><span class="string">&quot;if fstype $&#123;devtype&#125; &quot;</span>                           \</span><br><span class="line"><span class="string">&quot;$&#123;devnum&#125;:$&#123;distro_bootpart&#125; &quot;</span>   \</span><br><span class="line"><span class="string">&quot;bootfstype; then &quot;</span>               \</span><br><span class="line"><span class="string">&quot;run scan_dev_for_boot; &quot;</span>                 \</span><br><span class="line"><span class="string">&quot;fi; &quot;</span>                                            \</span><br><span class="line"><span class="string">&quot;done\0&quot;</span>                                                  \</span><br></pre></td></tr></table></figure><p>诸行分析：<br>    - 列出<code>$&#123;devtype&#125; $&#123;devnum&#125; </code>下所有<code>bootable</code>的分区并且将其放到<code>devplist</code>变量中<br>    - 判断<code>devplist</code>是否存在，也就是上一步是否成功，如果不成功设置为<code>1</code><br>    - 使用<code>distro_bootpart</code>变量遍历<code>devplist</code>，假如<code>devplist</code>是<code>2</code>,那么<code>distro_bootpart</code>会是<code>0,1,2</code><br>    - 在<code>for</code>循环中输出<code>$&#123;devtype&#125; $&#123;devnum&#125;:$&#123;distro_bootpart&#125;</code>的文件类型给<code>bootfstype</code>变量<br>    - 运行<code>scan_dev_for_boot</code></p><h2 id="scan-dev-for-boot"><a href="#scan-dev-for-boot" class="headerlink" title="scan_dev_for_boot"></a>scan_dev_for_boot</h2><p>查看<code>scan_dev_for_boot</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// path: ./include/config_distro_bootcmd.h</span></span><br><span class="line"><span class="string">&quot;scan_dev_for_boot=&quot;</span>                                              \</span><br><span class="line"><span class="string">&quot;echo Scanning $&#123;devtype&#125; &quot;</span>                               \</span><br><span class="line"><span class="string">&quot;$&#123;devnum&#125;:$&#123;distro_bootpart&#125;...; &quot;</span>       \</span><br><span class="line"><span class="string">&quot;for prefix in $&#123;boot_prefixes&#125;; do &quot;</span>                     \</span><br><span class="line"><span class="string">&quot;run scan_dev_for_scripts; &quot;</span>                      \</span><br><span class="line"><span class="string">&quot;run scan_dev_for_extlinux; &quot;</span>                     \</span><br><span class="line"><span class="string">&quot;done;&quot;</span>                                                   \</span><br><span class="line">SCAN_DEV_FOR_EFI                                          \</span><br><span class="line"><span class="string">&quot;\0&quot;</span>                                                      \</span><br></pre></td></tr></table></figure><p>这里其实就是打印一个调试信息，然后遍历<code>boot_prefixes</code>去运行两个命令。</p><p>查看<code>boot_prefixes</code>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; <span class="built_in">printenv</span> boot_prefixes </span><br><span class="line">boot_prefixes=/ /boot/</span><br></pre></td></tr></table></figure><p>就是一个<code>boot</code>的前缀，一个是<code>/</code>一个是<code>/boot/</code>。</p><h2 id="scan-dev-for-scripts"><a href="#scan-dev-for-scripts" class="headerlink" title="scan_dev_for_scripts"></a>scan_dev_for_scripts</h2><p>查看<code>scan_dev_for_scripts</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// path: ./include/config_distro_bootcmd.h</span></span><br><span class="line"><span class="string">&quot;scan_dev_for_scripts=&quot;</span>                                           \</span><br><span class="line"><span class="string">&quot;for script in $&#123;boot_scripts&#125;; do &quot;</span>                      \</span><br><span class="line"><span class="string">&quot;if test -e $&#123;devtype&#125; &quot;</span>                          \</span><br><span class="line"><span class="string">&quot;$&#123;devnum&#125;:$&#123;distro_bootpart&#125; &quot;</span>   \</span><br><span class="line"><span class="string">&quot;$&#123;prefix&#125;$&#123;script&#125;; then &quot;</span>       \</span><br><span class="line"><span class="string">&quot;echo Found U-Boot script &quot;</span>               \</span><br><span class="line"><span class="string">&quot;$&#123;prefix&#125;$&#123;script&#125;; &quot;</span>            \</span><br><span class="line"><span class="string">&quot;run boot_a_script; &quot;</span>                     \</span><br><span class="line"><span class="string">&quot;echo SCRIPT FAILED: continuing...; &quot;</span>     \</span><br><span class="line"><span class="string">&quot;fi; &quot;</span>                                            \</span><br><span class="line"><span class="string">&quot;done\0&quot;</span>                                                  \</span><br></pre></td></tr></table></figure><p>其中涉及到一个变量为<code>boot_scripts</code>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; <span class="built_in">printenv</span> boot_scripts </span><br><span class="line">boot_scripts=boot.scr.uimg boot.scr</span><br></pre></td></tr></table></figure><p>诸行分析<code>scan_dev_for_scripts</code>：<br>    - 使用<code>script</code>变量遍历<code>boot_scripts</code><br>    - 判断<code>$&#123;devnum&#125;:$&#123;distro_bootpart&#125; $&#123;prefix&#125;$&#123;script&#125;</code> 文件是否存在<br>    - 如果存在运行<code>boot_a_script</code></p><p>查看<code>boot_a_script</code>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; <span class="built_in">printenv</span> boot_a_script </span><br><span class="line">boot_a_script=load <span class="variable">$&#123;devtype&#125;</span> <span class="variable">$&#123;devnum&#125;</span>:<span class="variable">$&#123;distro_bootpart&#125;</span> <span class="variable">$&#123;scriptaddr&#125;</span> <span class="variable">$&#123;prefix&#125;</span><span class="variable">$&#123;script&#125;</span>; <span class="built_in">source</span> <span class="variable">$&#123;scriptaddr&#125;</span></span><br></pre></td></tr></table></figure><p>将刚才的<code>script</code>文件加载到<code>scriptaddr</code>，并且运行该脚本，<code>source</code>命令就是运行脚本。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; <span class="built_in">printenv</span> scriptaddr</span><br><span class="line">scriptaddr=0x00c00000</span><br></pre></td></tr></table></figure><h3 id="查看野火boot分区下脚本文件"><a href="#查看野火boot分区下脚本文件" class="headerlink" title="查看野火boot分区下脚本文件"></a>查看野火boot分区下脚本文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@lubancat:/boot# <span class="built_in">ls</span> *.scr</span><br><span class="line">boot.scr</span><br></pre></td></tr></table></figure><p>这里就不分析该内容了，该文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if test -e $&#123;devtype&#125; $&#123;devnum&#125;:$&#123;distro_bootpart&#125; /uEnv/uEnv.txt; then  </span><br><span class="line"> </span><br><span class="line">    echo [boot.cmd] load $&#123;devtype&#125; $&#123;devnum&#125;:$&#123;distro_bootpart&#125; $&#123;env_addr_r&#125; //</span><br><span class="line">uEnv/uEnv.txt ...; </span><br><span class="line">    load $&#123;devtype&#125; $&#123;devnum&#125;:$&#123;distro_bootpart&#125; $&#123;env_addr_r&#125; /uEnv/uEnv.txt; </span><br><span class="line"> </span><br><span class="line">    echo [boot.cmd] Importing environment from $&#123;devtype&#125; ... </span><br><span class="line">    env import -t $&#123;env_addr_r&#125; 0x8000 </span><br><span class="line"> </span><br><span class="line">    setenv bootargs $&#123;bootargs&#125; root=/dev/mmcblk$&#123;devnum&#125;p3 $&#123;cmdline&#125; </span><br><span class="line">    printenv bootargs </span><br><span class="line"> </span><br><span class="line">    echo [boot.cmd] load $&#123;devtype&#125; $&#123;devnum&#125;:$&#123;distro_bootpart&#125; $&#123;ramdisk_addr__</span><br><span class="line">r&#125; /initrd-$&#123;uname_r&#125; ... </span><br><span class="line">    load $&#123;devtype&#125; $&#123;devnum&#125;:$&#123;distro_bootpart&#125; $&#123;ramdisk_addr_r&#125; /initrd-$&#123;unaa</span><br><span class="line">me_r&#125; </span><br><span class="line"> </span><br><span class="line">    echo [boot.cmd] loading $&#123;devtype&#125; $&#123;devnum&#125;:$&#123;distro_bootpart&#125; $&#123;kernel_addd</span><br><span class="line">r_r&#125; /Image-$&#123;uname_r&#125; ... </span><br><span class="line">    load $&#123;devtype&#125; $&#123;devnum&#125;:$&#123;distro_bootpart&#125; $&#123;kernel_addr_r&#125; /Image-$&#123;unamee</span><br><span class="line">_r&#125;</span><br><span class="line"></span><br><span class="line">    echo [boot.cmd] loading default rk-kernel.dtb</span><br><span class="line">    load $&#123;devtype&#125; $&#123;devnum&#125;:$&#123;distro_bootpart&#125; $&#123;fdt_addr_r&#125; /rk-kernel.dtb</span><br><span class="line"></span><br><span class="line">    fdt addr  $&#123;fdt_addr_r&#125;</span><br><span class="line">    fdt set /chosen bootargs</span><br><span class="line"></span><br><span class="line">    echo [boot.cmd] dtoverlay from /uEnv/uEnv.txt</span><br><span class="line">    setenv dev_bootpart $&#123;devnum&#125;:$&#123;distro_bootpart&#125;</span><br><span class="line">    dtfile $&#123;fdt_addr_r&#125; $&#123;fdt_over_addr&#125;  /uEnv/uEnv.txt $&#123;env_addr_r&#125;</span><br><span class="line"></span><br><span class="line">    echo [boot.cmd] [$&#123;devtype&#125; $&#123;devnum&#125;:$&#123;distro_bootpart&#125;] ...</span><br><span class="line">    echo [boot.cmd] [booti] ...</span><br><span class="line">    booti $&#123;kernel_addr_r&#125; $&#123;ramdisk_addr_r&#125; $&#123;fdt_addr_r&#125;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo [boot.cmd] run boot.cmd scripts failed ...;</span><br><span class="line"></span><br><span class="line"># Recompile with:</span><br><span class="line"># mkimage -C none -A arm -T script -d /boot/boot.cmd /boot/boot.scr</span><br></pre></td></tr></table></figure><h2 id="scan-dev-for-extlinux"><a href="#scan-dev-for-extlinux" class="headerlink" title="scan_dev_for_extlinux"></a>scan_dev_for_extlinux</h2><p>查看<code>scan_dev_for_extlinux</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// path: ./include/config_distro_bootcmd.h</span></span><br><span class="line"><span class="string">&quot;scan_dev_for_extlinux=&quot;</span>                                          \</span><br><span class="line"><span class="string">&quot;if test -e $&#123;devtype&#125; &quot;</span>                                  \</span><br><span class="line"><span class="string">&quot;$&#123;devnum&#125;:$&#123;distro_bootpart&#125; &quot;</span>           \</span><br><span class="line"><span class="string">&quot;$&#123;prefix&#125;extlinux/extlinux.conf; then &quot;</span>  \</span><br><span class="line"><span class="string">&quot;echo Found $&#123;prefix&#125;extlinux/extlinux.conf; &quot;</span>    \</span><br><span class="line"><span class="string">&quot;run boot_extlinux; &quot;</span>                             \</span><br><span class="line"><span class="string">&quot;echo SCRIPT FAILED: continuing...; &quot;</span>             \</span><br><span class="line"><span class="string">&quot;fi\0&quot;</span>                                                    \</span><br></pre></td></tr></table></figure><p>这里就是判断<code>$&#123;devtype&#125; $&#123;devnum&#125;:$&#123;distro_bootpart&#125; $&#123;prefix&#125;extlinux/extlinux.conf</code>文件是否存在，如果存在的话，就去运行<code>boot_extlinux</code>。</p><h2 id="boot-extlinux"><a href="#boot-extlinux" class="headerlink" title="boot_extlinux"></a>boot_extlinux</h2><p>查看<code>boot_extlinux</code>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; <span class="built_in">printenv</span> boot_extlinux </span><br><span class="line">boot_extlinux=sysboot <span class="variable">$&#123;devtype&#125;</span> <span class="variable">$&#123;devnum&#125;</span>:<span class="variable">$&#123;distro_bootpart&#125;</span> any <span class="variable">$&#123;scriptaddr&#125;</span> <span class="variable">$&#123;prefix&#125;</span>extlinux/extlinux.conf</span><br></pre></td></tr></table></figure><p><code>boot_extlinux</code>中实际调用了<code>sysboot</code>命令，<code>sysboot</code> 是一个 <code>U-Boot</code> 命令，用于从特定设备和文件系统加载并启动 <code>Syslinux</code> 引导文件。<code>Syslinux</code> 是一个轻量级的引导加载程序，通常用于引导 <code>Linux</code> 内核。</p><h3 id="sysboot"><a href="#sysboot" class="headerlink" title="sysboot"></a>sysboot</h3><p>命令格式如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysboot [-p] &lt;interface&gt; &lt;dev[:part]&gt; &lt;ext2|fat|any&gt; [addr] [filename]</span><br></pre></td></tr></table></figure><ul><li>-p: 可选参数，表示使用 “pxelinux” 格式的配置文件。</li><li><interface>: 设备接口类型，例如 mmc、usb、scsi、eth 等。</li><li>&lt;dev[:part]&gt;: 设备号和可选的分区号。例如，0:1 表示设备 0 的第 1 分区。</li><li>&lt;ext2|fat|any&gt;: 文件系统类型，可以是 ext2、fat 或 any。其中 any 会自动检测文件系统类型。</li><li></li><li>[filename]: 可选参数，要加载和解析的 Syslinux 配置文件名，通常是 syslinux.cfg 或 extlinux.conf。</li></ul><p>所以<code>boot_extlinux</code>中就是将<code>$&#123;devtype&#125; $&#123;devnum&#125;:$&#123;distro_bootpart&#125;</code>分区中的<code>$&#123;prefix&#125;extlinux/extlinux.conf</code>文件加载到<code>&#123;scriptaddr&#125;</code>去用<code>sysboot</code>运行，该分区的文件系统类型设置为<code>any</code>意思就是让<code>uboot</code>自动检测文件系统类型。</p><h3 id="cfg文件"><a href="#cfg文件" class="headerlink" title="cfg文件"></a>cfg文件</h3><p>Syslinux 配置文件（通常命名为 syslinux.cfg 或 extlinux.conf）用于指定启动项和相关参数。这个文件的格式比较简单，通常包含启动菜单和内核启动选项。以下是一个典型的 syslinux.cfg 配置文件示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DEFAULT linux</span><br><span class="line">PROMPT 0</span><br><span class="line">TIMEOUT 50</span><br><span class="line"></span><br><span class="line">LABEL linux</span><br><span class="line">    KERNEL /boot/vmlinuz</span><br><span class="line">    APPEND root=/dev/sda1 ro quiet</span><br><span class="line">    INITRD /boot/initrd.img</span><br></pre></td></tr></table></figure><ul><li>DEFAULT: 指定默认启动项的标签（如 LABEL 中定义的名称）。</li><li>PROMPT: 设置是否显示引导菜单。0 表示不显示，直接启动默认项；1 表示显示引导菜单。</li><li>TIMEOUT: 设置等待时间（以1&#x2F;10秒为单位）。例如，50 表示等待5秒，然后启动默认项。</li><li>LABEL: 定义一个启动项，并给它一个名称（如 linux）。<ul><li>KERNEL: 指定要启动的内核文件路径。</li><li>APPEND: 向内核传递的启动参数。例如，root&#x3D;&#x2F;dev&#x2F;sda1 ro quiet 表示根文件系统在 &#x2F;- dev&#x2F;sda1，只读挂载，并且启动时保持静默模式。</li><li>INITRD: 指定初始 RAM 磁盘映像（initrd）文件的路径，通常用于加载必要的驱动程序和文件系统支持。</li></ul></li></ul><p>还可以使用<strong>更高级的选项</strong>：</p><ul><li>SAY: 显示消息给用户。</li><li>MENU DEFAULT: 指定一个菜单项为默认选项。</li><li>FALLBACK: 在默认启动项失败时，指定一个后备启动项。</li><li>MENU LABEL: 给每个启动项设置一个显示在菜单中的名称。</li><li>single: 在 APPEND 中添加 single 参数将 Linux 以单用户模式启动，通常用于故障排查。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DEFAULT linux</span><br><span class="line">PROMPT 1</span><br><span class="line">TIMEOUT 100</span><br><span class="line"></span><br><span class="line">SAY Hello! Welcome to the Syslinux bootloader.</span><br><span class="line"></span><br><span class="line">LABEL linux</span><br><span class="line">    MENU LABEL Start Linux</span><br><span class="line">    KERNEL /boot/vmlinuz</span><br><span class="line">    APPEND root=/dev/sda1 ro quiet</span><br><span class="line">    INITRD /boot/initrd.img</span><br><span class="line">    MENU DEFAULT</span><br><span class="line"></span><br><span class="line">LABEL fallback</span><br><span class="line">    MENU LABEL Fallback Linux</span><br><span class="line">    KERNEL /boot/vmlinuz</span><br><span class="line">    APPEND root=/dev/sda2 ro single</span><br><span class="line">    INITRD /boot/initrd.img</span><br><span class="line">    FALLBACK</span><br></pre></td></tr></table></figure><p>这里需要重点说明的是设备树相关的问题，如果想指定设备树，需要以这样的格式进行指定：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FDT /your-device-tree.dtb</span><br></pre></td></tr></table></figure><p>或者不明确指定设备树，但指定设备树所存在的文件夹，可以用<code>devicetreedir</code>或者<code>fdtdir</code>去指定。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">devicetreedir /</span><br></pre></td></tr></table></figure><p>或者是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fdtdir/</span><br></pre></td></tr></table></figure><p>如果是使用指定设备树文件夹，不明确指定设备树的方式，<code>uboot</code>会使用以下策略来查找设备树：</p><ul><li>自动选择: U-Boot 可能会自动选择与内核文件同名或类似名称的 .dtb 文件。如果内核名是 Image-4.19.232，那么它可能会尝试查找 Image-4.19.232.dtb 或其他类似名称的设备树文件。</li><li>在 U-Boot 中，可以通过环境变量（如 fdtfile）指定设备树文件的路径。如果没有在 extlinux.conf 中明确指定设备树，U-Boot 可能会使用这些环境变量中定义的路径。</li></ul><h3 id="查看野火boot分区下extlinux-conf"><a href="#查看野火boot分区下extlinux-conf" class="headerlink" title="查看野火boot分区下extlinux.conf"></a>查看野火boot分区下extlinux.conf</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@lubancat:/boot# <span class="built_in">cat</span> extlinux/extlinux.conf </span><br><span class="line">label kernel-4.19.232</span><br><span class="line">        kernel /Image-4.19.232</span><br><span class="line">        devicetreedir /</span><br><span class="line">        append  root=/dev/mmcblk0p3 earlyprintk console=ttyFIQ0 console=tty1 consoleblank=0 loglevel=7 rootwait rw rootfstype=ext4 cgroup_enable=cpuset</span><br><span class="line"> cgroup_memory=1 cgroup_enable=memory swapaccount=1 switolb=1 coherent_pool=1m</span><br></pre></td></tr></table></figure><p>可以看到野火的<code>conf</code>文件并没有明确指定设备树，而是指定了一个设备树文件夹，查看设备树文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@lubancat:/boot# <span class="built_in">ls</span> *.dtb</span><br><span class="line">rk-kernel.dtb</span><br><span class="line">root@lubancat:/boot# <span class="built_in">ls</span> Image-4.19.232 </span><br><span class="line">Image-4.19.232</span><br></pre></td></tr></table></figure><p>可以看到并没有与内核同名的设备树文件，那么一定是使用了<code>fdtfile</code>变量来指定设备树。</p><p>进入<code>uboot</code>查看<code>fdtfile</code>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; <span class="built_in">printenv</span> fdtfile </span><br><span class="line">fdtfile=rk-kernel.dtb</span><br></pre></td></tr></table></figure><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://doc.embedfire.com/lubancat-mp157/build_and_deploy/zh/latest/building_image/use_uboot/use_uboot.html">https://doc.embedfire.com/lubancat-mp157/build_and_deploy/zh/latest/building_image/use_uboot/use_uboot.html</a></p>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
          <category> rockchip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rk3568 </tag>
            
            <tag> rockchip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rk3568移植uboot</title>
      <link href="/2024/08/26/rk3568%E7%A7%BB%E6%A4%8Duboot-1/"/>
      <url>/2024/08/26/rk3568%E7%A7%BB%E6%A4%8Duboot-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Env"><a href="#Env" class="headerlink" title="Env"></a>Env</h1><p>Systemt: Ubuntu 22.04</p><h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h2><p>首先克隆仓库：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ git <span class="built_in">clone</span> --depth=1  https://github.com/Caesar-github/u-boot</span><br><span class="line"><span class="comment"># 这是rkbin仓库，至于为什么克隆见https://blog.troy-y.org/2024/08/23/rk3568%E7%A7%BB%E6%A4%8Duboot/</span></span><br><span class="line">❯ git <span class="built_in">clone</span> --depth=1 git@github.com:Caesar-github/rkbin.git</span><br></pre></td></tr></table></figure><p>执行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">cd</span> uboot &amp;&amp; ./make.sh rk3568</span><br></pre></td></tr></table></figure><p>生成以下文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">ls</span> rk356x_spl_loader_v1.13.112.bin</span><br><span class="line">rk356x_spl_loader_v1.13.112.bin</span><br><span class="line">❯ <span class="built_in">ls</span> uboot.img</span><br><span class="line">uboot.img</span><br></pre></td></tr></table></figure><p>其中<code>rk356x_spl_loader_v1.13.112.bin</code>是由rkbin仓库的<code>ddr init.bin</code>和<code>miniloader</code>合并成的，了解原理并手动合成可以看<a href="https://blog.troy-y.org/2024/08/23/rk3568%E7%A7%BB%E6%A4%8Duboot/">https://blog.troy-y.org/2024/08/23/rk3568%E7%A7%BB%E6%A4%8Duboot/</a></p><p><code>uboot.img</code>则是由<code>fit/u-boot.itb</code>拷贝来的，<code>fit/u-boot.itb</code>是一个<code>FIT</code>格式的镜像文件，由<code>fit/u-boot.its</code>指导生成，观察<code>fit/u-boot.its</code>文件如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Copyright (C) 2020 Rockchip Electronic Co.,Ltd</span><br><span class="line"> *</span><br><span class="line"> * Simple U-boot fit <span class="built_in">source</span> file containing ATF/OP-TEE/U-Boot/dtb/MCU</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">description = <span class="string">&quot;FIT Image with ATF/OP-TEE/U-Boot/MCU&quot;</span>;</span><br><span class="line"><span class="comment">#address-cells = &lt;1&gt;;</span></span><br><span class="line"></span><br><span class="line">images &#123;</span><br><span class="line"></span><br><span class="line">uboot &#123;</span><br><span class="line">description = <span class="string">&quot;U-Boot&quot;</span>;</span><br><span class="line">data = /incbin/(<span class="string">&quot;u-boot-nodtb.bin&quot;</span>);</span><br><span class="line"><span class="built_in">type</span> = <span class="string">&quot;standalone&quot;</span>;</span><br><span class="line"><span class="built_in">arch</span> = <span class="string">&quot;arm64&quot;</span>;</span><br><span class="line">os = <span class="string">&quot;U-Boot&quot;</span>;</span><br><span class="line">compression = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">load = &lt;0x00a00000&gt;;</span><br><span class="line"><span class="built_in">hash</span> &#123;</span><br><span class="line">algo = <span class="string">&quot;sha256&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">atf-1 &#123;</span><br><span class="line">description = <span class="string">&quot;ARM Trusted Firmware&quot;</span>;</span><br><span class="line">data = /incbin/(<span class="string">&quot;./bl31_0x00040000.bin&quot;</span>);</span><br><span class="line"><span class="built_in">type</span> = <span class="string">&quot;firmware&quot;</span>;</span><br><span class="line"><span class="built_in">arch</span> = <span class="string">&quot;arm64&quot;</span>;</span><br><span class="line">os = <span class="string">&quot;arm-trusted-firmware&quot;</span>;</span><br><span class="line">compression = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">load = &lt;0x00040000&gt;;</span><br><span class="line"><span class="built_in">hash</span> &#123;</span><br><span class="line">algo = <span class="string">&quot;sha256&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">atf-2 &#123;</span><br><span class="line">description = <span class="string">&quot;ARM Trusted Firmware&quot;</span>;</span><br><span class="line">data = /incbin/(<span class="string">&quot;./bl31_0xfdcc1000.bin&quot;</span>);</span><br><span class="line"><span class="built_in">type</span> = <span class="string">&quot;firmware&quot;</span>;</span><br><span class="line"><span class="built_in">arch</span> = <span class="string">&quot;arm64&quot;</span>;</span><br><span class="line">os = <span class="string">&quot;arm-trusted-firmware&quot;</span>;</span><br><span class="line">compression = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">load = &lt;0xfdcc1000&gt;;</span><br><span class="line"><span class="built_in">hash</span> &#123;</span><br><span class="line">algo = <span class="string">&quot;sha256&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">atf-3 &#123;</span><br><span class="line">description = <span class="string">&quot;ARM Trusted Firmware&quot;</span>;</span><br><span class="line">data = /incbin/(<span class="string">&quot;./bl31_0x0006a000.bin&quot;</span>);</span><br><span class="line"><span class="built_in">type</span> = <span class="string">&quot;firmware&quot;</span>;</span><br><span class="line"><span class="built_in">arch</span> = <span class="string">&quot;arm64&quot;</span>;</span><br><span class="line">os = <span class="string">&quot;arm-trusted-firmware&quot;</span>;</span><br><span class="line">compression = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">load = &lt;0x0006a000&gt;;</span><br><span class="line"><span class="built_in">hash</span> &#123;</span><br><span class="line">algo = <span class="string">&quot;sha256&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">atf-4 &#123;</span><br><span class="line">description = <span class="string">&quot;ARM Trusted Firmware&quot;</span>;</span><br><span class="line">data = /incbin/(<span class="string">&quot;./bl31_0xfdcd0000.bin&quot;</span>);</span><br><span class="line"><span class="built_in">type</span> = <span class="string">&quot;firmware&quot;</span>;</span><br><span class="line"><span class="built_in">arch</span> = <span class="string">&quot;arm64&quot;</span>;</span><br><span class="line">os = <span class="string">&quot;arm-trusted-firmware&quot;</span>;</span><br><span class="line">compression = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">load = &lt;0xfdcd0000&gt;;</span><br><span class="line"><span class="built_in">hash</span> &#123;</span><br><span class="line">algo = <span class="string">&quot;sha256&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">atf-5 &#123;</span><br><span class="line">description = <span class="string">&quot;ARM Trusted Firmware&quot;</span>;</span><br><span class="line">data = /incbin/(<span class="string">&quot;./bl31_0xfdcce000.bin&quot;</span>);</span><br><span class="line"><span class="built_in">type</span> = <span class="string">&quot;firmware&quot;</span>;</span><br><span class="line"><span class="built_in">arch</span> = <span class="string">&quot;arm64&quot;</span>;</span><br><span class="line">os = <span class="string">&quot;arm-trusted-firmware&quot;</span>;</span><br><span class="line">compression = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">load = &lt;0xfdcce000&gt;;</span><br><span class="line"><span class="built_in">hash</span> &#123;</span><br><span class="line">algo = <span class="string">&quot;sha256&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">atf-6 &#123;</span><br><span class="line">description = <span class="string">&quot;ARM Trusted Firmware&quot;</span>;</span><br><span class="line">data = /incbin/(<span class="string">&quot;./bl31_0x00068000.bin&quot;</span>);</span><br><span class="line"><span class="built_in">type</span> = <span class="string">&quot;firmware&quot;</span>;</span><br><span class="line"><span class="built_in">arch</span> = <span class="string">&quot;arm64&quot;</span>;</span><br><span class="line">os = <span class="string">&quot;arm-trusted-firmware&quot;</span>;</span><br><span class="line">compression = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">load = &lt;0x00068000&gt;;</span><br><span class="line"><span class="built_in">hash</span> &#123;</span><br><span class="line">algo = <span class="string">&quot;sha256&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">optee &#123;</span><br><span class="line">description = <span class="string">&quot;OP-TEE&quot;</span>;</span><br><span class="line">data = /incbin/(<span class="string">&quot;tee.bin&quot;</span>);</span><br><span class="line"><span class="built_in">type</span> = <span class="string">&quot;firmware&quot;</span>;</span><br><span class="line"><span class="built_in">arch</span> = <span class="string">&quot;arm64&quot;</span>;</span><br><span class="line">os = <span class="string">&quot;op-tee&quot;</span>;</span><br><span class="line">compression = <span class="string">&quot;none&quot;</span>;</span><br><span class="line"></span><br><span class="line">load = &lt;0x8400000&gt;;</span><br><span class="line"><span class="built_in">hash</span> &#123;</span><br><span class="line">algo = <span class="string">&quot;sha256&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">fdt &#123;</span><br><span class="line">description = <span class="string">&quot;U-Boot dtb&quot;</span>;</span><br><span class="line">data = /incbin/(<span class="string">&quot;./u-boot.dtb&quot;</span>);</span><br><span class="line"><span class="built_in">type</span> = <span class="string">&quot;flat_dt&quot;</span>;</span><br><span class="line"><span class="built_in">arch</span> = <span class="string">&quot;arm64&quot;</span>;</span><br><span class="line">compression = <span class="string">&quot;none&quot;</span>;</span><br><span class="line"><span class="built_in">hash</span> &#123;</span><br><span class="line">algo = <span class="string">&quot;sha256&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">configurations &#123;</span><br><span class="line">default = <span class="string">&quot;conf&quot;</span>;</span><br><span class="line">conf &#123;</span><br><span class="line">description = <span class="string">&quot;rk3568-evb&quot;</span>;</span><br><span class="line">rollback-index = &lt;0x0&gt;;</span><br><span class="line">firmware = <span class="string">&quot;atf-1&quot;</span>;</span><br><span class="line">loadables = <span class="string">&quot;uboot&quot;</span>, <span class="string">&quot;atf-2&quot;</span>, <span class="string">&quot;atf-3&quot;</span>, <span class="string">&quot;atf-4&quot;</span>, <span class="string">&quot;atf-5&quot;</span>, <span class="string">&quot;atf-6&quot;</span>, <span class="string">&quot;optee&quot;</span>;</span><br><span class="line"></span><br><span class="line">fdt = <span class="string">&quot;fdt&quot;</span>;</span><br><span class="line">signature &#123;</span><br><span class="line">algo = <span class="string">&quot;sha256,rsa2048&quot;</span>;</span><br><span class="line"></span><br><span class="line">key-name-hint = <span class="string">&quot;dev&quot;</span>;</span><br><span class="line">sign-images = <span class="string">&quot;fdt&quot;</span>, <span class="string">&quot;firmware&quot;</span>, <span class="string">&quot;loadables&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到这里面将<code>bl31</code>文件分成了很多块和<code>u-boot-nodtb.bin</code>还有<code>u-boot.dtb</code>放入了<code>u-boot.itb</code>，<code>bl31</code>文件是一个<code>trust</code>文件，也就是<code>ATF (Arm trust firmware)</code>，<code>ATF </code>主要负责在启动<code>uboot</code>之前把<code>CPU</code>从安全的<code>EL3</code>切换到 <code>EL2</code>，然后跳转到<code>uboot</code>，并且在内核启动后负责启动其他的CPU。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.cnblogs.com/zyly/p/17389525.html#_label0">https://www.cnblogs.com/zyly/p/17389525.html#_label0</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>docker搭建的ha无法使用homekit bridge</title>
      <link href="/2024/08/26/docker%E6%90%AD%E5%BB%BA%E7%9A%84ha%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8homekit-bridge/"/>
      <url>/2024/08/26/docker%E6%90%AD%E5%BB%BA%E7%9A%84ha%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8homekit-bridge/</url>
      
        <content type="html"><![CDATA[<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://juejin.cn/post/7075383203820732430">https://juejin.cn/post/7075383203820732430</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> home-assistant </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>home assistant远程访问</title>
      <link href="/2024/08/24/home-assistant%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/"/>
      <url>/2024/08/24/home-assistant%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<p>根据链接创建内网穿透：<a href="https://sspai.com/post/79278">https://sspai.com/post/79278</a></p><p>此时打开域名会显示如下信息：</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/0b96f1157a009111e282a8f2c97323b0.png" alt="bad request"></p><p>查看<code>home assistant</code>的日志：</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-10439143/28809a086eb9acbfd4382ab534929919.png" alt="log"></p><p>此时可以看到一个<code>ip</code>，记录下来。</p><p>打开<code>homeassistant</code>的配置文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim </span><br><span class="line"><span class="comment"># 文件末尾添加以下内容</span></span><br><span class="line">http:</span><br><span class="line">  use_x_forwarded_for: <span class="literal">true</span></span><br><span class="line">  trusted_proxies:</span><br><span class="line">    - &lt;<span class="built_in">log</span>中的ip地址&gt;</span><br></pre></td></tr></table></figure><p>重启<code>ha</code>，问题解决</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://cloud.tencent.com/developer/article/2260090">https://cloud.tencent.com/developer/article/2260090</a></p>]]></content>
      
      
      <categories>
          
          <category> home-assistant </category>
          
      </categories>
      
      
        <tags>
            
            <tag> home-assistant </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rk3568 uboot distro_cmd</title>
      <link href="/2024/08/23/Rockchip-%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87uboot-distro-cmd/"/>
      <url>/2024/08/23/Rockchip-%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87uboot-distro-cmd/</url>
      
        <content type="html"><![CDATA[<h2 id="bootcmd"><a href="#bootcmd" class="headerlink" title="bootcmd"></a>bootcmd</h2><p>在<code>uboot</code>的<code>shell</code>中使用<code>printenv</code>命令可以看到<code>bootcmd</code>的字符串：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; <span class="built_in">printenv</span> bootcmd</span><br><span class="line">bootcmd=boot_android <span class="variable">$&#123;devtype&#125;</span> <span class="variable">$&#123;devnum&#125;</span>;boot_fit;bootrkp;run distro_bootcmd;</span><br></pre></td></tr></table></figure><p>命令解析：<br>    - <code>boot_android</code>: 查找并尝试启动安卓镜像。<br>    - <code>boot_fix</code>: 查找并尝试启动fit格式镜像。<br>    - <code>bootrkp</code>: 查找并尝试启动rk分区镜像。<br>    - <code>run distro_bootcmd</code>: 这就是这篇文章的主角了，distro_bootcmd可以根据不同介质去启动<code>kernel</code>内核，比如<code>kernel</code>可以在sd卡，emmc上，都可以顺利启动。</p><p>以上提到的<code>bootcmd</code>可以在<code>include/configs/rockchip-common.h</code>中看到相关定义：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_AVB_VBMETA_PUBLIC_KEY_VALIDATE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RKIMG_BOOTCOMMAND\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;boot_android $&#123;devtype&#125; $&#123;devnum&#125;;&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_FIT_SIGNATURE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RKIMG_BOOTCOMMAND\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;boot_fit;&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RKIMG_BOOTCOMMAND\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;boot_android $&#123;devtype&#125; $&#123;devnum&#125;;&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;boot_fit;&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;bootrkp;&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;run distro_bootcmd;&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="distro-bootcmd"><a href="#distro-bootcmd" class="headerlink" title="distro_bootcmd"></a>distro_bootcmd</h2><p>现在来重点分析一下<code>distro_bootcmd</code>，首先使用打印出<code>distro_bootcmd</code>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; <span class="built_in">printenv</span> distro_bootcmd </span><br><span class="line">distro_bootcmd=<span class="keyword">for</span> target <span class="keyword">in</span> <span class="variable">$&#123;boot_targets&#125;</span>; <span class="keyword">do</span> run bootcmd_<span class="variable">$&#123;target&#125;</span>; <span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<code>uboot</code>源码中找到对应实现，可以看到<code>BOOTENV_SET_SCSI_NEED_INIT</code>这个宏定义是空的，所以不必深究：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTENV \</span></span><br><span class="line"><span class="meta">    BOOTENV_BOOT_TARGETS</span></span><br><span class="line">    ...</span><br><span class="line">BOOT_TARGET_DEVICES(BOOTENV_DEV)                                  \</span><br><span class="line">\</span><br><span class="line"><span class="string">&quot;distro_bootcmd=&quot;</span> BOOTENV_SET_SCSI_NEED_INIT                      \</span><br><span class="line"><span class="string">&quot;for target in $&#123;boot_targets&#125;; do &quot;</span>                      \</span><br><span class="line"><span class="string">&quot;run bootcmd_$&#123;target&#125;; &quot;</span>                         \</span><br><span class="line"><span class="string">&quot;done\0&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="BOOTENV"><a href="#BOOTENV" class="headerlink" title="BOOTENV"></a>BOOTENV</h3><p>在这个<code>BOOTENV</code>宏定义中，定义了<code>distro_bootcmd</code>的值，<code>BOOTENV</code>在<code>include/configs/rk3568_common.h</code>中被使用到：</p><figure class="highlight plaintext"><figcaption><span>CONFIG_EXTRA_ENV_SETTINGS \</span></figcaption><table><tr><td class="code"><pre><span class="line">ENV_MEM_LAYOUT_SETTINGS \</span><br><span class="line">&quot;partitions=&quot; PARTS_RKIMG \</span><br><span class="line">ROCKCHIP_DEVICE_SETTINGS \</span><br><span class="line">RKIMG_DET_BOOTDEV \</span><br><span class="line">BOOTENV</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>而<code>CONFIG_EXTRA_ENV_SETTINGS</code>又在<code>include/env_default.h</code>中被使用到：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEFAULT_ENV_INSTANCE_EMBEDDED</span></span><br><span class="line"><span class="type">env_t</span> environment __UBOOT_ENV_SECTION__ = &#123;</span><br><span class="line">ENV_CRC,<span class="comment">/* CRC Sum */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYS_REDUNDAND_ENVIRONMENT</span></span><br><span class="line"><span class="number">1</span>,<span class="comment">/* Flags: valid */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(DEFAULT_ENV_INSTANCE_STATIC)</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> default_environment[] = &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">const</span> uchar default_environment[] = &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>CONFIG_USE_BOOTARGS</span></span><br><span class="line"><span class="string">&quot;bootargs=&quot;</span>CONFIG_BOOTARGS<span class="string">&quot;\0&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>CONFIG_BOOTCOMMAND</span></span><br><span class="line"><span class="string">&quot;bootcmd=&quot;</span>CONFIG_BOOTCOMMAND<span class="string">&quot;\0&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>CONFIG_EXTRA_ENV_SETTINGS</span></span><br><span class="line">CONFIG_EXTRA_ENV_SETTINGS</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="string">&quot;\0&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEFAULT_ENV_INSTANCE_EMBEDDED</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="TODO-了解这个数组"><a href="#TODO-了解这个数组" class="headerlink" title="TODO 了解这个数组"></a>TODO 了解这个数组</h3><p>回到<code>distro_bootcmd</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTENV \</span></span><br><span class="line"><span class="meta">    BOOTENV_BOOT_TARGETS</span></span><br><span class="line">    ...</span><br><span class="line">BOOT_TARGET_DEVICES(BOOTENV_DEV)                                  \</span><br><span class="line">\</span><br><span class="line"><span class="string">&quot;distro_bootcmd=&quot;</span> BOOTENV_SET_SCSI_NEED_INIT                      \</span><br><span class="line"><span class="string">&quot;for target in $&#123;boot_targets&#125;; do &quot;</span>                      \</span><br><span class="line"><span class="string">&quot;run bootcmd_$&#123;target&#125;; &quot;</span>                         \</span><br><span class="line"><span class="string">&quot;done\0&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里其实就是一个循环，循环遍历<code> $&#123;boot_targets&#125;</code>并执行<code>bootcmd_$&#123;target&#125;</code>,查看<code> $&#123;boot_targets&#125;</code>相关定义：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// path: include/config_distro_bootcmd.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTENV_DEV_NAME(devtypeu, devtypel, instance) \</span></span><br><span class="line"><span class="meta">BOOTENV_DEV_NAME_##devtypeu(devtypeu, devtypel, instance)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTENV_BOOT_TARGETS \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;boot_targets=&quot;</span> BOOT_TARGET_DEVICES(BOOTENV_DEV_NAME) <span class="string">&quot;\0&quot;</span></span></span><br></pre></td></tr></table></figure><h3 id="BOOTENV-BOOT-TARGETS生成boot-targets字符串"><a href="#BOOTENV-BOOT-TARGETS生成boot-targets字符串" class="headerlink" title="BOOTENV_BOOT_TARGETS生成boot_targets字符串"></a>BOOTENV_BOOT_TARGETS生成boot_targets字符串</h3><p>通过<code>BOOTENV_BOOT_TARGETS</code>宏定义生成了<code>boot_targets</code>字符串：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// path: include/config_distro_bootcmd.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTENV_DEV_NAME(devtypeu, devtypel, instance) \</span></span><br><span class="line"><span class="meta">BOOTENV_DEV_NAME_##devtypeu(devtypeu, devtypel, instance)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTENV_BOOT_TARGETS \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;boot_targets=&quot;</span> BOOT_TARGET_DEVICES(BOOTENV_DEV_NAME) <span class="string">&quot;\0&quot;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>[!NOTE]<br>BOOTENV_BOOT_TARGETS也是在BOOTENV中定义的</p></blockquote><p><code>BOOTENV_BOOT_TARGETS</code>调用了<code>BOOT_TARGET_DEVICES</code>宏定义，<code>BOOT_TARGET_DEVICES</code>就是在对应的芯片上或芯片系列的定义了，不同的芯片应有不同的实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// path: include/configs/rockchip-common.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOT_TARGET_DEVICES(func) \</span></span><br><span class="line"><span class="meta">BOOT_TARGET_MMC(func) \</span></span><br><span class="line"><span class="meta">BOOT_TARGET_MTD(func) \</span></span><br><span class="line"><span class="meta">BOOT_TARGET_RKNAND(func) \</span></span><br><span class="line"><span class="meta">BOOT_TARGET_USB(func) \</span></span><br><span class="line"><span class="meta">BOOT_TARGET_PXE(func) \</span></span><br><span class="line"><span class="meta">BOOT_TARGET_DHCP(func)</span></span><br></pre></td></tr></table></figure><p>这里宏定义定义成了6个宏，这里只研究<code>BOOT_TARGET_MMC</code>，其他都是差不多的：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// path: include/configs/rockchip-common.h</span></span><br><span class="line"><span class="comment">/* First try to boot from SD (index 1), then eMMC (index 0) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_IS_ENABLED(CMD_MMC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOT_TARGET_MMC(func) \</span></span><br><span class="line"><span class="meta">func(MMC, mmc, 1) \</span></span><br><span class="line"><span class="meta">func(MMC, mmc, 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOT_TARGET_MMC(func)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>逐级展开：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTENV_DEV_NAME(devtypeu, devtypel, instance) \</span></span><br><span class="line"><span class="meta">BOOTENV_DEV_NAME_##devtypeu(devtypeu, devtypel, instance)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTENV_BOOT_TARGETS \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;boot_targets=&quot;</span> BOOT_TARGET_DEVICES(BOOTENV_DEV_NAME) <span class="string">&quot;\0&quot;</span></span></span><br><span class="line"></span><br><span class="line">    -&gt;（这里就只展开mmc了，道理都一样）</span><br><span class="line">    <span class="string">&quot;boot_targets=&quot;</span>  BOOT_TARGET_MMC(BOOTENV_DEV_NAME) <span class="string">&quot;\0&quot;</span></span><br><span class="line">    -&gt;</span><br><span class="line">    <span class="string">&quot;boot_targets=&quot;</span>  BOOTENV_DEV_NAME(MMC, mmc, <span class="number">1</span>) \</span><br><span class="line">                        BOOTENV_DEV_NAME(MMC, mmc, <span class="number">0</span>)<span class="string">&quot;\0&quot;</span></span><br><span class="line">    -&gt;</span><br><span class="line">    <span class="string">&quot;boot_targets=&quot;</span>  BOOTENV_DEV_NAME_MMC(MMC, mmc, <span class="number">1</span>) \</span><br><span class="line">                        BOOTENV_DEV_NAME_MMC(MMC, mmc, <span class="number">0</span>)<span class="string">&quot;\0&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>BOOTENV_DEV_NAME_MMC</code>宏定义:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// path: include/config_distro_bootcmd.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTENV_DEV_NAME_BLKDEV(devtypeu, devtypel, instance) \</span></span><br><span class="line"><span class="meta">#devtypel #instance <span class="string">&quot; &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTENV_DEV_NAME_MMCBOOTENV_DEV_NAME_BLKDEV</span></span><br></pre></td></tr></table></figure><p>继续展开：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTENV_DEV_NAME(devtypeu, devtypel, instance) \</span></span><br><span class="line"><span class="meta">BOOTENV_DEV_NAME_##devtypeu(devtypeu, devtypel, instance)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTENV_BOOT_TARGETS \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;boot_targets=&quot;</span> BOOT_TARGET_DEVICES(BOOTENV_DEV_NAME) <span class="string">&quot;\0&quot;</span></span></span><br><span class="line"></span><br><span class="line">    -&gt;（这里就只展开mmc了，道理都一样）</span><br><span class="line">    <span class="string">&quot;boot_targets=&quot;</span>  BOOT_TARGET_MMC(BOOTENV_DEV_NAME) <span class="string">&quot;\0&quot;</span></span><br><span class="line">    -&gt;</span><br><span class="line">    <span class="string">&quot;boot_targets=&quot;</span>  BOOTENV_DEV_NAME(MMC, mmc, <span class="number">1</span>) \</span><br><span class="line">                        BOOTENV_DEV_NAME(MMC, mmc, <span class="number">0</span>)<span class="string">&quot;\0&quot;</span></span><br><span class="line">    -&gt;</span><br><span class="line">    <span class="string">&quot;boot_targets=&quot;</span>  BOOTENV_DEV_NAME_MMC(MMC, mmc, <span class="number">1</span>) \</span><br><span class="line">                        BOOTENV_DEV_NAME_MMC(MMC, mmc, <span class="number">0</span>)<span class="string">&quot;\0&quot;</span></span><br><span class="line">    -&gt;</span><br><span class="line">    <span class="string">&quot;boot_targets=&quot;</span>  BOOTENV_DEV_NAME_BLKDEV(MMC, mmc, <span class="number">1</span>) \</span><br><span class="line">                        BOOTENV_DEV_NAME_BLKDEV(MMC, mmc, <span class="number">0</span>)<span class="string">&quot;\0&quot;</span></span><br><span class="line">        -&gt;</span><br><span class="line">    <span class="string">&quot;boot_targets=&quot;</span>  mmc1 mmc0  <span class="string">&quot;\0&quot;</span></span><br></pre></td></tr></table></figure><p>最后<code>boot_targets</code>就变成了下面这样，同时在<code>uboot</code>的<code>shell</code>中验证也是这样：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; <span class="built_in">printenv</span> boot_targets </span><br><span class="line">boot_targets=mmc1 mmc0 mtd2 mtd1 mtd0 usb0 pxe dhcp </span><br></pre></td></tr></table></figure><p><code>boot_targets</code>分析完了，但这只是我们<code>distro_bootcmd</code>循环的变量而已，还有一个<code>run bootcmd_$&#123;target&#125;;</code>没有分析，通过<code>boot_targets</code>能知道，这运行的大概就是<code>bootcmd_mmc0</code>, <code>bootcmd_mmc1</code>这样的东西。</p><h3 id="生成distro-cmd运行命令"><a href="#生成distro-cmd运行命令" class="headerlink" title="生成distro_cmd运行命令"></a>生成distro_cmd运行命令</h3><p>在<code>BOOTENV</code>中有一个宏调用是<code>BOOT_TARGET_DEVICES(BOOTENV_DEV)</code>（上文BOOTENV代码中贴了），现在回顾一下<code>BOOT_TARGET_DEVICES</code>: </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// path: include/configs/rockchip-common.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOT_TARGET_DEVICES(func) \</span></span><br><span class="line"><span class="meta">BOOT_TARGET_MMC(func) \</span></span><br><span class="line"><span class="meta">BOOT_TARGET_MTD(func) \</span></span><br><span class="line"><span class="meta">BOOT_TARGET_RKNAND(func) \</span></span><br><span class="line"><span class="meta">BOOT_TARGET_USB(func) \</span></span><br><span class="line"><span class="meta">BOOT_TARGET_PXE(func) \</span></span><br><span class="line"><span class="meta">BOOT_TARGET_DHCP(func)</span></span><br></pre></td></tr></table></figure><p><code>BOOTENV_DEV</code>定义如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define BOOTENV_DEV_BLKDEV(devtypeu, devtypel, instance) \</span><br><span class="line">&quot;bootcmd_&quot; #devtypel #instance &quot;=&quot; \</span><br><span class="line">&quot;setenv devnum &quot; #instance &quot;; &quot; \</span><br><span class="line">&quot;run &quot; #devtypel &quot;_boot\0&quot;</span><br></pre></td></tr></table></figure><p>逐级展开（只讨论mmc）:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   BOOT_TARGET_DEVICES(BOOTENV_DEV)</span><br><span class="line"></span><br><span class="line">   -&gt;（这里就只展开mmc了，道理都一样）</span><br><span class="line">       BOOT_TARGET_MMC(BOOTENV_DEV) \</span><br><span class="line">   -&gt;</span><br><span class="line">   BOOTENV_DEV(MMC, mmc, <span class="number">1</span>) \</span><br><span class="line">BOOTENV_DEV(MMC, mmc, <span class="number">0</span>)<span class="string">&quot;\0&quot;</span></span><br><span class="line">   -&gt;</span><br><span class="line">   <span class="string">&quot;bootcmd_mmc1=setenv devnum 1;run mmc1_boot\0&quot;</span> \</span><br><span class="line">   <span class="string">&quot;bootcmd_mmc0=setenv devnum 0;run mmc0_boot\0&quot;</span> \</span><br></pre></td></tr></table></figure><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://blog.csdn.net/Andyshrk/article/details/89136721">https://blog.csdn.net/Andyshrk/article/details/89136721</a><br><a href="https://juejin.cn/post/7202851843488088125">https://juejin.cn/post/7202851843488088125</a></p>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
          <category> rockchip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> kernel </tag>
            
            <tag> rk3568 </tag>
            
            <tag> rockchip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rockchip 系列启动流程解读</title>
      <link href="/2024/08/23/rk3568%E7%A7%BB%E6%A4%8Duboot/"/>
      <url>/2024/08/23/rk3568%E7%A7%BB%E6%A4%8Duboot/</url>
      
        <content type="html"><![CDATA[<h2 id="Soc启动流程"><a href="#Soc启动流程" class="headerlink" title="Soc启动流程"></a>Soc启动流程</h2><p>Soc在上电之后，第一个执行的代码是芯片是<code>BootRom</code>，通常来说，SoC厂家都会做一个<code>ROM</code>在SoC的内部，这个<code>ROM</code>很小，里面固化了上电启动的代码（一经固化，永不能改，是芯片做的时候，做进去的）；这部分代码呢，我们管它叫做<code>BootROM</code>，也叫作<code>一级启动程序</code>。</p><p>BootRom需要做的事情：初始化系统，CPU的配置，关闭看门狗，初始化时钟，初始化一些外设（比如 <code>USB Controller</code>、<code>MMC Controller</code>，<code>Nand Controller</code>等）；</p><p><code>BootROM</code>的代码除了去初始化硬件环境以外，还需要去外部存储器上面，将接下来可执行的程序读到内存来执行。</p><p>但此时<code>dram</code>还没有初始化完成，所以并不能直接读取程序到<code>dram</code>上执行，这时候芯片内部自带的<code>sram</code>就派上用场了，但<code>sram</code>造价高昂，所以通常内存容量较小，只能加载一小段程序到sram运行，这一小段程序只需要负责初始化<code>dram</code>。</p><p>初始化好<code>dram</code>之后将跳会到<code>BootRom</code>，<code>BootRom</code>再加载一段程序用以将<code>uboot</code>和<code>trust</code>复制到<code>dram</code>并运行。</p><p>上文提到了一个专业名词叫做<code>trust</code>，因为<code>RK3399</code>是<code>ARM64</code>，所以我们还需要编译·<code>ATF (ARM Trust Firmware)</code>，<code>ATF</code>主要负责在启动<code>uboot</code>之前把CPU从安全的<code>EL3</code>切换到<code>EL2</code>，然后跳转到<code>uboot</code>，并且在内核启动后负责启动其他的CPU。</p><h3 id="开源方式"><a href="#开源方式" class="headerlink" title="开源方式"></a>开源方式</h3><p>在开源方式中，初始化<code>dram</code>的程序叫做<code>TPL</code>; 将<code>uboot</code>加载到<code>dram</code>中的程序叫做<code>SPL</code>.</p><p>在<code>rockchip</code>移植好的uboot中开启以下选项即可编译出来<code>TPL / SPL</code>文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># SPL / TPL</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">CONFIG_SUPPORT_SPL=y</span><br><span class="line">CONFIG_SUPPORT_TPL=y</span><br><span class="line">CONFIG_SPL=y</span><br><span class="line"><span class="comment"># CONFIG_SPL_ADC_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_DECOMP_HEADER is not set</span></span><br><span class="line">CONFIG_SPL_BOARD_INIT=y</span><br><span class="line"><span class="comment"># CONFIG_SPL_BOOTROM_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_RAW_IMAGE_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_LEGACY_IMAGE_SUPPORT is not set</span></span><br><span class="line">CONFIG_SPL_SYS_MALLOC_SIMPLE=y</span><br><span class="line"><span class="comment"># CONFIG_TPL_SYS_MALLOC_SIMPLE is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_STACK_R is not set</span></span><br><span class="line">CONFIG_SPL_SEPARATE_BSS=y</span><br><span class="line"><span class="comment"># CONFIG_SPL_DISPLAY_PRINT is not set</span></span><br><span class="line">CONFIG_SPL_SKIP_RELOCATE=y</span><br><span class="line">CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_SECTOR=y</span><br><span class="line">CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR=0x4000</span><br><span class="line">CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_PARTITION=y</span><br><span class="line">CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_PARTITION=1</span><br><span class="line">CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_PARTITION_NAME=<span class="string">&quot;uboot&quot;</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_CRC32_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_MD5_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_SHA1_SUPPORT is not set</span></span><br><span class="line">CONFIG_SPL_SHA256_SUPPORT=y</span><br><span class="line"><span class="comment"># CONFIG_SPL_FIT_IMAGE_TINY is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_CPU_SUPPORT is not set</span></span><br><span class="line">CONFIG_SPL_CRYPTO_SUPPORT=y</span><br><span class="line">CONFIG_SPL_HASH_SUPPORT=y</span><br><span class="line"><span class="comment"># CONFIG_SPL_DMA_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_ENV_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_EXT_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_FPGA_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_I2C_SUPPORT is not set</span></span><br><span class="line">CONFIG_SPL_MMC_WRITE=y</span><br><span class="line"><span class="comment"># CONFIG_SPL_MPC8XXX_INIT_DDR_SUPPORT is not set</span></span><br><span class="line">CONFIG_SPL_MTD_SUPPORT=y</span><br><span class="line">CONFIG_MTD_BLK_U_BOOT_OFFS=0x4000</span><br><span class="line">CONFIG_SPL_MTD_WRITE=y</span><br><span class="line"><span class="comment"># CONFIG_SPL_MUSB_NEW_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_NET_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_NO_CPU_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_NOR_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_XIP_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_ONENAND_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_OS_BOOT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_PCI_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_PCH_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_POST_MEM_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_POWER_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_PWM_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_RAM_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_RTC_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_SATA_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_RKNAND_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_SPI_FLASH_TINY is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_SPI_FLASH_SFDP_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_SPI_LOAD is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_USB_HOST_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_USB_GADGET is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_YMODEM_SUPPORT is not set</span></span><br><span class="line">CONFIG_SPL_ATF=y</span><br><span class="line"><span class="comment"># CONFIG_SPL_OPTEE_SUPPORT is not set</span></span><br><span class="line">CONFIG_SPL_ATF_NO_PLATFORM_PARAM=y</span><br><span class="line"><span class="comment"># CONFIG_SPL_OPTEE is not set</span></span><br><span class="line">CONFIG_SPL_AB=y</span><br><span class="line"><span class="comment"># CONFIG_SPL_LOAD_RKFW is not set</span></span><br><span class="line"><span class="comment"># CONFIG_SPL_KERNEL_BOOT is not set</span></span><br><span class="line">CONFIG_TPL=y</span><br><span class="line"><span class="comment"># CONFIG_TPL_BOARD_INIT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_TPL_NEEDS_SEPARATE_TEXT_BASE is not set</span></span><br><span class="line"><span class="comment"># CONFIG_TPL_NEEDS_SEPARATE_STACK is not set</span></span><br><span class="line"><span class="comment"># CONFIG_TPL_BOOTROM_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_TPL_DRIVERS_MISC_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_TPL_ENV_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_TPL_I2C_SUPPORT is not set</span></span><br><span class="line">CONFIG_TPL_TINY_FRAMEWORK=y</span><br><span class="line"><span class="comment"># CONFIG_TPL_MPC8XXX_INIT_DDR_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_TPL_MMC_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_TPL_NAND_SUPPORT is not set</span></span><br><span class="line">CONFIG_TPL_SERIAL_SUPPORT=y</span><br><span class="line"><span class="comment"># CONFIG_TPL_SPI_FLASH_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># CONFIG_TPL_SPI_SUPPORT is not set</span></span><br></pre></td></tr></table></figure><p>编译出来的文件如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">ls</span> spl</span><br><span class="line"><span class="built_in">arch</span>   cmd     disk     dts  fs       lib         u-boot-spl      u-boot-spl.dtb      u-boot-spl.lds  u-boot-spl-nodtb.bin</span><br><span class="line">board  common  drivers  <span class="built_in">env</span>  include  u-boot.cfg  u-boot-spl.bin  u-boot-spl-dtb.bin  u-boot-spl.map  u-boot-spl.sym</span><br><span class="line">❯ <span class="built_in">ls</span> tpl</span><br><span class="line"><span class="built_in">arch</span>   cmd     disk     dts  fs       lib         u-boot-spl.lds  u-boot-tpl.bin      u-boot-tpl.map        u-boot-tpl.sym</span><br><span class="line">board  common  drivers  <span class="built_in">env</span>  include  u-boot.cfg  u-boot-tpl      u-boot-tpl-dtb.bin  u-boot-tpl-nodtb.bin</span><br></pre></td></tr></table></figure><p>将这两个文件打包成loader镜像：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ tools/mkimage -n rk3399 -T rksd -d tpl/u-boot-tpl.bin idbloader.img</span><br><span class="line">Image Type:   Rockchip RK33 (SD/MMC) boot image</span><br><span class="line">Init Data Size: 2048 bytes</span><br><span class="line">❯ ll idbloader.img</span><br><span class="line">-rw-rw-r-- 1 troy troy 4.0K  8月 23 16:39 idbloader.img</span><br><span class="line">❯ <span class="built_in">cat</span> spl/u-boot-spl.bin &gt;&gt; idbloader.img</span><br><span class="line">❯ ll idbloader.img</span><br><span class="line">-rw-rw-r-- 1 troy troy 244K  8月 23 16:39 idbloader.img</span><br></pre></td></tr></table></figure><h3 id="闭源方式"><a href="#闭源方式" class="headerlink" title="闭源方式"></a>闭源方式</h3><p>在官方固件加载方式中，我们基于<code>Rockchip rkbin</code>官方给的<code>ddr.bin</code>、<code>miniloader.bin</code>来实现的: <a href="https://github.com/Caesar-github/rkbin">https://github.com/Caesar-github/rkbin</a></p><p>1.通过<code>tools/mkimage</code>将官方固件<code>ddr</code>, <code>miniloader</code>打包成<code>BootROM</code>程序可识别的、带有<code>ID Block header</code>的文件<code>idbloader.img</code>；</p><p><code>ddr.bin</code>：等价于上面说的<code>TPL</code>，用于初始化<code>DDR</code>；<br>miniloader.bin：Rockchip修改的一个bootloader，等价于上面说的SPL，用于加载uboot；<br>这个文件打包出来实际上也是超过192KB的，因此也是分为二阶段执行的。</p><ol start="2"><li>通过tools&#x2F;loaderimage工具将u-boot.bin打包成u-boot.img；其中u-boot.bin是由uboot源码编译生成；</li></ol><p>补充说明：使用Rockchip miniloader的 idbloader 时，需要将u-boot.bin通过tools&#x2F;loaderimage转换为可加载的miniloader格式。</p><p>3.使用Rockchip工具tools&#x2F;trust_merge将bl31.bin打包成trust.img；其中bl31.bin由ATF源码编译生成；</p><p>补充说明：使用Rockchip miniloader的idbloader 时，需要将bl31.bin通过tools&#x2F;trust_merge转换为可加载的miniloader格式。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.cnblogs.com/zyly/p/17380243.html">https://www.cnblogs.com/zyly/p/17380243.html</a><br><a href="https://www.cnblogs.com/zyly/p/17389525.html#_label0">https://www.cnblogs.com/zyly/p/17389525.html#_label0</a><br><a href="https://github.com/Caesar-github/docs/tree/master/Common/UBOOT">https://github.com/Caesar-github/docs/tree/master/Common/UBOOT</a></p>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
          <category> rockchip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rockchip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenHarmony on rk3568使能can</title>
      <link href="/2024/08/22/OpenHarmony-on-rk3568%E4%BD%BF%E8%83%BDcan/"/>
      <url>/2024/08/22/OpenHarmony-on-rk3568%E4%BD%BF%E8%83%BDcan/</url>
      
        <content type="html"><![CDATA[<h2 id="Env"><a href="#Env" class="headerlink" title="Env"></a>Env</h2><p>OH: v3.2.3<br>chip: rk3568</p><h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h2><p>首先查看源码中是否具有<code>CAN_ROCKCHIP</code>选项：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ find -name <span class="string">&quot;Kconfig&quot;</span> -<span class="built_in">exec</span> grep -n <span class="string">&quot;CAN_ROCKCHIP&quot;</span> &#123;&#125; +</span><br><span class="line">❯ </span><br></pre></td></tr></table></figure><p>发现什么都没有..好吧，那看到官方的rk3568的补丁并没有打到这里，需要自己进行适配。</p><p>去rockchip的kernel仓库找到关于can的部分：<a href="https://github.com/rockchip-linux/kernel/blob/develop-5.10/drivers/net/can/rockchip/">https://github.com/rockchip-linux/kernel/blob/develop-5.10/drivers/net/can/rockchip/</a></p><p>进入到我们的内核工作目录，没有Makefile创建的可以见这篇文章：<a href="https://blog.troy-y.org/2024/08/16/rk3568%E7%A7%BB%E6%A4%8DopenHarmony-v3-2-3-%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/">https://blog.troy-y.org/2024/08/16/rk3568%E7%A7%BB%E6%A4%8DopenHarmony-v3-2-3-%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/</a></p><p>将刚才仓库的文件无论用什么方式放到<code>driver/net/can/rockchip</code>目录下，随后进行<code>git</code>操作:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ git add drivers/net/can/Makefile</span><br><span class="line">❯ git add drivers/net/can/Kconfig</span><br><span class="line">❯ git commit -m <span class="string">&quot;can init&quot;</span></span><br></pre></td></tr></table></figure><p>并且修改<code>driver/net/can/Makefile</code>和<code>driver/net/can/Kconfig</code>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ diff drivers/net/can/Makefile mmm</span><br><span class="line">32d31</span><br><span class="line">&lt; obj-$(CONFIG_CAN_ROCKCHIP)+= rockchip/</span><br><span class="line">❯ diff drivers/net/can/Kconfig kkk</span><br><span class="line">181d180</span><br><span class="line">&lt; <span class="built_in">source</span> <span class="string">&quot;drivers/net/can/rockchip/Kconfig&quot;</span></span><br></pre></td></tr></table></figure><p>随后修改<code>config</code>文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ diff <span class="built_in">arch</span>/arm64/configs/rockchip_linux_defconfig ccc</span><br><span class="line">6858,6860d6857</span><br><span class="line">&lt; CONFIG_CAN=y</span><br><span class="line">&lt; CONFIG_CAN_ROFKCHIP=y</span><br><span class="line">&lt; CONFIG_CANFD_ROCKCHIP=y</span><br></pre></td></tr></table></figure><p>继续<code>git</code>操作:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ git add drivers/net/can/Makefile</span><br><span class="line">❯ git add drivers/net/can/Kconfig</span><br><span class="line">❯ git add drivers/net/can/rockchip</span><br><span class="line">❯ git commit -m <span class="string">&quot;add can support&quot;</span></span><br></pre></td></tr></table></figure><p>生成<code>patch</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ git format-patch --subject-prefix=<span class="string">&#x27;PATCH&#x27;</span> -n -s -1</span><br><span class="line">0001-add-can-support.patch</span><br><span class="line">❯ <span class="built_in">cp</span> 0001-add-can-support.patch /mnt/v3.2.3/kernel/linux/patches/linux-5.10/rk3568_patch/add-can-support.patch &amp;&amp; <span class="built_in">rm</span> *.patch</span><br></pre></td></tr></table></figure><p>修改编译脚本：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ diff device/board/hihope/rk3568/kernel/build_kernel.sh device/board/hihope/rk3568/kernel/build_kernel.sh.1</span><br><span class="line">34,35c34</span><br><span class="line">&lt; <span class="variable">$&#123;ROOT_DIR&#125;</span>/kernel/linux/patches/linux-5.10/rk3568_patch/add-jl201-drivers.patch</span><br><span class="line">&lt; <span class="variable">$&#123;ROOT_DIR&#125;</span>/kernel/linux/patches/linux-5.10/rk3568_patch/add-can-support.patch<span class="string">&quot;</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string">&gt; <span class="variable">$&#123;ROOT_DIR&#125;</span>/kernel/linux/patches/linux-5.10/rk3568_patch/add-jl201-drivers.patch&quot;</span></span><br></pre></td></tr></table></figure><p>修改设备树：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ vim device/board/hihope/rk3568/kernel/dts/rk3568-xxx.dtsi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下内容添加</span></span><br><span class="line">&amp;can2 &#123;</span><br><span class="line">compatible = <span class="string">&quot;rockchip,rk3568-can-2.0&quot;</span>;</span><br><span class="line">pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">pinctrl-0 = &lt;&amp;can2m0_pins&gt;;</span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://blog.troy-y.org/2024/08/16/rk3568%E7%A7%BB%E6%A4%8DopenHarmony-v3-2-3-%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/">https://blog.troy-y.org/2024/08/16/rk3568%E7%A7%BB%E6%A4%8DopenHarmony-v3-2-3-%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/</a><br><a href="https://github.com/rockchip-linux/kernel/blob/develop-5.10/drivers/net/can/rockchip/">https://github.com/rockchip-linux/kernel/blob/develop-5.10/drivers/net/can/rockchip/</a></p>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
          <category> rockchip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> openHarmony </tag>
            
            <tag> kernel </tag>
            
            <tag> rk3568 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenHarmony on rk3568驱动intel 7260无线网卡</title>
      <link href="/2024/08/21/rk3568%E4%BD%BF%E7%94%A8mini-pcie%E9%A9%B1%E5%8A%A8intel-7260/"/>
      <url>/2024/08/21/rk3568%E4%BD%BF%E7%94%A8mini-pcie%E9%A9%B1%E5%8A%A8intel-7260/</url>
      
        <content type="html"><![CDATA[<h2 id="Env"><a href="#Env" class="headerlink" title="Env"></a>Env</h2><p>OH: v3.2.3<br>chip: rk3568</p><h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h2><p>使用以下命令查找<code>intel 7260</code>的驱动配置:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ find -name <span class="string">&quot;Kconfig&quot;</span> -<span class="built_in">exec</span> grep -n <span class="string">&quot;7260&quot;</span> &#123;&#125; +</span><br><span class="line">./drivers/watchdog/Kconfig:689:  Technologic Systems TS-7200, TS-7250 and TS-7260 boards have</span><br><span class="line">./drivers/net/wireless/intel/iwlwifi/Kconfig:22:Intel 7260 Wi-Fi Adapter</span><br></pre></td></tr></table></figure><p>在<code>./drivers/net/wireless/intel/iwlwifi/Kconfig</code>找到了其配置，进去查看：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">config IWLWIFI</span><br><span class="line">tristate <span class="string">&quot;Intel Wireless WiFi Next Gen AGN - Wireless-N/Advanced-N/Ultimate-N (iwlwifi) &quot;</span></span><br><span class="line">depends on PCI &amp;&amp; HAS_IOMEM &amp;&amp; CFG80211</span><br><span class="line"><span class="keyword">select</span> FW_LOADER</span><br><span class="line"><span class="built_in">help</span></span><br><span class="line">  Select to build the driver supporting the:</span><br><span class="line"></span><br><span class="line">  Intel Wireless WiFi Link Next-Gen AGN</span><br><span class="line"></span><br><span class="line">  This option enables support <span class="keyword">for</span> use with the following hardware:</span><br><span class="line">Intel Wireless WiFi Link 6250AGN Adapter</span><br><span class="line">Intel 6000 Series Wi-Fi Adapters (6200AGN and 6300AGN)</span><br><span class="line">Intel WiFi Link 1000BGN</span><br><span class="line">Intel Wireless WiFi 5150AGN</span><br><span class="line">Intel Wireless WiFi 5100AGN, 5300AGN, and 5350AGN</span><br><span class="line">Intel 6005 Series Wi-Fi Adapters</span><br><span class="line">Intel 6030 Series Wi-Fi Adapters</span><br><span class="line">Intel Wireless WiFi Link 6150BGN 2 Adapter</span><br><span class="line">Intel 100 Series Wi-Fi Adapters (100BGN and 130BGN)</span><br><span class="line">Intel 2000 Series Wi-Fi Adapters</span><br><span class="line">Intel 7260 Wi-Fi Adapter</span><br><span class="line">Intel 3160 Wi-Fi Adapter</span><br><span class="line">Intel 7265 Wi-Fi Adapter</span><br><span class="line">Intel 8260 Wi-Fi Adapter</span><br><span class="line">Intel 3165 Wi-Fi Adapter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  This driver uses the kernel<span class="string">&#x27;s mac80211 subsystem.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  In order to use this driver, you will need a firmware</span></span><br><span class="line"><span class="string">  image for it. You can obtain the microcode from:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">          &lt;https://wireless.wiki.kernel.org/en/users/Drivers/iwlwifi&gt;.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  The firmware is typically installed in /lib/firmware. You can</span></span><br><span class="line"><span class="string">  look in the hotplug script /etc/hotplug/firmware.agent to</span></span><br><span class="line"><span class="string">  determine which directory FIRMWARE_DIR is set to when the script</span></span><br><span class="line"><span class="string">  runs.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  If you want to compile the driver as a module ( = code which can be</span></span><br><span class="line"><span class="string">  inserted in and removed from the running kernel whenever you want),</span></span><br><span class="line"><span class="string">  say M here and read &lt;file:Documentation/kbuild/modules.rst&gt;.  The</span></span><br><span class="line"><span class="string">  module will be called iwlwifi.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if IWLWIFI</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">config IWLWIFI_LEDS</span></span><br><span class="line"><span class="string">bool</span></span><br><span class="line"><span class="string">depends on LEDS_CLASS=y || LEDS_CLASS=IWLWIFI</span></span><br><span class="line"><span class="string">depends on IWLMVM || IWLDVM</span></span><br><span class="line"><span class="string">select LEDS_TRIGGERS</span></span><br><span class="line"><span class="string">select MAC80211_LEDS</span></span><br><span class="line"><span class="string">default y</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">config IWLDVM</span></span><br><span class="line"><span class="string">tristate &quot;Intel Wireless WiFi DVM Firmware support&quot;</span></span><br><span class="line"><span class="string">depends on MAC80211</span></span><br><span class="line"><span class="string">help</span></span><br><span class="line"><span class="string">  This is the driver that supports the DVM firmware. The list</span></span><br><span class="line"><span class="string">  of the devices that use this firmware is available here:</span></span><br><span class="line"><span class="string">  https://wireless.wiki.kernel.org/en/users/drivers/iwlwifi#firmware</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">config IWLMVM</span></span><br><span class="line"><span class="string">tristate &quot;Intel Wireless WiFi MVM Firmware support&quot;</span></span><br><span class="line"><span class="string">select WANT_DEV_COREDUMP</span></span><br><span class="line"><span class="string">depends on MAC80211</span></span><br><span class="line"><span class="string">help</span></span><br><span class="line"><span class="string">  This is the driver that supports the MVM firmware. The list</span></span><br><span class="line"><span class="string">  of the devices that use this firmware is available here:</span></span><br><span class="line"><span class="string">  https://wireless.wiki.kernel.org/en/users/drivers/iwlwifi#firmware</span></span><br></pre></td></tr></table></figure><p>创建文件夹并拷贝<code>firmware</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p device/board/hihope/rk3568/kernel/firmware/ &amp;&amp; <span class="built_in">cp</span> &lt;firmware_path&gt; device/board/hihope/rk3568/kernel/firmware/</span><br></pre></td></tr></table></figure><p>修改编译脚本：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ diff device/board/hihope/rk3568/kernel/build_kernel.sh device/board/hihope/rk3568/kernel/build_kernel.sh.1</span><br><span class="line">77,81d76</span><br><span class="line">&lt; <span class="comment"># firmware</span></span><br><span class="line">&lt; <span class="built_in">mkdir</span> -p <span class="variable">$&#123;KERNEL_SRC_TMP_PATH&#125;</span>/kernel/firmware</span><br><span class="line">&lt; <span class="built_in">cp</span>  -rf <span class="variable">$&#123;3&#125;</span>/kernel/firmware/* <span class="variable">$&#123;KERNEL_SRC_TMP_PATH&#125;</span>/kernel/firmware</span><br><span class="line">&lt; </span><br><span class="line">&lt; </span><br></pre></td></tr></table></figure><p>查看日志初始化成功：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dmesg | grep iwl</span></span><br><span class="line">[    2.899279] iwlwifi 0000:01:00.0: enabling device (0000 -&gt; 0002)</span><br><span class="line">[    2.902993] iwlwifi 0000:01:00.0: loaded firmware version 17.3216344376.0 7260-17.ucode op_mode iwlmvm</span><br><span class="line">[    2.903274] iwlwifi 0000:01:00.0: Detected Intel(R) Dual Band Wireless AC 7260, REV=0x144</span><br><span class="line">[    2.909365] iwlwifi 0000:01:00.0: reporting RF_KILL (radio disabled)</span><br><span class="line">[    2.909427] iwlwifi 0000:01:00.0: RF_KILL bit toggled to <span class="built_in">disable</span> radio.</span><br><span class="line">[    2.950167] iwlwifi 0000:01:00.0: base HW address: 80:86:f2:c3:ff:00</span><br><span class="line">[    2.969690] ieee80211 phy0: Selected rate control algorithm <span class="string">&#x27;iwl-mvm-rs&#x27;</span></span><br></pre></td></tr></table></figure><p>使用<code>ifconfig</code>能够查看到，但是操作失败：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ifconfig wlan0</span></span><br><span class="line">wlan0     Link encap:Ethernet  HWaddr 80:86:f2:c3:ff:00  Driver iwlwifi</span><br><span class="line">          BROADCAST MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0 </span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 </span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:0 TX bytes:0 </span><br><span class="line"></span><br><span class="line"><span class="comment"># ifconfig wlan0 up</span></span><br><span class="line">ifconfig: ioctl 8914: No error information</span><br></pre></td></tr></table></figure><p>使用rfkill查看状态：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rfkill list</span></span><br><span class="line">0: phy0: wlan</span><br><span class="line">        Soft blocked: no</span><br><span class="line">        Hard blocked: <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><p>发现被锁定了，尝试解锁但是失败了..：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rfkill unblock all</span></span><br><span class="line"><span class="comment"># rfkill list                                                                  </span></span><br><span class="line">0: phy0: wlan</span><br><span class="line">        Soft blocked: no</span><br><span class="line">        Hard blocked: <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><p>根据原理图和设备树，我们锁定两个引脚，一个是<code>reset</code>一个是<code>disable</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* mini pcie */</span></span><br><span class="line">&amp;pcie2x1 &#123;</span><br><span class="line">reset-gpios = &lt;&amp;gpio3 RK_PC1 GPIO_ACTIVE_HIGH&gt;;</span><br><span class="line">disable-gpios = &lt;&amp;gpio3 RK_PC2 GPIO_ACTIVE_HIGH&gt;;</span><br><span class="line">vpcie3v3-supply = &lt;&amp;mini_pcie_3v3&gt;;</span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://i.postimg.cc/Y2TpH1Pq/2024-09-02-15-56-00.png" alt="2024-09-02-15-56-00.png"></p><p>经过万用表测量<code>reset</code>引脚在进入<code>shell</code>后是高电平，而<code>disable</code>引脚则从上电到进入<code>shell</code>一直都是低电平。</p><p>那么应该可以确定问题所在了，就是<code>disable</code>搞得鬼。</p><p>查看文档<code>Documentation/devicetree/bindings/pci/rockchip-pcie-host.txt</code>中并没有关于<code>disable</code>的说明，这让我大感奇怪：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">cat</span> Documentation/devicetree/bindings/pci/rockchip-pcie-host.txt | grep <span class="built_in">disable</span></span><br></pre></td></tr></table></figure><p>因为这个设备树的基准文件来自于野火<code>sdk</code>的<code>4.19</code>版本，所以这时候还在怀疑是不是<code>5.10</code>内核的驱动中取消了这一个节点属性换成其他名字的了，于是又去<code>4.19</code>的文档看了一下，也是没有<code>disable</code>的说明，此时心中已经警惕了，感觉就是野火改了驱动。</p><p>查找该驱动的c文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ find -name <span class="string">&quot;*.c&quot;</span> -<span class="built_in">exec</span> grep -n <span class="string">&quot;rockchip,rk3568-pcie&quot;</span> &#123;&#125; +</span><br><span class="line">./drivers/phy/rockchip/phy-rockchip-snps-pcie3.c:262:&#123; .compatible = <span class="string">&quot;rockchip,rk3568-pcie3-phy&quot;</span>, .data = &amp;rk3568_ops &#125;,</span><br><span class="line">./drivers/pci/controller/dwc/pcie-dw-rockchip.c:1324:.compatible = <span class="string">&quot;rockchip,rk3568-pcie&quot;</span>,</span><br><span class="line">./drivers/pci/controller/dwc/pcie-dw-rockchip.c:1328:.compatible = <span class="string">&quot;rockchip,rk3568-pcie-ep&quot;</span>,</span><br></pre></td></tr></table></figure><p>锁定<code>./drivers/pci/controller/dwc/pcie-dw-rockchip.c</code>文件，进去一看，果然…:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rk_pcie_resource_get</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev,</span></span><br><span class="line"><span class="params"> <span class="keyword">struct</span> rk_pcie *rk_pcie)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">rk_pcie-&gt;dis_gpio = devm_gpiod_get_optional(&amp;pdev-&gt;dev, <span class="string">&quot;disable&quot;</span>,</span><br><span class="line">    GPIOD_OUT_LOW);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(rk_pcie-&gt;dis_gpio)) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;invalid disable-gpios property in node\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(rk_pcie-&gt;rst_gpio);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码块中的内容是野火增加的<code>disable</code>引脚资源获取，在官方的驱动里面是并没有这一部分的，所以增加如下内容：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">diff --git a/drivers/pci/controller/dwc/pcie-dw-rockchip.c b/drivers/pci/controller/dwc/pcie-dw-rockchip.c</span><br><span class="line">index fa40f51..<span class="number">3</span>c6cd4f <span class="number">100755</span></span><br><span class="line">--- a/drivers/pci/controller/dwc/pcie-dw-rockchip.c</span><br><span class="line">+++ b/drivers/pci/controller/dwc/pcie-dw-rockchip.c</span><br><span class="line">@@ <span class="number">-133</span>,<span class="number">6</span> +<span class="number">133</span>,<span class="number">7</span> @@ <span class="class"><span class="keyword">struct</span> <span class="title">rk_pcie</span> &#123;</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span>clk_cnt;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">reset_bulk_data</span>*<span class="title">rsts</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span>*<span class="title">rst_gpio</span>;</span></span><br><span class="line">+<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span>*<span class="title">dis_gpio</span>;</span></span><br><span class="line"> <span class="type">phys_addr_t</span>mem_start;</span><br><span class="line"> <span class="type">size_t</span>mem_size;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">pcie_port</span><span class="title">pp</span>;</span></span><br><span class="line">@@ <span class="number">-892</span>,<span class="number">6</span> +<span class="number">893</span>,<span class="number">11</span> @@ <span class="type">static</span> <span class="type">int</span> <span class="title function_">rk_pcie_host_init</span><span class="params">(<span class="keyword">struct</span> pcie_port *pp)</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">dw_pcie</span> *<span class="title">pci</span> =</span> to_dw_pcie_from_pp(pp);</span><br><span class="line">+<span class="class"><span class="keyword">struct</span> <span class="title">rk_pcie</span> *<span class="title">rk_pcie</span> =</span> to_rk_pcie(pci);</span><br><span class="line">+        </span><br><span class="line">+<span class="keyword">if</span> (!IS_ERR(rk_pcie-&gt;dis_gpio)) &#123;</span><br><span class="line">+gpiod_set_value_cansleep(rk_pcie-&gt;dis_gpio, <span class="number">1</span>);</span><br><span class="line">+        &#125;</span><br><span class="line"> </span><br><span class="line"> dw_pcie_setup_rc(pp);</span><br><span class="line"> </span><br><span class="line">@@ <span class="number">-1066</span>,<span class="number">6</span> +<span class="number">1072</span>,<span class="number">13</span> @@ <span class="type">static</span> <span class="type">int</span> <span class="title function_">rk_pcie_resource_get</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev,</span></span><br><span class="line"><span class="params"> dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;invalid reset-gpios property in node\n&quot;</span>);</span></span><br><span class="line"><span class="params"> <span class="keyword">return</span> PTR_ERR(rk_pcie-&gt;rst_gpio);</span></span><br><span class="line"><span class="params"> &#125;</span></span><br><span class="line"><span class="params">+</span></span><br><span class="line"><span class="params">+rk_pcie-&gt;dis_gpio = devm_gpiod_get_optional(&amp;pdev-&gt;dev, <span class="string">&quot;disable&quot;</span>,</span></span><br><span class="line"><span class="params">+    GPIOD_OUT_LOW);</span></span><br><span class="line"><span class="params">+<span class="keyword">if</span> (IS_ERR(rk_pcie-&gt;dis_gpio)) &#123;</span></span><br><span class="line"><span class="params">+dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;invalid disable-gpios property in node\n&quot;</span>);</span></span><br><span class="line"><span class="params">+<span class="keyword">return</span> PTR_ERR(rk_pcie-&gt;rst_gpio);</span></span><br><span class="line"><span class="params">+&#125;</span></span><br><span class="line"><span class="params"> </span></span><br><span class="line"><span class="params"> <span class="keyword">return</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="params"> &#125;</span></span><br><span class="line"><span class="params">-- </span></span><br><span class="line"><span class="params"><span class="number">2.34</span>.<span class="number">1</span></span></span><br></pre></td></tr></table></figure><p>重新编译烧录内核，一切正常：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rfkill list                                                                  </span></span><br><span class="line">0: hci0: bluetooth</span><br><span class="line">        Soft blocked: no</span><br><span class="line">        Hard blocked: no</span><br><span class="line">1: phy0: wlan</span><br><span class="line">        Soft blocked: no</span><br><span class="line">        Hard blocked: no</span><br></pre></td></tr></table></figure><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://wireless.wiki.kernel.org/en/users/Drivers/iwlwifi">https://wireless.wiki.kernel.org/en/users/Drivers/iwlwifi</a><br><a href="https://www.kernel.org/doc/html/v4.14/driver-api/firmware/built-in-fw.html">https://www.kernel.org/doc/html/v4.14/driver-api/firmware/built-in-fw.html</a><br><a href="https://wiki.gentoo.org/wiki/">https://wiki.gentoo.org/wiki/</a></p>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
          <category> rockchip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> openHarmony </tag>
            
            <tag> kernel </tag>
            
            <tag> rk3568 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu22.04 自带输入法卡死问题</title>
      <link href="/2024/08/19/Ubuntu22-04-%E8%87%AA%E5%B8%A6%E8%BE%93%E5%85%A5%E6%B3%95%E5%8D%A1%E6%AD%BB%E9%97%AE%E9%A2%98/"/>
      <url>/2024/08/19/Ubuntu22-04-%E8%87%AA%E5%B8%A6%E8%BE%93%E5%85%A5%E6%B3%95%E5%8D%A1%E6%AD%BB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/libpinyin/ibus-libpinyin/issues/308">https://github.com/libpinyin/ibus-libpinyin/issues/308</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu安装hdc工具</title>
      <link href="/2024/08/19/ubuntu%E5%AE%89%E8%A3%85hdc%E5%B7%A5%E5%85%B7/"/>
      <url>/2024/08/19/ubuntu%E5%AE%89%E8%A3%85hdc%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>首先打开链接：<a href="https://ci.openharmony.cn/workbench/cicd/dailybuild/dailylist">https://ci.openharmony.cn/workbench/cicd/dailybuild/dailylist</a></p><p>选择你的openharmony版本，找到对应的系统， 是standard还是Small根据需要选择。</p><p>之后选择下载全量包，打开全量包压缩包后可在toolchains中看到hdc，需要注意的是，toolchains整个文件夹都需要解压出来，因为so文件的原因，不能单独执行hdc。</p><p>解压完成后添加到~&#x2F;.bashrc中的PATH变量即可。</p><p><strong>Ref：</strong></p><p><a href="https://docs.openharmony.cn/pages/v4.1/zh-cn/device-dev/subsystems/subsys-toolchain-hdc-guide.md">https://docs.openharmony.cn/pages/v4.1/zh-cn/device-dev/subsystems/subsys-toolchain-hdc-guide.md</a><br><a href="https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/dfx/hdc.md">https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/dfx/hdc.md</a><br><a href="https://developer.huawei.com/consumer/cn/blog/topic/03137966529669104">https://developer.huawei.com/consumer/cn/blog/topic/03137966529669104</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> linux </tag>
            
            <tag> openHarmony </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rk3568移植openHarmony v3.2.3---系统移植</title>
      <link href="/2024/08/16/rk3568%E7%A7%BB%E6%A4%8DopenHarmony-v3-2-3-%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/"/>
      <url>/2024/08/16/rk3568%E7%A7%BB%E6%A4%8DopenHarmony-v3-2-3-%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="修改build-kernel-sh脚本"><a href="#修改build-kernel-sh脚本" class="headerlink" title="修改build_kernel.sh脚本"></a>修改build_kernel.sh脚本</h2><ul><li>KERNEL_PATCH增加2个，增加了板级patch和jl2101的patch</li><li>增加CONFIG_PATCH对config文件打补丁</li><li>增加拷贝设备树到内核临时目录</li><li>修改了传递给<code>make-ohos.sh</code>脚本的参数</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ git diff build_kernel.sh</span><br><span class="line">diff --git a/rk3568/kernel/build_kernel.sh b/rk3568/kernel/build_kernel.sh</span><br><span class="line">index 4bd1e65..c205e0b 100755</span><br><span class="line">--- a/rk3568/kernel/build_kernel.sh</span><br><span class="line">+++ b/rk3568/kernel/build_kernel.sh</span><br><span class="line">@@ -23,12 +23,17 @@ <span class="built_in">export</span> DEVICE_NAME=<span class="variable">$&#123;7&#125;</span></span><br><span class="line"> <span class="built_in">export</span> PRODUCT_COMPANY=<span class="variable">$&#123;8&#125;</span></span><br><span class="line"> ENABLE_LTO_O0=<span class="variable">$&#123;9&#125;</span></span><br><span class="line"> </span><br><span class="line">+YOUR_BOARD_NAME=your_board_name</span><br><span class="line">+</span><br><span class="line"> KERNEL_SRC_TMP_PATH=<span class="variable">$&#123;ROOT_DIR&#125;</span>/out/kernel/src_tmp/linux-5.10</span><br><span class="line"> KERNEL_OBJ_TMP_PATH=<span class="variable">$&#123;ROOT_DIR&#125;</span>/out/kernel/OBJ/linux-5.10</span><br><span class="line"> KERNEL_SOURCE=<span class="variable">$&#123;ROOT_DIR&#125;</span>/kernel/linux/linux-5.10</span><br><span class="line"> KERNEL_PATCH_PATH=<span class="variable">$&#123;ROOT_DIR&#125;</span>/kernel/linux/patches/linux-5.10</span><br><span class="line">-KERNEL_PATCH=<span class="variable">$&#123;ROOT_DIR&#125;</span>/kernel/linux/patches/linux-5.10/rk3568_patch/kernel.patch</span><br><span class="line">+KERNEL_PATCHES=<span class="string">&quot;<span class="variable">$&#123;ROOT_DIR&#125;</span>/kernel/linux/patches/linux-5.10/rk3568_patch/kernel.patch</span></span><br><span class="line"><span class="string">+<span class="variable">$&#123;ROOT_DIR&#125;</span>/kernel/linux/patches/linux-5.10/rk3568_patch/<span class="variable">$YOUR_BOARD_NAME</span>.patch</span></span><br><span class="line"><span class="string">+<span class="variable">$&#123;ROOT_DIR&#125;</span>/kernel/linux/patches/linux-5.10/rk3568_patch/add-jl201-drivers.patch&quot;</span></span><br><span class="line"> KERNEL_CONFIG_FILE=<span class="variable">$&#123;ROOT_DIR&#125;</span>/kernel/linux/config/linux-5.10/arch/arm64/configs/rk3568_standard_defconfig</span><br><span class="line">+KERNEL_CONFIG_PATCH=<span class="variable">$&#123;ROOT_DIR&#125;</span>/kernel/linux/patches/linux-5.10/<span class="variable">$&#123;YOUR_BOARD_NAME&#125;</span>_config.patch</span><br><span class="line"> NEWIP_PATCH_FILE=<span class="variable">$&#123;ROOT_DIR&#125;</span>/foundation/communication/sfc/newip/apply_newip.sh</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">rm</span> -rf <span class="variable">$&#123;KERNEL_SRC_TMP_PATH&#125;</span></span><br><span class="line">@@ -46,17 +51,27 @@ <span class="built_in">cd</span> <span class="variable">$&#123;KERNEL_SRC_TMP_PATH&#125;</span></span><br><span class="line"> bash <span class="variable">$&#123;ROOT_DIR&#125;</span>/drivers/hdf_core/adapter/khdf/linux/patch_hdf.sh <span class="variable">$&#123;ROOT_DIR&#125;</span> <span class="variable">$&#123;KERNEL_SRC_TMP_PATH&#125;</span> <span class="variable">$&#123;KERNEL_PATCH_PATH&#125;</span> <span class="variable">$&#123;DEVICE_NAME&#125;</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">#kernel patch</span></span><br><span class="line">-patch -p1 &lt; <span class="variable">$&#123;KERNEL_PATCH&#125;</span></span><br><span class="line">+<span class="keyword">for</span> KERNEL_PATCH <span class="keyword">in</span> <span class="variable">$KERNEL_PATCHES</span></span><br><span class="line">+<span class="keyword">do</span></span><br><span class="line">+    patch -p1 &lt; <span class="variable">$&#123;KERNEL_PATCH&#125;</span></span><br><span class="line">+<span class="keyword">done</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">#newip</span></span><br><span class="line"> <span class="keyword">if</span> [ -f <span class="variable">$NEWIP_PATCH_FILE</span> ]; <span class="keyword">then</span></span><br><span class="line"> bash <span class="variable">$NEWIP_PATCH_FILE</span> <span class="variable">$&#123;ROOT_DIR&#125;</span> <span class="variable">$&#123;KERNEL_SRC_TMP_PATH&#125;</span> <span class="variable">$&#123;DEVICE_NAME&#125;</span> linux-5.10</span><br><span class="line"> <span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line">+#kernel dts</span><br><span class="line">+<span class="built_in">cp</span> -rf <span class="variable">$&#123;3&#125;</span>/kernel/dts/*.dts* <span class="variable">$&#123;KERNEL_SRC_TMP_PATH&#125;</span>/arch/arm64/boot/dts/rockchip/</span><br><span class="line">+# jl2101 driver</span><br><span class="line">+<span class="built_in">cp</span> -rf <span class="variable">$&#123;3&#125;</span>/kernel/JL201/jlsemi* <span class="variable">$&#123;KERNEL_SRC_TMP_PATH&#125;</span>/drivers/net/phy/</span><br><span class="line">+</span><br><span class="line"> <span class="built_in">cp</span> -rf <span class="variable">$&#123;3&#125;</span>/kernel/logo* <span class="variable">$&#123;KERNEL_SRC_TMP_PATH&#125;</span>/</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#config</span></span><br><span class="line"> <span class="built_in">cp</span> -rf <span class="variable">$&#123;KERNEL_CONFIG_FILE&#125;</span> <span class="variable">$&#123;KERNEL_SRC_TMP_PATH&#125;</span>/arch/arm64/configs/rockchip_linux_defconfig</span><br><span class="line">+#config patch</span><br><span class="line">+#patch -p1 &lt; <span class="variable">$&#123;CONFIG_PATCH&#125;</span></span><br><span class="line"> </span><br><span class="line"> ramdisk_arg=<span class="string">&quot;disable_ramdisk&quot;</span></span><br><span class="line"> make_ohos_env=<span class="string">&quot;GPUDRIVER=mali&quot;</span></span><br><span class="line">@@ -72,7 +87,7 @@ <span class="keyword">do</span></span><br><span class="line"> ;;</span><br><span class="line"> <span class="keyword">esac</span></span><br><span class="line"> <span class="keyword">done</span></span><br><span class="line">-<span class="built_in">eval</span> <span class="variable">$make_ohos_env</span> ./make-ohos.sh TB-RK3568X0 <span class="variable">$ramdisk_arg</span> <span class="variable">$&#123;ENABLE_LTO_O0&#125;</span></span><br><span class="line">+<span class="built_in">eval</span> <span class="variable">$make_ohos_env</span> ./make-ohos.sh <span class="variable">$YOUR_BOARD_NAME</span> <span class="variable">$ramdisk_arg</span> <span class="variable">$&#123;ENABLE_LTO_O0&#125;</span></span><br><span class="line"> </span><br><span class="line"> <span class="built_in">mkdir</span> -p <span class="variable">$&#123;2&#125;</span></span><br></pre></td></tr></table></figure><h2 id="内核补丁准备工作"><a href="#内核补丁准备工作" class="headerlink" title="内核补丁准备工作"></a>内核补丁准备工作</h2><p>首先编写<code>Makefile</code>实现自动化复制内核，打补丁的操作：</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Linux内核目录</span></span><br><span class="line">KERNEL_SRC_TMP_PATH := &lt;绝对路径&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># OpenHarmony目录相关变量</span></span><br><span class="line">OHOS_BUILD_HOME := &lt;绝对路径&gt;</span><br><span class="line">DEVICE_NAME := rk3568</span><br><span class="line">KERNEL_VERSION := linux-5.10</span><br><span class="line">KERNEL_SRC_PATH := <span class="variable">$(OHOS_BUILD_HOME)</span>/kernel/linux/$&#123;KERNEL_VERSION&#125;</span><br><span class="line">DEVICE_PATCH_DIR := <span class="variable">$(OHOS_BUILD_HOME)</span>/kernel/linux/patches/$&#123;KERNEL_VERSION&#125;/<span class="variable">$(DEVICE_NAME)</span>_patch</span><br><span class="line">DEVICE_PATCH_FILE := <span class="variable">$(DEVICE_PATCH_DIR)</span>/kernel.patch</span><br><span class="line">HDF_PATCH_FILE := <span class="variable">$(DEVICE_PATCH_DIR)</span>/hdf.patch</span><br><span class="line">KERNEL_PATCH_PATH := <span class="variable">$(OHOS_BUILD_HOME)</span>/kernel/linux/patches/$&#123;KERNEL_VERSION&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all clean copy_kernel copy_device</span></span><br><span class="line"><span class="section">copy_kernel:</span></span><br><span class="line">rm -rf <span class="variable">$(KERNEL_SRC_TMP_PATH)</span>;mkdir -p <span class="variable">$(KERNEL_SRC_TMP_PATH)</span>;cp -arfL <span class="variable">$(KERNEL_SRC_PATH)</span>/* <span class="variable">$(KERNEL_SRC_TMP_PATH)</span></span><br><span class="line">    cp <span class="variable">$(OHOS_BUILD_HOME)</span>/kernel/linux/config/$&#123;KERNEL_VERSION&#125;/arch/arm64/configs/rk3568_standard_defconfig <span class="variable">$(KERNEL_SRC_TMP_PATH)</span>/arch/arm64/configs/rockchip_linux_defconfig</span><br><span class="line"></span><br><span class="line"><span class="section">put_hdf_patch:</span></span><br><span class="line">cd <span class="variable">$(KERNEL_SRC_TMP_PATH)</span> &amp;&amp; patch -p1 &lt; $&#123;HDF_PATCH_FILE&#125;</span><br><span class="line"><span class="section">ln_hdf_repos:</span></span><br><span class="line">cd <span class="variable">$(KERNEL_SRC_TMP_PATH)</span> &amp;&amp; ln -sf $&#123;OHOS_BUILD_HOME&#125;/drivers/hdf_core/adapter/khdf/linux    drivers/hdf/khdf</span><br><span class="line">cd <span class="variable">$(KERNEL_SRC_TMP_PATH)</span> &amp;&amp; ln -sf $&#123;OHOS_BUILD_HOME&#125;/drivers/hdf_core/framework             drivers/hdf/framework</span><br><span class="line">cd <span class="variable">$(KERNEL_SRC_TMP_PATH)</span> &amp;&amp; ln -sf $&#123;OHOS_BUILD_HOME&#125;/drivers/hdf_core/framework/<span class="keyword">include</span>     <span class="keyword">include</span>/hdf</span><br><span class="line"><span class="section">copy_external_compents:</span></span><br><span class="line">cd <span class="variable">$(KERNEL_SRC_TMP_PATH)</span> &amp;&amp; cp -arfL $&#123;OHOS_BUILD_HOME&#125;/third_party/bounds_checking_function  ./</span><br><span class="line">cd <span class="variable">$(KERNEL_SRC_TMP_PATH)</span> &amp;&amp; mkdir -p drivers/hdf/</span><br><span class="line">cd <span class="variable">$(KERNEL_SRC_TMP_PATH)</span> &amp;&amp; cp -arfL $&#123;OHOS_BUILD_HOME&#125;/device/soc/hisilicon/common/platform/wifi         drivers/hdf/</span><br><span class="line">cd <span class="variable">$(KERNEL_SRC_TMP_PATH)</span> &amp;&amp; cp -arfL $&#123;OHOS_BUILD_HOME&#125;/third_party/FreeBSD/sys/dev/evdev     drivers/hdf/</span><br><span class="line">    </span><br><span class="line"><span class="section">patch_hdf_all:</span></span><br><span class="line"><span class="variable">$(OHOS_BUILD_HOME)</span>/drivers/hdf_core/adapter/khdf/linux/patch_hdf.sh <span class="variable">$(OHOS_BUILD_HOME)</span> <span class="variable">$(KERNEL_SRC_TMP_PATH)</span> <span class="variable">$(KERNEL_PATCH_PATH)</span> <span class="variable">$(DEVICE_NAME)</span></span><br><span class="line"><span class="comment">#make put_hdf_patch</span></span><br><span class="line"><span class="comment">#make ln_hdf_repos</span></span><br><span class="line"><span class="comment">#make copy_external_compentsls</span></span><br><span class="line"></span><br><span class="line"><span class="section">patch_kernel:</span></span><br><span class="line">cd <span class="variable">$(KERNEL_SRC_TMP_PATH)</span> &amp;&amp; patch -p1 &lt; <span class="variable">$(DEVICE_PATCH_FILE)</span></span><br><span class="line"><span class="section">copy_config:</span></span><br><span class="line">cp -rf <span class="variable">$(KERNEL_CONFIG_PATH)</span>/. <span class="variable">$(KERNEL_SRC_TMP_PATH)</span>/</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">make clean</span><br><span class="line">make copy_kernel</span><br><span class="line">make patch_hdf_all</span><br><span class="line">make patch_kernel</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf <span class="variable">$(KERNEL_SRC_TMP_PATH)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>依次执行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make copy_kernel</span><br><span class="line">make patch_kernel</span><br><span class="line">find ./* -name <span class="string">&quot;*.orig&quot;</span> | xargs <span class="built_in">rm</span> -rf</span><br><span class="line">make patch_hdf</span><br><span class="line"></span><br><span class="line">创建设备树目录并将已经适配好`Linux`系统的设备树文件拷贝进来(这一步是为了`build_kernel.sh`将此文件夹中的设备树拷贝到内核临时目录的设备树文件夹中)：</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"><span class="built_in">mkdir</span> -p device/board/hihope/rk3568/kernel/dts</span><br><span class="line"><span class="built_in">cp</span> rk3568-xxx.dts device/board/hihope/rk3568/kernel/dts</span><br></pre></td></tr></table></figure><p>创建git仓库并且提交：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init &amp;&amp; git add -A &amp;&amp; git commit -m <span class="string">&quot;First&quot;</span></span><br></pre></td></tr></table></figure><h2 id="增加内核补丁"><a href="#增加内核补丁" class="headerlink" title="增加内核补丁"></a>增加内核补丁</h2><p>进入内核临时目录后修改<code>make-ohos.h</code>：<br>    - 修改了DTB变量<br>    - 修改了model_list</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">diff --git a/make-ohos.sh b/make-ohos.sh</span><br><span class="line">index 4dc437165..704e8c78f 100755</span><br><span class="line">--- a/make-ohos.sh</span><br><span class="line">+++ b/make-ohos.sh</span><br><span class="line">@@ -14,7 +14,7 @@ MAKE=<span class="string">&quot;make LLVM=1 LLVM_IAS=1 CROSS_COMPILE=../../../../prebuilts/gcc/linux-x86/a</span></span><br><span class="line"><span class="string"> BUILD_PATH=boot_linux</span></span><br><span class="line"><span class="string"> EXTLINUX_PATH=<span class="variable">$&#123;BUILD_PATH&#125;</span>/extlinux</span></span><br><span class="line"><span class="string"> EXTLINUX_CONF=<span class="variable">$&#123;EXTLINUX_PATH&#125;</span>/extlinux.conf</span></span><br><span class="line"><span class="string">-TOYBRICK_DTB=toybrick.dtb</span></span><br><span class="line"><span class="string">+YOUR_BOARD_NAME_DTB=rk3568-your_board_name.dtb</span></span><br><span class="line"><span class="string"> if [ <span class="variable">$&#123;KBUILD_OUTPUT&#125;</span> ]; then</span></span><br><span class="line"><span class="string"> OBJ_PATH=<span class="variable">$&#123;KBUILD_OUTPUT&#125;</span>/</span></span><br><span class="line"><span class="string"> fi</span></span><br><span class="line"><span class="string">@@ -26,8 +26,7 @@ ID_DTB=4</span></span><br><span class="line"><span class="string"> ID_IMAGE=5</span></span><br><span class="line"><span class="string"> ID_CONF=6</span></span><br><span class="line"><span class="string"> model_list=(</span></span><br><span class="line"><span class="string">-&quot;</span>TB-RK3568X0   arm64 0xfe660000 rk3568-toybrick-x0-linux  Image rockchip_linux_defconfig<span class="string">&quot;</span></span><br><span class="line"><span class="string">-&quot;</span>TB-RK3568X10  arm64 0xfe660000 rk3568-toybrick-x10-linux Image rockchip_linux_defconfig<span class="string">&quot;</span></span><br><span class="line"><span class="string">+&quot;</span>your_board_name   arm64 0xfe660000 rk3568-your_board_name  Image rockchip_linux_defconfig<span class="string">&quot;</span></span><br><span class="line"><span class="string"> )</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">@@ -49,7 +48,7 @@ function make_extlinux_conf()</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> echo &quot;</span>label rockchip-kernel-5.10<span class="string">&quot; &gt; <span class="variable">$&#123;EXTLINUX_CONF&#125;</span></span></span><br><span class="line"><span class="string"> echo &quot;</span>kernel /extlinux/<span class="variable">$&#123;image&#125;</span><span class="string">&quot; &gt;&gt; <span class="variable">$&#123;EXTLINUX_CONF&#125;</span></span></span><br><span class="line"><span class="string">-echo &quot;</span>fdt /extlinux/<span class="variable">$&#123;TOYBRICK_DTB&#125;</span><span class="string">&quot; &gt;&gt; <span class="variable">$&#123;EXTLINUX_CONF&#125;</span></span></span><br><span class="line"><span class="string">+echo &quot;</span>fdt /extlinux/<span class="variable">$&#123;YOUR_BOARD_NAME_DTB&#125;</span><span class="string">&quot; &gt;&gt; <span class="variable">$&#123;EXTLINUX_CONF&#125;</span></span></span><br><span class="line"><span class="string"> cmdline=&quot;</span>append earlycon=uart8250,mmio32,<span class="variable">$&#123;uart&#125;</span> root=PARTUUID=614e0000-0000-4b53-8000-1d28000054a9 rw rootwait rootfstype=ext4<span class="string">&quot;</span></span><br><span class="line"><span class="string"> echo &quot;</span>  <span class="variable">$&#123;cmdline&#125;</span><span class="string">&quot; &gt;&gt; <span class="variable">$&#123;EXTLINUX_CONF&#125;</span></span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string">@@ -118,7 +117,7 @@ function make_boot_linux()</span></span><br><span class="line"><span class="string"> fi</span></span><br><span class="line"><span class="string"> make_extlinux_conf <span class="variable">$&#123;dtb_path&#125;</span> <span class="variable">$&#123;uart&#125;</span> <span class="variable">$&#123;image&#125;</span></span></span><br><span class="line"><span class="string"> cp -f <span class="variable">$&#123;OBJ_PATH&#125;</span>arch/<span class="variable">$&#123;arch&#125;</span>/boot/<span class="variable">$&#123;image&#125;</span> <span class="variable">$&#123;EXTLINUX_PATH&#125;</span>/</span></span><br><span class="line"><span class="string">-cp -f <span class="variable">$&#123;OBJ_PATH&#125;</span><span class="variable">$&#123;dtb_path&#125;</span>/<span class="variable">$&#123;dtb&#125;</span>.dtb <span class="variable">$&#123;EXTLINUX_PATH&#125;</span>/<span class="variable">$&#123;TOYBRICK_DTB&#125;</span></span></span><br><span class="line"><span class="string">+cp -f <span class="variable">$&#123;OBJ_PATH&#125;</span><span class="variable">$&#123;dtb_path&#125;</span>/<span class="variable">$&#123;dtb&#125;</span>.dtb <span class="variable">$&#123;EXTLINUX_PATH&#125;</span>/<span class="variable">$&#123;YOUR_BOARD_NAME_DTB&#125;</span></span></span><br><span class="line"><span class="string"> cp -f logo*.bmp <span class="variable">$&#123;BUILD_PATH&#125;</span>/</span></span><br><span class="line"><span class="string"> if [ &quot;</span>enable_ramdisk<span class="string">&quot; != &quot;</span><span class="variable">$&#123;ramdisk_flag&#125;</span><span class="string">&quot; ]; then</span></span><br><span class="line"><span class="string"> make_ext2_image</span></span><br></pre></td></tr></table></figure><p>修改<code>arch/arm64/boot/dts/rockchip/Makefile</code>加入你的板子。</p><p>执行以下命令提交：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add -A &amp;&amp; git commit -m <span class="string">&quot;something you like&quot;</span></span><br></pre></td></tr></table></figure><p>执行以下命令生成patch:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git format-patch --subject-prefix=<span class="string">&#x27;PATCH&#x27;</span> -n -s -1</span><br></pre></td></tr></table></figure><p>将这个<code>patch</code>移动到<code>kernel/linux/patches/linux-5.10/rk3568_patch/$YOUR_BOARD_NAME.patch</code>下，<code>YOUR_BOARD_NAME</code>对应你<code>build_kernel.sh</code>中定义的。</p><p>根据自己的需要修改<code>arch/arm64/configs/rockchip_linux_defconfig</code>后提交，随后生成补丁，移动到<code>build_kernel.sh</code>中设置的<code>CONFIG_PATCH_FILE</code>。</p><p>回到主目录，删除<code>out/kernel</code>文件夹后重新编译，即可在<code>out/rk3568/packages/phone/images</code>目录下看到输出文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf out/kernel</span><br><span class="line">./build.sh --product-name rk3568 --ccache</span><br><span class="line"></span><br><span class="line">❯ <span class="built_in">cd</span> out/rk3568/packages/phone/images</span><br><span class="line">❯ <span class="built_in">ls</span></span><br><span class="line">boot_linux.img  config.cfg         parameter.txt  resource.img  system.img  updater.img   vendor.img</span><br><span class="line">chip_prod.img   MiniLoaderAll.bin  ramdisk.img    sys_prod.img  uboot.img   userdata.img</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
          <category> rockchip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openHarmony </tag>
            
            <tag> kernel </tag>
            
            <tag> rk3568 </tag>
            
            <tag> rockchip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rk3568移植openHarmony v3.2.3---编译流程分析</title>
      <link href="/2024/08/16/rk3568%E7%A7%BB%E6%A4%8DopenHarmony-v3-2-3-%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-1/"/>
      <url>/2024/08/16/rk3568%E7%A7%BB%E6%A4%8DopenHarmony-v3-2-3-%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-1/</url>
      
        <content type="html"><![CDATA[<h2 id="目录分析"><a href="#目录分析" class="headerlink" title="目录分析"></a>目录分析</h2><p>在<code>OpenHarmony</code>编译过程中，内核源码是不变的，内核源码保存在<code>kernel/linux/linux-5.10/</code>下，并且永远不被修改。</p><p>在编译内核前，会将内核源码复制到内核临时源码目录<code>out/kernel/src_tmp/linux-5.10/</code>下，然后再以打补丁的方式进行修改。</p><p>在编译命令<code>./build.sh --product-name rk3568 --ccache</code>中，用<code>--product</code>命令指定了<code>rk3568</code>。</p><p>通过查阅文档得知，这个<code>product</code>参数是在<code>vendor</code>文件夹中所指定的。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">❯ vim vendor/hihope/rk3568/config.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;product_name&quot;</span>: <span class="string">&quot;rk3568&quot;</span>,</span><br><span class="line">  <span class="string">&quot;device_company&quot;</span>: <span class="string">&quot;rockchip&quot;</span>,</span><br><span class="line">  <span class="string">&quot;device_build_path&quot;</span>: <span class="string">&quot;device/board/hihope/rk3568&quot;</span>,</span><br><span class="line">  <span class="string">&quot;target_cpu&quot;</span>: <span class="string">&quot;arm&quot;</span>,</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;standard&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;3.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;board&quot;</span>: <span class="string">&quot;rk3568&quot;</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该配置文件中指定了<code>product_name</code>为<code>rk3568</code>的目标的编译路径是<code>device/board/hihope/rk3568</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">cd</span> device/board/hihope/rk3568</span><br><span class="line">❯ <span class="built_in">ls</span></span><br><span class="line">audio_drivers  bootanimation  BUILD.gn  camera  cfg  config.gni  device.gni  distributedhardware  kernel  loader  ohos.build  startup  updater  wifi</span><br></pre></td></tr></table></figure><p>目标的编译路径下面有很多文件，我们关心的是内核移植，所以只需要看<code>kernel</code>文件夹。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">cd</span> kernel &amp;&amp; <span class="built_in">ls</span></span><br><span class="line">BUILD.gn  build_kernel.sh  dts  JL201  logo.bmp  logo_kernel.bmp  ov8858.c</span><br></pre></td></tr></table></figure><p>先从<code>BUILD.gn</code>文件开始看：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">cat</span> BUILD.gn</span><br><span class="line">···</span><br><span class="line">import(<span class="string">&quot;//build/config/clang/clang.gni&quot;</span>)</span><br><span class="line">import(<span class="string">&quot;//build/ohos.gni&quot;</span>)</span><br><span class="line">kernel_build_script_dir = <span class="string">&quot;//kernel/linux/linux-5.10&quot;</span></span><br><span class="line">kernel_source_dir = <span class="string">&quot;//kernel/linux/linux-5.10&quot;</span></span><br><span class="line"></span><br><span class="line">action(<span class="string">&quot;kernel&quot;</span>) &#123;</span><br><span class="line">  script = <span class="string">&quot;build_kernel.sh&quot;</span></span><br><span class="line">  sources = [ kernel_source_dir ]</span><br><span class="line"></span><br><span class="line">  product_path = <span class="string">&quot;vendor/<span class="variable">$product_company</span>/<span class="variable">$product_name</span>&quot;</span></span><br><span class="line">  outputs = [ <span class="string">&quot;<span class="variable">$root_build_dir</span>/../kernel/src_tmp/linux-5.10/boot_linux&quot;</span> ]</span><br><span class="line">  args = [</span><br><span class="line">    rebase_path(kernel_build_script_dir, root_build_dir),</span><br><span class="line">    rebase_path(<span class="string">&quot;<span class="variable">$root_build_dir</span>/packages/phone/images&quot;</span>),</span><br><span class="line">    rebase_path(<span class="string">&quot;//device/board/hihope/<span class="variable">$device_name</span>&quot;</span>),</span><br><span class="line">    product_path,</span><br><span class="line">    rebase_path(<span class="string">&quot;<span class="variable">$root_build_dir</span>/../..&quot;</span>),</span><br><span class="line">    device_company,</span><br><span class="line">    device_name,</span><br><span class="line">    product_company,</span><br><span class="line">  ]</span><br><span class="line">···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到当构建流执行到这里的时候会直接执行<code>build_kernel.sh</code>这个脚本，并且传入一些参数。</p><h2 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h2><p>查看<code>build_kernel.sh</code>这个脚本：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="built_in">pushd</span> <span class="variable">$&#123;1&#125;</span></span><br><span class="line">ROOT_DIR=<span class="variable">$&#123;5&#125;</span></span><br><span class="line"><span class="built_in">export</span> PRODUCT_PATH=<span class="variable">$&#123;4&#125;</span></span><br><span class="line"><span class="built_in">export</span> DEVICE_COMPANY=<span class="variable">$&#123;6&#125;</span></span><br><span class="line"><span class="built_in">export</span> DEVICE_NAME=<span class="variable">$&#123;7&#125;</span></span><br><span class="line"><span class="built_in">export</span> PRODUCT_COMPANY=<span class="variable">$&#123;8&#125;</span></span><br><span class="line">ENABLE_LTO_O0=<span class="variable">$&#123;9&#125;</span></span><br><span class="line"></span><br><span class="line">KERNEL_SRC_TMP_PATH=<span class="variable">$&#123;ROOT_DIR&#125;</span>/out/kernel/src_tmp/linux-5.10</span><br><span class="line">KERNEL_OBJ_TMP_PATH=<span class="variable">$&#123;ROOT_DIR&#125;</span>/out/kernel/OBJ/linux-5.10</span><br><span class="line">KERNEL_SOURCE=<span class="variable">$&#123;ROOT_DIR&#125;</span>/kernel/linux/linux-5.10</span><br><span class="line">KERNEL_PATCH_PATH=<span class="variable">$&#123;ROOT_DIR&#125;</span>/kernel/linux/patches/linux-5.10</span><br><span class="line">KERNEL_PATCH=<span class="variable">$&#123;ROOT_DIR&#125;</span>/kernel/linux/patches/linux-5.10/rk3568_patch/kernel.patch</span><br><span class="line">KERNEL_CONFIG_FILE=<span class="variable">$&#123;ROOT_DIR&#125;</span>/kernel/linux/config/linux-5.10/arch/arm64/configs/rk3568_standard_defconfig</span><br><span class="line">NEWIP_PATCH_FILE=<span class="variable">$&#123;ROOT_DIR&#125;</span>/foundation/communication/sfc/newip/apply_newip.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf <span class="variable">$&#123;KERNEL_SRC_TMP_PATH&#125;</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$&#123;KERNEL_SRC_TMP_PATH&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf <span class="variable">$&#123;KERNEL_OBJ_TMP_PATH&#125;</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$&#123;KERNEL_OBJ_TMP_PATH&#125;</span></span><br><span class="line"><span class="built_in">export</span> KBUILD_OUTPUT=<span class="variable">$&#123;KERNEL_OBJ_TMP_PATH&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> -arf <span class="variable">$&#123;KERNEL_SOURCE&#125;</span>/* <span class="variable">$&#123;KERNEL_SRC_TMP_PATH&#125;</span>/</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;KERNEL_SRC_TMP_PATH&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#HDF patch</span></span><br><span class="line">bash <span class="variable">$&#123;ROOT_DIR&#125;</span>/drivers/hdf_core/adapter/khdf/linux/patch_hdf.sh <span class="variable">$&#123;ROOT_DIR&#125;</span> <span class="variable">$&#123;KERNEL_SRC_TMP_PATH&#125;</span> <span class="variable">$&#123;KERNEL_PATCH_PATH&#125;</span> <span class="variable">$&#123;DEVICE_NAME&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#kernel patch</span></span><br><span class="line">patch -p1 &lt; <span class="variable">$&#123;KERNEL_PATCH&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#newip</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="variable">$NEWIP_PATCH_FILE</span> ]; <span class="keyword">then</span></span><br><span class="line">bash <span class="variable">$NEWIP_PATCH_FILE</span> <span class="variable">$&#123;ROOT_DIR&#125;</span> <span class="variable">$&#123;KERNEL_SRC_TMP_PATH&#125;</span> <span class="variable">$&#123;DEVICE_NAME&#125;</span> linux-5.10</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> -rf <span class="variable">$&#123;3&#125;</span>/kernel/logo* <span class="variable">$&#123;KERNEL_SRC_TMP_PATH&#125;</span>/</span><br><span class="line"></span><br><span class="line"><span class="comment">#config</span></span><br><span class="line"><span class="built_in">cp</span> -rf <span class="variable">$&#123;KERNEL_CONFIG_FILE&#125;</span> <span class="variable">$&#123;KERNEL_SRC_TMP_PATH&#125;</span>/arch/arm64/configs/rockchip_linux_defconfig</span><br><span class="line"></span><br><span class="line">ramdisk_arg=<span class="string">&quot;disable_ramdisk&quot;</span></span><br><span class="line">make_ohos_env=<span class="string">&quot;GPUDRIVER=mali&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span> </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$i</span> <span class="keyword">in</span></span><br><span class="line">enable_ramdisk)</span><br><span class="line">ramdisk_arg=enable_ramdisk</span><br><span class="line">;;</span><br><span class="line">enable_mesa3d)</span><br><span class="line">make_ohos_env=<span class="string">&quot;GPUDRIVER=mesa3d&quot;</span></span><br><span class="line">python <span class="variable">$&#123;ROOT_DIR&#125;</span>/third_party/mesa3d/ohos/modifyDtsi.py <span class="variable">$&#123;KERNEL_SRC_TMP_PATH&#125;</span>/arch/arm64/boot/dts/rockchip/rk3568.dtsi</span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">eval</span> <span class="variable">$make_ohos_env</span> ./make-ohos.sh TB-RK3568X0 <span class="variable">$ramdisk_arg</span> <span class="variable">$&#123;ENABLE_LTO_O0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$&#123;2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;enable_ramdisk&quot;</span> != <span class="string">&quot;<span class="variable">$&#123;10&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$&#123;KERNEL_OBJ_TMP_PATH&#125;</span>/boot_linux.img <span class="variable">$&#123;2&#125;</span>/boot_linux.img</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$&#123;KERNEL_OBJ_TMP_PATH&#125;</span>/resource.img <span class="variable">$&#123;2&#125;</span>/resource.img</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$&#123;3&#125;</span>/loader/parameter.txt <span class="variable">$&#123;2&#125;</span>/parameter.txt</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$&#123;3&#125;</span>/loader/MiniLoaderAll.bin <span class="variable">$&#123;2&#125;</span>/MiniLoaderAll.bin</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$&#123;3&#125;</span>/loader/uboot.img <span class="variable">$&#123;2&#125;</span>/uboot.img</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$&#123;3&#125;</span>/loader/config.cfg <span class="variable">$&#123;2&#125;</span>/config.cfg</span><br><span class="line"><span class="built_in">popd</span></span><br><span class="line"></span><br><span class="line">../kernel/src_tmp/linux-5.10/make-boot.sh ..</span><br></pre></td></tr></table></figure><h3 id="变量解释"><a href="#变量解释" class="headerlink" title="变量解释"></a>变量解释</h3><pre><code>- KERNEL_SRC_TMP_PATH: 源码临时路径，在编译流程中，内核的原源码是不变的，需要将内核源码复制到这个路径下，然后对这个路径下的内核源码进行打补丁。- KERNEL_OBJ_TMP_PATH: 目标临时路径。- KERNEL_SOURCE: 内核原源码路径- KERNEL_PATCH_PATH: 内核补丁路径- KERNEL_PATCH: 内核补丁文件- KERNEL_CONFIG_FILE: 内核配置文件- NEWIP_PATCH_FILE: newip补丁文件</code></pre><h3 id="脚本解释"><a href="#脚本解释" class="headerlink" title="脚本解释"></a>脚本解释</h3><p>将内核源码复制到内核临时源码目录并且进入：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf <span class="variable">$&#123;KERNEL_SRC_TMP_PATH&#125;</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$&#123;KERNEL_SRC_TMP_PATH&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf <span class="variable">$&#123;KERNEL_OBJ_TMP_PATH&#125;</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$&#123;KERNEL_OBJ_TMP_PATH&#125;</span></span><br><span class="line"><span class="built_in">export</span> KBUILD_OUTPUT=<span class="variable">$&#123;KERNEL_OBJ_TMP_PATH&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> -arf <span class="variable">$&#123;KERNEL_SOURCE&#125;</span>/* <span class="variable">$&#123;KERNEL_SRC_TMP_PATH&#125;</span>/</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;KERNEL_SRC_TMP_PATH&#125;</span></span><br></pre></td></tr></table></figure><p>对内核源码进行打补丁：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#HDF patch</span></span><br><span class="line">bash <span class="variable">$&#123;ROOT_DIR&#125;</span>/drivers/hdf_core/adapter/khdf/linux/patch_hdf.sh <span class="variable">$&#123;ROOT_DIR&#125;</span> <span class="variable">$&#123;KERNEL_SRC_TMP_PATH&#125;</span> <span class="variable">$&#123;KERNEL_PATCH_PATH&#125;</span> <span class="variable">$&#123;DEVICE_NAME&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#kernel patch</span></span><br><span class="line">patch -p1 &lt; <span class="variable">$&#123;KERNEL_PATCH&#125;</span></span><br></pre></td></tr></table></figure><p>其中HDF的补丁调用到了<code>drivers/hdf_core/adapter/khdf/linux/patch_hdf.sh</code>这个脚本，脚本参数如下：<br>    - OH工程根目录，绝对路径<br>    - 内核临时目录，绝对路径<br>    - 内核补丁路径，绝对路径<br>    - 设备名称</p><p><code>patch_hdf.sh</code>脚本对于补丁的搜索：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">put_hdf_patch</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    HDF_PATCH_FILE=<span class="variable">$&#123;KERNEL_PATCH_PATH&#125;</span>/<span class="variable">$&#123;DEVICE_NAME&#125;</span>_patch/hdf.patch</span><br><span class="line">    <span class="keyword">if</span> [ ! -e <span class="string">&quot;<span class="variable">$&#123;HDF_PATCH_FILE&#125;</span>&quot;</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">    HDF_PATCH_FILE=<span class="variable">$&#123;KERNEL_PATCH_PATH&#125;</span>/<span class="variable">$&#123;HDF_COMMON_PATCH&#125;</span>_patch/hdf.patch</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    patch -p1 &lt; <span class="variable">$HDF_PATCH_FILE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到此脚本是根据补丁路径+设备名称找到<code>hdf.patch</code>这个补丁。</p><p>拷贝开机logo和配置文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> -rf <span class="variable">$&#123;3&#125;</span>/kernel/logo* <span class="variable">$&#123;KERNEL_SRC_TMP_PATH&#125;</span>/</span><br><span class="line"></span><br><span class="line"><span class="comment">#config</span></span><br><span class="line"><span class="built_in">cp</span> -rf <span class="variable">$&#123;KERNEL_CONFIG_FILE&#125;</span> <span class="variable">$&#123;KERNEL_SRC_TMP_PATH&#125;</span>/arch/arm64/configs/rockchip_linux_defconfig</span><br></pre></td></tr></table></figure><p>创建env和执行编译脚本：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ramdisk_arg=<span class="string">&quot;disable_ramdisk&quot;</span></span><br><span class="line">make_ohos_env=<span class="string">&quot;GPUDRIVER=mali&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span> </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$i</span> <span class="keyword">in</span></span><br><span class="line">enable_ramdisk)</span><br><span class="line">ramdisk_arg=enable_ramdisk</span><br><span class="line">;;</span><br><span class="line">enable_mesa3d)</span><br><span class="line">make_ohos_env=<span class="string">&quot;GPUDRIVER=mesa3d&quot;</span></span><br><span class="line">python <span class="variable">$&#123;ROOT_DIR&#125;</span>/third_party/mesa3d/ohos/modifyDtsi.py <span class="variable">$&#123;KERNEL_SRC_TMP_PATH&#125;</span>/arch/arm64/boot/dts/rockchip/rk3568.dtsi</span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">eval</span> <span class="variable">$make_ohos_env</span> ./make-ohos.sh TB-RK3568X0 <span class="variable">$ramdisk_arg</span> <span class="variable">$&#123;ENABLE_LTO_O0&#125;</span></span><br></pre></td></tr></table></figure><p><code>make-ohos.sh</code>脚本在内核临时源码目录，<code>TB-RK3568X0</code>是选择设备树的。</p><p><code>make-ohos.sh</code>脚本中关于设备树如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">···</span><br><span class="line">model_list=(</span><br><span class="line"><span class="string">&quot;TB-RK3568X0   arm64 0xfe660000 rk3568-xxx  Image rockchip_linux_defconfig&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>其中<code>TB-RK3568X0 </code>是设备树目标名字， <code>rk3568-xxx</code>是具体的设备树名字，注意，没有后缀。</p><p>回到<code>build_kernel.sh</code>，创建编译文件目录并且拷贝过去：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># $2 = rebase_path(&quot;$root_build_dir/packages/phone/images&quot;),</span></span><br><span class="line"><span class="comment"># $3 = rebase_path(&quot;//device/board/hihope/$device_name&quot;),</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$&#123;2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;enable_ramdisk&quot;</span> != <span class="string">&quot;<span class="variable">$&#123;10&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$&#123;KERNEL_OBJ_TMP_PATH&#125;</span>/boot_linux.img <span class="variable">$&#123;2&#125;</span>/boot_linux.img</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$&#123;KERNEL_OBJ_TMP_PATH&#125;</span>/resource.img <span class="variable">$&#123;2&#125;</span>/resource.img</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$&#123;3&#125;</span>/loader/parameter.txt <span class="variable">$&#123;2&#125;</span>/parameter.txt</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$&#123;3&#125;</span>/loader/MiniLoaderAll.bin <span class="variable">$&#123;2&#125;</span>/MiniLoaderAll.bin</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$&#123;3&#125;</span>/loader/uboot.img <span class="variable">$&#123;2&#125;</span>/uboot.img</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$&#123;3&#125;</span>/loader/config.cfg <span class="variable">$&#123;2&#125;</span>/config.cfg</span><br><span class="line"><span class="built_in">popd</span></span><br></pre></td></tr></table></figure><p>执行生成<code>boot_linux.img</code>脚本：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">../kernel/src_tmp/linux-5.10/make-boot.sh ..</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
          <category> rockchip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openHarmony </tag>
            
            <tag> kernel </tag>
            
            <tag> rk3568 </tag>
            
            <tag> rockchip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>home-assistant MQTT无法使用高级选项</title>
      <link href="/2024/08/13/home-assistant-MQTT/"/>
      <url>/2024/08/13/home-assistant-MQTT/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/home-assistant/frontend/issues/16886">https://github.com/home-assistant/frontend/issues/16886</a></p>]]></content>
      
      
      <categories>
          
          <category> home-assistant </category>
          
      </categories>
      
      
        <tags>
            
            <tag> home-assistant </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[逆向破解]Oscal Pad70---提取系统分区</title>
      <link href="/2024/08/12/%E9%80%86%E5%90%91%E7%A0%B4%E8%A7%A3-Oscal-Pad70-%E6%8F%90%E5%8F%96%E7%B3%BB%E7%BB%9F%E5%88%86%E5%8C%BA/"/>
      <url>/2024/08/12/%E9%80%86%E5%90%91%E7%A0%B4%E8%A7%A3-Oscal-Pad70-%E6%8F%90%E5%8F%96%E7%B3%BB%E7%BB%9F%E5%88%86%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="Starting"><a href="#Starting" class="headerlink" title="Starting"></a>Starting</h2><p><code>Oscal Pad70</code>实物图：</p><p><img src="https://i.imghippo.com/files/Ct0oQ1723469150.jpg" alt="oscal pad70"></p><p>由官网可知，<code>Oscal Pad70</code>是使用<code>rk3566</code>作为主控：</p><p><img src="https://i.imghippo.com/files/wqrko1723469276.png" alt="oscal pad70 website"></p><p>这台设备并没有关闭<code>adb</code>，使用<code>adb</code>命令可以很轻松的查看到<code>adb</code>的设备。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">Pad70PROL02309200121device</span><br><span class="line"></span><br><span class="line">❯ adb shell</span><br><span class="line">Pad70_Pro:/ $ <span class="built_in">cat</span> /proc/version                                                                              </span><br><span class="line">Linux version 5.10.168-android13-4-00008-g33b1e2eb04dc-ab10159773 (build-user@build-host) (Android (8508608, based on r450784e) clang version 14.0.7 (https://android.googlesource.com/toolchain/llvm-project 4c603efb0cca074e9238af8b4106c30add4418f6), LLD 14.0.7) <span class="comment">#1 SMP PREEMPT Thu May 11 18:17:05 UTC 2023</span></span><br></pre></td></tr></table></figure><p>不出意料的是<code>5.10</code>版本的内核。</p><h2 id="备份分区"><a href="#备份分区" class="headerlink" title="备份分区"></a>备份分区</h2><p>为了防止在后续移植过程中出问题，先备份一下分区。</p><p>使用如下命令查看分区：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Pad70_Pro:/ $ <span class="built_in">ls</span> /dev/block/by-name -l</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 21 2024-08-11 20:21 backup -&gt; /dev/block/mmcblk2p19</span><br><span class="line">lrwxrwxrwx 1 root root 21 2024-08-11 20:21 baseparameter -&gt; /dev/block/mmcblk2p23</span><br><span class="line">lrwxrwxrwx 1 root root 21 2024-08-11 20:21 boot_a -&gt; /dev/block/mmcblk2p17</span><br><span class="line">lrwxrwxrwx 1 root root 21 2024-08-11 20:21 boot_b -&gt; /dev/block/mmcblk2p18</span><br><span class="line">lrwxrwxrwx 1 root root 21 2024-08-11 20:21 cache -&gt; /dev/block/mmcblk2p20</span><br><span class="line">lrwxrwxrwx 1 root root 21 2024-08-11 20:21 dtbo_a -&gt; /dev/block/mmcblk2p13</span><br><span class="line">lrwxrwxrwx 1 root root 21 2024-08-11 20:21 dtbo_b -&gt; /dev/block/mmcblk2p14</span><br><span class="line">lrwxrwxrwx 1 root root 21 2024-08-11 20:21 frp -&gt; /dev/block/mmcblk2p22</span><br><span class="line">lrwxrwxrwx 1 root root 21 2024-08-11 20:21 init_boot_a -&gt; /dev/block/mmcblk2p11</span><br><span class="line">lrwxrwxrwx 1 root root 21 2024-08-11 20:21 init_boot_b -&gt; /dev/block/mmcblk2p12</span><br><span class="line">lrwxrwxrwx 1 root root 21 2024-08-11 20:21 metadata -&gt; /dev/block/mmcblk2p21</span><br><span class="line">lrwxrwxrwx 1 root root 20 2024-08-11 20:21 misc -&gt; /dev/block/mmcblk2p6</span><br><span class="line">lrwxrwxrwx 1 root root 18 2024-08-11 20:21 mmcblk2 -&gt; /dev/block/mmcblk2</span><br><span class="line">lrwxrwxrwx 1 root root 23 2024-08-11 20:21 mmcblk2boot0 -&gt; /dev/block/mmcblk2boot0</span><br><span class="line">lrwxrwxrwx 1 root root 23 2024-08-11 20:21 mmcblk2boot1 -&gt; /dev/block/mmcblk2boot1</span><br><span class="line">lrwxrwxrwx 1 root root 20 2024-08-11 20:21 resource_a -&gt; /dev/block/mmcblk2p7</span><br><span class="line">lrwxrwxrwx 1 root root 20 2024-08-11 20:21 resource_b -&gt; /dev/block/mmcblk2p8</span><br><span class="line">lrwxrwxrwx 1 root root 20 2024-08-11 20:21 security -&gt; /dev/block/mmcblk2p1</span><br><span class="line">lrwxrwxrwx 1 root root 21 2024-08-11 20:21 super -&gt; /dev/block/mmcblk2p24</span><br><span class="line">lrwxrwxrwx 1 root root 20 2024-08-11 20:21 trust_a -&gt; /dev/block/mmcblk2p4</span><br><span class="line">lrwxrwxrwx 1 root root 20 2024-08-11 20:21 trust_b -&gt; /dev/block/mmcblk2p5</span><br><span class="line">lrwxrwxrwx 1 root root 20 2024-08-11 20:21 uboot_a -&gt; /dev/block/mmcblk2p2</span><br><span class="line">lrwxrwxrwx 1 root root 20 2024-08-11 20:21 uboot_b -&gt; /dev/block/mmcblk2p3</span><br><span class="line">lrwxrwxrwx 1 root root 21 2024-08-11 20:21 userdata -&gt; /dev/block/mmcblk2p25</span><br><span class="line">lrwxrwxrwx 1 root root 21 2024-08-11 20:21 vbmeta_a -&gt; /dev/block/mmcblk2p15</span><br><span class="line">lrwxrwxrwx 1 root root 21 2024-08-11 20:21 vbmeta_b -&gt; /dev/block/mmcblk2p16</span><br><span class="line">lrwxrwxrwx 1 root root 20 2024-08-11 20:21 vendor_boot_a -&gt; /dev/block/mmcblk2p9</span><br><span class="line">lrwxrwxrwx 1 root root 21 2024-08-11 20:21 vendor_boot_b -&gt; /dev/block/mmcblk2p10</span><br></pre></td></tr></table></figure><p>可以看到文件超级多，没办法，是个体力活了。</p><p>从系统分区的<code>_a</code>和<code>_b</code>能够看出来，使用的是采用了<code> A/B（双系统）</code>分区结构。这种分区结构常用于安卓设备，以实现无缝系统更新。</p><blockquote><p>双分区： 在 A&#x2F;B 分区结构中，关键的系统分区（如 boot、system、vendor 等）被复制成两份，分别为 A（_a 后缀）和 B（_b 后缀）分区。<br>系统更新： 当有新的系统更新时，系统会将更新写入未使用的分区（例如当前使用 A 分区时会更新 B 分区）。更新完成后，设备会切换到更新后的分区启动。</p></blockquote><p>使用以下命令查看当前正在使用的分区：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Pad70_Pro:/mnt/backup <span class="comment"># getprop ro.boot.slot_suffix</span></span><br><span class="line">_a</span><br></pre></td></tr></table></figure><p>正在使用的分区是<code>_a</code>，所以<code>_b</code>的我们就不用提取了。</p><p>使用如下命令提取分区：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Pad70_Pro:/ <span class="comment"># dd if=/dev/block/mmcblk2p19 of=backup.img                                                        </span></span><br><span class="line"><span class="built_in">dd</span>: backup.img: Read-only file system</span><br><span class="line">0+0 records <span class="keyword">in</span></span><br><span class="line">0+0 records out</span><br><span class="line">0 bytes (0 B) copied, 0.000704 s, 0 B/s</span><br></pre></td></tr></table></figure><p>发现根目录是以只读方式挂载的，所以两种方案：</p><ul><li>重新挂载</li><li>找一个可写的目录</li><li>插入sd卡</li></ul><p>这里偷懒插了一张<code>sd卡</code>，省去很多麻烦：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意这里的6EBE-F0F5可能有所不同</span></span><br><span class="line"><span class="built_in">cd</span> /storage/6EBE-F0F5 &amp;&amp; <span class="built_in">mkdir</span> backup &amp;&amp; <span class="built_in">cd</span> backup</span><br><span class="line"></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/block/mmcblk2p19 of=backup.img   </span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/block/mmcblk2p23 of=baseparameter    </span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/block/mmcblk2p17 of=boot_a.img      </span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/block/mmcblk2p20 of=cache.img    </span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/block/mmcblk2p13 of=dtbo_a.img       </span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/block/mmcblk2p22 of=frp.img</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/block/mmcblk2p11 of=init_boot_a.img</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/block/mmcblk2p21 of=metadata.img</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/block/mmcblk2p6 of=misc.img</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/block/mmcblk2boot0 of=mmcblk2boot0.img</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/block/mmcblk2boot1 of=mmcblk2boot1.img</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/block/mmcblk2p7 of=resource_a.img</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/block/mmcblk2p1 of=security.img</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/block/mmcblk2p24 of=super.img</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/block/mmcblk2p4 of=trust_a.img</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/block/mmcblk2p2 of=uboot_a.img</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/block/mmcblk2p15 of=vbmeta_a.img</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/block/mmcblk2p9 of=vendor_boot_a.img</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/block/mmcblk2p25 of=userdata.img bs=1M count=9216</span><br></pre></td></tr></table></figure><p>使用<code>pull</code>命令拉取到本地文件夹：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ adb pull /data/back/</span><br><span class="line">/data/back/: 26 files pulled. 35.7 MB/s (5431099392 bytes <span class="keyword">in</span> 144.983s)</span><br></pre></td></tr></table></figure><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
          <category> reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> kernel </tag>
            
            <tag> rockchip </tag>
            
            <tag> hack </tag>
            
            <tag> rk3566 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux服务器搭建nfs服务(转)</title>
      <link href="/2024/08/12/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAnfs%E6%9C%8D%E5%8A%A1/"/>
      <url>/2024/08/12/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAnfs%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6868085817987268616">https://juejin.cn/post/6868085817987268616</a></p>]]></content>
      
      
      <categories>
          
          <category> server </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux服务器配置ssh密钥登录</title>
      <link href="/2024/08/12/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AEssh%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95/"/>
      <url>/2024/08/12/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AEssh%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="What-server-does"><a href="#What-server-does" class="headerlink" title="What server does"></a>What server does</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>打开如下选项：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PubkeyAuthentication <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><p>使用如下命令生成密钥：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> .ssh</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> id_rsa.pub &gt;&gt; authorized_keys</span><br></pre></td></tr></table></figure><p>重启<code>sshd</code>服务：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart ssh</span><br></pre></td></tr></table></figure><h2 id="What-client-does"><a href="#What-client-does" class="headerlink" title="What client does"></a>What client does</h2><p>复制<code>.ssh</code>目录下的<code>id_rsa</code>文件到<code>~/.ssh</code>目录下并重命名一个名字。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 600 ./&lt;your id_rsa name&gt; </span><br></pre></td></tr></table></figure><p>编辑<code>hostname</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.ssh/config</span><br></pre></td></tr></table></figure><p>将以下内容添加进入：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host &lt;your server name&gt;</span><br><span class="line">HostName &lt;your server IP&gt;</span><br><span class="line">TCPKeepAlive <span class="built_in">yes</span></span><br><span class="line">ServerAliveInterval 15</span><br><span class="line">User &lt;your user name of server&gt;</span><br><span class="line">IdentityFile &lt;your id_rsa file path&gt;</span><br><span class="line">Port &lt;your server port&gt;</span><br></pre></td></tr></table></figure><p>尝试连接：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh &lt;your server name&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> server </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rk3568不能烧写问题</title>
      <link href="/2024/08/08/rk3568%E4%B8%8D%E8%83%BD%E7%83%A7%E5%86%99%E9%97%AE%E9%A2%98/"/>
      <url>/2024/08/08/rk3568%E4%B8%8D%E8%83%BD%E7%83%A7%E5%86%99%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>烧写固件时被打断就会导致<code>Loader</code>和<code>Maskrom</code>模式都无法进入。</p><p>此时将<code>sd</code>卡刷写一个<code>update.img</code>，就可以进入<code>Maskrom</code>模式，此时可向<code>emmc</code>烧写镜像。</p>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
          <category> rockchip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> kernel </tag>
            
            <tag> rk3568 </tag>
            
            <tag> rockchip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>esp32-system-api: Event Loop Library</title>
      <link href="/2024/08/07/esp32-system-api-Event-Loop-Library/"/>
      <url>/2024/08/07/esp32-system-api-Event-Loop-Library/</url>
      
        <content type="html"><![CDATA[<h2 id="Env"><a href="#Env" class="headerlink" title="Env"></a>Env</h2><p>esp-idf: v5.3-stable</p><h2 id="数据结构介绍"><a href="#数据结构介绍" class="headerlink" title="数据结构介绍"></a>数据结构介绍</h2><h3 id="事件处理函数"><a href="#事件处理函数" class="headerlink" title="事件处理函数"></a>事件处理函数</h3><p>当事件到达后，运行的函数名为<code>事件处理函数</code>。</p><p><code>事件处理函数</code>要在<code>事件循环</code>创建完成之后调用注册函数注册进入<code>事件循环</code>。</p><p><code>事件处理函数</code>定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">esp_event_handler_t</span>)</span><span class="params">(<span class="type">void</span>* event_handler_arg,</span></span><br><span class="line"><span class="params">                                    <span class="type">esp_event_base_t</span> event_base,</span></span><br><span class="line"><span class="params">                                    <span class="type">int32_t</span> event_id,</span></span><br><span class="line"><span class="params">                                    <span class="type">void</span>* event_data)</span>; </span><br><span class="line"><span class="comment">/**&lt; function called when an event is posted to the queue */</span></span><br></pre></td></tr></table></figure><h3 id="事件循环句柄"><a href="#事件循环句柄" class="headerlink" title="事件循环句柄"></a>事件循环句柄</h3><p>事件循环句柄的<code>内存</code>与<code>值</code>由<code>API</code>决定，用户并不参与，所以用户在创建事件循环句柄的时候应该创建为指针，调用<code>esp_event_loop_create</code>函数创建事件循环句柄，经该函数创建的事件循环句柄称为<code>用户事件循环句柄</code>。</p><p>事件循环句柄类型：<code>esp_event_loop_handle_t</code><br>PS: 这个类型已经为一个指针。</p><p>e.g.: </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">esp_event_loop_handle_t</span> loop_handle;</span><br></pre></td></tr></table></figure><h3 id="事件循环配置项"><a href="#事件循环配置项" class="headerlink" title="事件循环配置项"></a>事件循环配置项</h3><p>上面提到<code>事件循环句柄</code>由API创建，那么如果想配置<code>事件循环</code>就要用到<code>事件循环配置项</code>。</p><p><code>事件循环配置项</code>定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Configuration for creating event loops</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int32_t</span> queue_size;                         <span class="comment">/**&lt; size of the event loop queue */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *task_name;                      <span class="comment">/**&lt; name of the event loop task; if NULL,</span></span><br><span class="line"><span class="comment">                                                        a dedicated task is not created for event loop*/</span></span><br><span class="line">    UBaseType_t task_priority;                  <span class="comment">/**&lt; priority of the event loop task, ignored if task name is NULL */</span></span><br><span class="line">    <span class="type">uint32_t</span> task_stack_size;                   <span class="comment">/**&lt; stack size of the event loop task, ignored if task name is NULL */</span></span><br><span class="line">    BaseType_t task_core_id;                    <span class="comment">/**&lt; core to which the event loop task is pinned to,</span></span><br><span class="line"><span class="comment">                                                        ignored if task name is NULL */</span></span><br><span class="line">&#125; <span class="type">esp_event_loop_args_t</span>;</span><br></pre></td></tr></table></figure><p>配置项解析如下：</p><ul><li>queue_size: 事件循环队列大小，指在<code>事件</code>没发送到<code>事件处理函数</code>之前，该<code>事件循环</code>最多能容纳的事件数量。</li><li>task_name: 是否选择定义一个<code>线程</code>去读取<code>事件循环</code>的队列，并且在读取到数据后执行<code>事件处理函数</code>，如果该参数为<code>NULL</code>，则没有<code>专用线程</code>读取事件并执行<code>事件处理函数</code>，需要手动调用<code>esp_event_loop_run</code>函数去读取<code>队列</code>执行<code>事件处理函数</code>，并且下面三个成员配置项无效。</li><li>task_priority: <code>事件循环专用线程</code>的优先级配置，可使用<code>uxTaskPriorityGet(NULL)</code>函数获取当前线程优先级附加给它。</li><li>task_stack_size: 该<code>专用线程</code>的堆栈大小，不建议太小，会溢出，<code>3072</code>是一个普遍安全值。</li><li>task_core_id: 该事件循环<code>专用线程</code>在哪个核心上执行，应该≥<code>0</code> &amp;&amp; ＜ <code>CONFIG_FREERTOS_NUMBER_OF_CORES</code>，该宏在<code>sdkconfig</code>定义了最大核心数。也可以使用<code>tskNO_AFFINITY</code>宏定义不指定任何一个核心，由<code>FreeRTOS</code>指定。</li></ul><h2 id="EVENT-BASE与EVENT-ID"><a href="#EVENT-BASE与EVENT-ID" class="headerlink" title="EVENT_BASE与EVENT_ID"></a>EVENT_BASE与EVENT_ID</h2><p>每个<code>事件循环</code>都应该有<code>事件处理函数</code>，否则<code>事件循环</code>毫无意义。</p><p>在<code>事件处理函数</code>中区别<code>事件</code>的唯一方式就是通过<code>EVENT_BASE</code>与<code>EVENT_ID</code>。</p><p>这两个类似于Linux的major与minor。</p><p>如<code>EVENT_BASE</code>可以是<code>WIFI_EVENT</code>，<code>EVENT_ID</code>可以是<code>CONNECTED</code>、<code>GOT_IP</code>等。</p><p><code>EVENT_BASE</code>定义方式如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ESP_EVENT_DECLARE_BASE(MY_EVENT_BASE);</span><br><span class="line">ESP_EVENT_DEFINE_BASE(MY_EVENT_BASE);</span><br></pre></td></tr></table></figure><p><code>EVENT_ID</code>推荐通过<code>enum</code>定义：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    MY_EVENT_ID1,</span><br><span class="line">    MY_EVENT_ID2,</span><br><span class="line">    MY_EVENT_ID3,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>该章节涵盖了常用API以及简介，欲知更详细，请见[1]</p><ul><li><code>esp_event_loop_create</code>:  该函数创建了<code>事件循环</code>，两个入参一个是<code>事件循环句柄</code>，一个是<code>事件循环参数</code>。</li><li><code>esp_event_loop_create_default</code>: 该函数创建了默认的事件循环，由于一些事件的推送不能由用户提交到队列，如wifi连接事件，获取ip事件等，所以便有了默认的事件循环，具体见[4]</li><li><code>esp_event_loop_delete:</code> 删除事件循环，入参是<code>事件循环句柄</code>。</li><li><code>esp_event_loop_delete_default</code>: 删除默认事件循环</li><li><code>esp_event_handler_register_with</code>: 注册<code>事件处理函数</code>到某个<code>事件循环</code>，需要提供该事件处理函数所处理的<code>EVENT_BASE</code>和<code>EVENT_ID</code>，一个<code>事件处理函数</code>可用不同的<code>EVENT</code>注册多次，也可以使用<code>ESP_EVENT_ANY_ID</code>去处理整个<code>EVENT_BASE</code>下的<code>ID</code></li><li><code>esp_event_handler_unregister_with</code>: 注销某个<code>事件处理函数</code></li><li><code>esp_event_handler_register</code>: 为<code>默认事件循环</code>注册<code>事件处理函数</code>，除了不需要提供<code>事件循环句柄</code>以外，与<code>esp_event_handler_register</code>无异。</li><li><code>esp_event_handler_unregister</code>: 为<code>默认事件循环</code>注销<code>事件处理函数</code>，除了不需要提供<code>事件循环句柄</code>以外，与<code>esp_event_handler_register</code>无异。</li><li><code>esp_event_post_to</code>: 向指定的<code>事件循环</code>发送事件。</li><li><code>esp_event_post</code>: 向默认的<code>事件循环</code>发送事件</li><li><code>esp_event_loop_run</code>: 当在事件循环参数内没有配置<code>task_name</code>时，就不用有<code>专有线程</code>去读取<code>队列</code>并且执行<code>事件处理函数</code>，此时需要调用<code>esp_event_loop_run</code>手动读取并调用<code>事件处理函数</code>，该函数两个入参分别为<code>事件循环句柄</code>和<code>运行tick</code></li></ul><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h3 id="用户事件循环"><a href="#用户事件循环" class="headerlink" title="用户事件循环"></a>用户事件循环</h3><h4 id="专属线程"><a href="#专属线程" class="headerlink" title="专属线程"></a>专属线程</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 事件循环句柄 */</span></span><br><span class="line"><span class="type">esp_event_loop_handle_t</span> loop_with_task;</span><br><span class="line"></span><br><span class="line">ESP_EVENT_DECLARE_BASE(TASK_EVENTS);         <span class="comment">// declaration of the task events family</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    TASK_ITERATION_EVENT                     <span class="comment">// raised during an iteration of the loop within the task</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">task_iteration_handler</span><span class="params">(<span class="type">void</span>* handler_args, <span class="type">esp_event_base_t</span> base, <span class="type">int32_t</span> id, <span class="type">void</span>* event_data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Two types of data can be passed in to the event handler: the handler specific data and the event-specific data.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The handler specific data (handler_args) is a pointer to the original data, therefore, the user should ensure that</span></span><br><span class="line">    <span class="comment">// the memory location it points to is still valid when the handler executes.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The event-specific data (event_data) is a pointer to a deep copy of the original data, and is managed automatically.</span></span><br><span class="line">    <span class="type">int</span> iteration = *((<span class="type">int</span>*) event_data);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* loop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handler_args == loop_with_task) &#123;</span><br><span class="line">        loop = <span class="string">&quot;loop_with_task&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        loop = <span class="string">&quot;loop_without_task&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;handling %s:%s from %s, iteration %d&quot;</span>, base, <span class="string">&quot;TASK_ITERATION_EVENT&quot;</span>, loop, iteration);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* 事件循环参数 有专属任务*/</span> </span><br><span class="line">    <span class="type">esp_event_loop_args_t</span> loop_with_task_args = &#123;</span><br><span class="line">            <span class="comment">/* 队列大小 */</span> </span><br><span class="line">            .queue_size = <span class="number">5</span>,</span><br><span class="line">            .task_name = <span class="string">&quot;loop_task&quot;</span>, <span class="comment">// task will be created</span></span><br><span class="line">            <span class="comment">/* 当前创建事件循环的任务的优先级 */</span></span><br><span class="line">            .task_priority = uxTaskPriorityGet(<span class="literal">NULL</span>),</span><br><span class="line">            <span class="comment">/* 堆栈大小 */</span> </span><br><span class="line">            .task_stack_size = <span class="number">3072</span>,</span><br><span class="line">            <span class="comment">/* 不指定任何核心，由系统指派 */</span> </span><br><span class="line">            .task_core_id = tskNO_AFFINITY</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建事件循环 */</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_event_loop_create(&amp;loop_with_task_args, &amp;loop_with_task));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注册事件处理函数 */</span> </span><br><span class="line">    ESP_ERROR_CHECK(esp_event_handler_instance_register_with(loop_with_task, TASK_EVENTS, TASK_ITERATION_EVENT, task_iteration_handler, loop_with_task, <span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="没有专属线程"><a href="#没有专属线程" class="headerlink" title="没有专属线程"></a>没有专属线程</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 事件循环句柄 */</span></span><br><span class="line"><span class="type">esp_event_loop_handle_t</span> loop_without_task;</span><br><span class="line"></span><br><span class="line">ESP_EVENT_DECLARE_BASE(TASK_EVENTS);         <span class="comment">// declaration of the task events family</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    TASK_ITERATION_EVENT                     <span class="comment">// raised during an iteration of the loop within the task</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">task_iteration_handler</span><span class="params">(<span class="type">void</span>* handler_args, <span class="type">esp_event_base_t</span> base, <span class="type">int32_t</span> id, <span class="type">void</span>* event_data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Two types of data can be passed in to the event handler: the handler specific data and the event-specific data.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The handler specific data (handler_args) is a pointer to the original data, therefore, the user should ensure that</span></span><br><span class="line">    <span class="comment">// the memory location it points to is still valid when the handler executes.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The event-specific data (event_data) is a pointer to a deep copy of the original data, and is managed automatically.</span></span><br><span class="line">    <span class="type">int</span> iteration = *((<span class="type">int</span>*) event_data);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* loop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handler_args == loop_with_task) &#123;</span><br><span class="line">        loop = <span class="string">&quot;loop_with_task&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        loop = <span class="string">&quot;loop_without_task&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;handling %s:%s from %s, iteration %d&quot;</span>, base, <span class="string">&quot;TASK_ITERATION_EVENT&quot;</span>, loop, iteration);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* 事件循环参数 没有专属任务</span></span><br><span class="line"><span class="comment">        在post_to之后需要在线程中</span></span><br><span class="line"><span class="comment">        调用esp_event_loop_run(loop_without_task, 100);</span></span><br><span class="line"><span class="comment">        否则无法进入事件处理函数</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="type">esp_event_loop_args_t</span> loop_without_task_args = &#123;</span><br><span class="line">        .queue_size = <span class="number">5</span>,</span><br><span class="line">        .task_name = <span class="literal">NULL</span> <span class="comment">// no task will be created</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建事件循环 */</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_event_loop_create(&amp;loop_without_task_args, &amp;loop_without_task));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注册事件处理函数 */</span> </span><br><span class="line">    ESP_ERROR_CHECK(esp_event_handler_instance_register_with(loop_with_task, TASK_EVENTS, TASK_ITERATION_EVENT, task_iteration_handler, loop_with_task, <span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>[1]<a href="https://docs.espressif.com/projects/esp-idf/zh_CN/v5.3/esp32/api-reference/system/esp_event.html">https://docs.espressif.com/projects/esp-idf/zh_CN/v5.3/esp32/api-reference/system/esp_event.html</a><br>[2]<a href="https://github.com/espressif/esp-idf/tree/v5.3/examples/system/esp_event/user_event_loops">https://github.com/espressif/esp-idf/tree/v5.3/examples/system/esp_event/user_event_loops</a><br>[3]<a href="https://github.com/espressif/esp-idf/tree/v5.3/examples/system/esp_event/default_event_loop">https://github.com/espressif/esp-idf/tree/v5.3/examples/system/esp_event/default_event_loop</a><br>[4]<a href="https://docs.espressif.com/projects/esp-idf/zh_CN/v5.3/esp32/api-reference/system/esp_event.html#esp-event-default-loops">https://docs.espressif.com/projects/esp-idf/zh_CN/v5.3/esp32/api-reference/system/esp_event.html#esp-event-default-loops</a></p>]]></content>
      
      
      <categories>
          
          <category> mcu </category>
          
          <category> esp32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mcu </tag>
            
            <tag> esp32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim中文乱码</title>
      <link href="/2024/08/07/vim%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
      <url>/2024/08/07/vim%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.vimrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将以下内容加入：</span></span><br><span class="line"><span class="built_in">set</span> termencoding=utf-8</span><br><span class="line"><span class="built_in">set</span> encoding=utf8</span><br><span class="line"><span class="built_in">set</span> fileencodings=utf8,ucs-bom,gbk,cp936,gb2312,gb18030</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>clion开发esp32</title>
      <link href="/2024/08/01/clion%E5%BC%80%E5%8F%91esp32/"/>
      <url>/2024/08/01/clion%E5%BC%80%E5%8F%91esp32/</url>
      
        <content type="html"><![CDATA[<h2 id="README"><a href="#README" class="headerlink" title="README"></a>README</h2><p>本文基于文末的<code>ref</code>链接[Link1]搭建，这里作为一些补充记录。</p><p>Chip: esp32c3</p><p>System: Ubuntu 22.04</p><h2 id="安装idf出现错误"><a href="#安装idf出现错误" class="headerlink" title="安装idf出现错误"></a>安装idf出现错误</h2><p>在执行<code>.install.sh</code>时遇到如下错误：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./install.sh</span><br><span class="line">Detecting the Python interpreter</span><br><span class="line">Checking <span class="string">&quot;python3&quot;</span> ...</span><br><span class="line">Python 3.10.12</span><br><span class="line"><span class="string">&quot;python3&quot;</span> has been detected</span><br><span class="line">Checking Python cref: nsa-esp-elf-gdb, riscv32-esp-elf-gdb, xtensa-esp-elf, riscv32-esp-elf, esp32ulp-elf, openocd-esp32, esp-rom-elfs</span><br><span class="line">Skipping xtensa-esp-elf-gdb@14.2_20240403 (already installed)</span><br><span class="line">Skipping riscv32-esp-elf-gdb@14.2_20240403 (already installed)</span><br><span class="line">Skipping xtensa-esp-elf@esp-13.2.0_20240530 (already installed)</span><br><span class="line">Skipping riscv32-esp-elf@esp-13.2.0_20240530 (already installed)</span><br><span class="line">Skipping esp32ulp-elf@2.38_20240113 (already installed)</span><br><span class="line">Skipping openocd-esp32@v0.12.0-esp32-20240318 (already installed)</span><br><span class="line">Skipping esp-rom-elfs@20240305 (already installed)</span><br><span class="line">Installing Python environment and packages</span><br><span class="line">Python 3.10.12</span><br><span class="line">pip 22.0.2 from /home/troy/.espressif/python_env/idf5.3_py3.10_env/lib/python3.10/site-packages/pip (python 3.10)</span><br><span class="line">Upgrading pip and setuptools...</span><br><span class="line">Requirement already satisfied: pip <span class="keyword">in</span> /home/troy/.espressif/python_env/idf5.3_py3.10_env/lib/python3.10/site-packages (22.0.2)</span><br><span class="line">Collecting pip</span><br><span class="line">  Using cached pip-24.2-py3-none-any.whl (1.8 MB)</span><br><span class="line">Requirement already satisfied: setuptools <span class="keyword">in</span> /home/troy/.espressif/python_env/idf5.3_py3.10_env/lib/python3.10/site-packages (59.6.0)</span><br><span class="line">Collecting setuptools</span><br><span class="line">  Using cached setuptools-72.1.0-py3-none-any.whl (2.3 MB)</span><br><span class="line">Installing collected packages: setuptools, pip</span><br><span class="line">  Attempting uninstall: setuptools</span><br><span class="line">    Found existing installation: setuptools 59.6.0</span><br><span class="line">    Uninstalling setuptools-59.6.0:</span><br><span class="line">      Successfully uninstalled setuptools-59.6.0</span><br><span class="line">  Attempting uninstall: pip</span><br><span class="line">    Found existing installation: pip 22.0.2</span><br><span class="line">    Uninstalling pip-22.0.2:</span><br><span class="line">      Successfully uninstalled pip-22.0.2</span><br><span class="line">Successfully installed pip-24.2 setuptools-72.1.0</span><br><span class="line">Skipping the download of /home/troy/.espressif/espidf.constraints.v5.3.txt because it was downloaded recently.</span><br><span class="line">Installing Python packages</span><br><span class="line"> Constraint file: /home/troy/.espressif/espidf.constraints.v5.3.txt</span><br><span class="line"> Requirement files:</span><br><span class="line">  - /home/troy/repo/esp-idf-v5.3/tools/requirements/requirements.core.txt</span><br><span class="line">Usage: __main__.py [options]</span><br><span class="line"></span><br><span class="line">ERROR: Invalid requirement: --2024-08-01 15:30:43--  https://dl.espressif.com/dl/esp-idf/espidf.constraints.v5.3.txt</span><br><span class="line">__main__.py: error: no such option: --2024-08-01</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/home/troy/repo/esp-idf-v5.3/tools/idf_tools.py&quot;</span>, line 3241, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    main(sys.argv[1:])</span><br><span class="line">  File <span class="string">&quot;/home/troy/repo/esp-idf-v5.3/tools/idf_tools.py&quot;</span>, line 3233, <span class="keyword">in</span> main</span><br><span class="line">    action_func(args)</span><br><span class="line">  File <span class="string">&quot;/home/troy/repo/esp-idf-v5.3/tools/idf_tools.py&quot;</span>, line 2680, <span class="keyword">in</span> action_install_python_env</span><br><span class="line">    subprocess.check_call(run_args, stdout=sys.stdout, stderr=sys.stderr, <span class="built_in">env</span>=env_copy)</span><br><span class="line">  File <span class="string">&quot;/usr/lib/python3.10/subprocess.py&quot;</span>, line 369, <span class="keyword">in</span> check_call</span><br><span class="line">    raise CalledProcessError(retcode, cmd)</span><br><span class="line">subprocess.CalledProcessError: Command <span class="string">&#x27;[&#x27;</span>/home/troy/.espressif/python_env/idf5.3_py3.10_env/bin/python<span class="string">&#x27;, &#x27;</span>-m<span class="string">&#x27;, &#x27;</span>pip<span class="string">&#x27;, &#x27;</span>install<span class="string">&#x27;, &#x27;</span>--no-warn-script-location<span class="string">&#x27;, &#x27;</span>-r<span class="string">&#x27;, &#x27;</span>/home/troy/repo/esp-idf-v5.3/tools/requirements/requirements.core.txt<span class="string">&#x27;, &#x27;</span>--upgrade<span class="string">&#x27;, &#x27;</span>--constraint<span class="string">&#x27;, &#x27;</span>/home/troy/.espressif/espidf.constraints.v5.3.txt<span class="string">&#x27;, &#x27;</span>--extra-index-url<span class="string">&#x27;, &#x27;</span>https://dl.espressif.com/pypi<span class="string">&#x27;]&#x27;</span> returned non-zero <span class="built_in">exit</span> status 1.</span><br></pre></td></tr></table></figure><p>手动下载：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://dl.espressif.com/dl/esp-idf/espidf.constraints.v5.3.txt -O /home/troy/.espressif/espidf.constraints.v5.3.txt</span><br><span class="line"></span><br><span class="line">--2024-08-01 15:43:03--  https://dl.espressif.com/dl/esp-idf/espidf.constraints.v5.3.txt</span><br><span class="line">正在连接 127.0.0.1:7897... 已连接。</span><br><span class="line">已发出 Proxy 请求，正在等待回应... 200 OK</span><br><span class="line">长度： 2940 (2.9K) [text/plain]</span><br><span class="line">正在保存至: ‘/home/troy/.espressif/espidf.constraints.v5.3.txt’</span><br><span class="line"></span><br><span class="line">/home/troy/.espressif/espidf.constrai 100%[========================================================================&gt;]   2.87K  --.-KB/s    用时 0s    </span><br><span class="line"></span><br><span class="line">2024-08-01 15:43:03 (446 MB/s) - 已保存 ‘/home/troy/.espressif/espidf.constraints.v5.3.txt’ [2940/2940])</span><br></pre></td></tr></table></figure><h2 id="烧录程序后如何自动打开串口"><a href="#烧录程序后如何自动打开串口" class="headerlink" title="烧录程序后如何自动打开串口"></a>烧录程序后如何自动打开串口</h2><p>在经过对配置文件<code>monitor</code>的尝试之后，确实以<code>115200</code>波特率打开了<code>/dev/ttyACM0</code>，但是<code>console</code>上显示的字符全是空白，不清楚为什么，所以为<code>flash</code>这个<code>configuration</code>添加一下可执行文件，记得勾选上在<code>输出控制台模拟终端</code>。</p><p>可执行文件内容：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">idf.py monitor</span><br></pre></td></tr></table></figure><p>PS: 由于用到了<code>idf.py</code>，所以要执行<code>export.sh</code>，在<code>toolchain</code>里面的环境变量中可以添加<code>export.sh</code>.</p><p><img src="https://i.ibb.co/42jkNps/2024-08-04-19-28-11.png" alt="how to install export.sh"></p><p>记得勾选上</p><h2 id="如何通过JTAG进行调试"><a href="#如何通过JTAG进行调试" class="headerlink" title="如何通过JTAG进行调试"></a>如何通过JTAG进行调试</h2><p>添加<code>嵌入式GDB服务器</code>configuration后按照下图填写参数，需要注意两点：</p><ul><li><code>GDB服务器实参</code>的<code>cfg文件</code>请参考链接5[5]</li><li>调试器需要选择<code>esp32</code>对应的<code>gdb</code>，而不是内置的，这点需要在<code>toolchain</code>里面去配置路径，跟<code>gcc</code>和<code>g++</code>在的地方差不多</li></ul><p><img src="https://i.ibb.co/Qf8TRnx/2024-08-05-15-12-56.png" alt="how to jtag"></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>[Link1]<a href="https://blog.csdn.net/m0_51719399/article/details/127389279">https://blog.csdn.net/m0_51719399/article/details/127389279</a><br>[Link2]<a href="https://www.bilibili.com/read/cv15226500/">https://www.bilibili.com/read/cv15226500/</a><br>[Link3]<a href="https://github.com/TroyMitchell911/esp32-example-clion">https://github.com/TroyMitchell911/esp32-example-clion</a><br>[Link4]<a href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32c3/api-guides/jtag-debugging/index.html">https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32c3/api-guides/jtag-debugging/index.html</a><br>[Link5]<a href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32c3/api-guides/jtag-debugging/tips-and-quirks.html#jtag-debugging-tip-openocd-configure-target">https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32c3/api-guides/jtag-debugging/tips-and-quirks.html#jtag-debugging-tip-openocd-configure-target</a></p>]]></content>
      
      
      <categories>
          
          <category> mcu </category>
          
          <category> esp32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mcu </tag>
            
            <tag> esp32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rk3568移植openHarmony v3.2.3---环境准备</title>
      <link href="/2024/08/01/rk3568%E7%A7%BB%E6%A4%8DopenHarmony/"/>
      <url>/2024/08/01/rk3568%E7%A7%BB%E6%A4%8DopenHarmony/</url>
      
        <content type="html"><![CDATA[<h1 id="Env"><a href="#Env" class="headerlink" title="Env"></a>Env</h1><p>System: Ubuntu 20.04</p><h2 id="Package"><a href="#Package" class="headerlink" title="Package"></a>Package</h2><p>安装编译所需要的软件包：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="built_in">sudo</span> apt-get install binutils git git-lfs gnupg flex bison gperf build-essential zlib1g-dev \</span><br><span class="line">gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev \</span><br><span class="line">ccache libgl1-mesa-dev libxml2-utils xsltproc unzip m4 bc gnutls-bin python3.8 python3-pip ruby \</span><br><span class="line">openjdk-8-jdk genext2fs libopencv-dev lz4 libssl-dev libncurses5 git-lfs lib32z1-dev zip curl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果libncurses5这个依赖没安装上，执行apt再次安装依赖</span></span><br><span class="line"><span class="built_in">sudo</span> apt install libncurses5</span><br></pre></td></tr></table></figure><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo init -u git@gitee.com:openharmony/manifest.git -b refs/tags/OpenHarmony-v3.1.3-Release --no-repo-verify</span><br><span class="line">repo <span class="built_in">sync</span> -c</span><br><span class="line">repo forall -c <span class="string">&#x27;git lfs pull&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo init -u https://gitee.com/openharmony/manifest.git -b refs/tags/OpenHarmony-v3.1.3-Release --no-repo-verify</span><br><span class="line">repo <span class="built_in">sync</span> -c</span><br><span class="line">repo forall -c <span class="string">&#x27;git lfs pull&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="Toolchains"><a href="#Toolchains" class="headerlink" title="Toolchains"></a>Toolchains</h2><p>对于这一步，如果你有开启<code>proxy</code>的话，请关闭。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash ./build/prebuilts_download.sh</span><br></pre></td></tr></table></figure><h1 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h1><p>在移植之前，请先编译一次原版：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./build.sh --product-name rk3568 --ccache</span><br></pre></td></tr></table></figure><h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><p><a href="https://doc.embedfire.com/linux/rk356x/OpenHarmony_manual/zh/latest/doc/linux_introduce/ohos-compile.html">https://doc.embedfire.com/linux/rk356x/OpenHarmony_manual/zh/latest/doc/linux_introduce/ohos-compile.html</a></p>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
          <category> rockchip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openHarmony </tag>
            
            <tag> kernel </tag>
            
            <tag> rk3568 </tag>
            
            <tag> rockchip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rk3568 sd card无法检测</title>
      <link href="/2024/07/31/rk3568-sd-card%E6%97%A0%E6%B3%95%E6%A3%80%E6%B5%8B-1/"/>
      <url>/2024/07/31/rk3568-sd-card%E6%97%A0%E6%B3%95%E6%A3%80%E6%B5%8B-1/</url>
      
        <content type="html"><![CDATA[<p>配置好设备树节点后插入sd卡无法检测。</p><p>设备树节点如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;sdmmc0 &#123;</span><br><span class="line">bus-width = &lt;4&gt;;</span><br><span class="line">cap-sd-highspeed;</span><br><span class="line">cd-gpios = &lt;&amp;gpio0 RK_PA4 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">disable-wp;</span><br><span class="line">pinctrl-names = &quot;default&quot;;</span><br><span class="line">pinctrl-0 = &lt;&amp;sdmmc0_bus4 &amp;sdmmc0_clk &amp;sdmmc0_cmd &amp;sdmmc0_det&gt;;</span><br><span class="line">sd-uhs-sdr104;</span><br><span class="line">vmmc-supply = &lt;&amp;vcc3v3_sd&gt;;</span><br><span class="line">vqmmc-supply = &lt;&amp;vccio_sd&gt;;</span><br><span class="line">status = &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>查看内核日志发现如下报错：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dmesg | grep mmc</span><br><span class="line">[   12.226496] dwmmc_rockchip fe2b0000.mmc: Looking up vmmc-supply from device tree</span><br><span class="line">[   12.226535] dwmmc_rockchip fe2b0000.mmc: Looking up vqmmc-supply from device tree</span><br></pre></td></tr></table></figure><p><code>vmmc-supply</code>和<code>vqmmc-supply</code>由<code>rk809</code>提供，<code>rk809</code>在该板子上连接到了<code>i2c0</code>, 设备树如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;i2c0 &#123;</span><br><span class="line">status = &quot;okay&quot;;</span><br><span class="line"></span><br><span class="line">rk809: pmic@20 &#123;</span><br><span class="line">compatible = &quot;rockchip,rk809&quot;;</span><br><span class="line">reg = &lt;0x20&gt;;</span><br><span class="line">interrupt-parent = &lt;&amp;gpio0&gt;;</span><br><span class="line">interrupts = &lt;RK_PA3 IRQ_TYPE_LEVEL_LOW&gt;;</span><br><span class="line">assigned-clocks = &lt;&amp;cru I2S1_MCLKOUT_TX&gt;;</span><br><span class="line">assigned-clock-parents = &lt;&amp;cru CLK_I2S1_8CH_TX&gt;;</span><br><span class="line">#clock-cells = &lt;1&gt;;</span><br><span class="line">clock-names = &quot;mclk&quot;;</span><br><span class="line">clocks = &lt;&amp;cru I2S1_MCLKOUT_TX&gt;;</span><br><span class="line">pinctrl-names = &quot;default&quot;;</span><br><span class="line">pinctrl-0 = &lt;&amp;pmic_int&gt;;</span><br><span class="line">rockchip,system-power-controller;</span><br><span class="line">#sound-dai-cells = &lt;0&gt;;</span><br><span class="line">vcc1-supply = &lt;&amp;vcc3v3_sys&gt;;</span><br><span class="line">vcc2-supply = &lt;&amp;vcc3v3_sys&gt;;</span><br><span class="line">vcc3-supply = &lt;&amp;vcc3v3_sys&gt;;</span><br><span class="line">vcc4-supply = &lt;&amp;vcc3v3_sys&gt;;</span><br><span class="line">vcc5-supply = &lt;&amp;vcc3v3_sys&gt;;</span><br><span class="line">vcc6-supply = &lt;&amp;vcc3v3_sys&gt;;</span><br><span class="line">vcc7-supply = &lt;&amp;vcc3v3_sys&gt;;</span><br><span class="line">vcc8-supply = &lt;&amp;vcc3v3_sys&gt;;</span><br><span class="line">vcc9-supply = &lt;&amp;vcc3v3_sys&gt;;</span><br><span class="line">wakeup-source;</span><br><span class="line"></span><br><span class="line">regulators &#123;</span><br><span class="line">vdd_logic: DCDC_REG1 &#123;</span><br><span class="line">regulator-name = &quot;vdd_logic&quot;;</span><br><span class="line">regulator-always-on;</span><br><span class="line">regulator-boot-on;</span><br><span class="line">regulator-min-microvolt = &lt;500000&gt;;</span><br><span class="line">regulator-max-microvolt = &lt;1350000&gt;;</span><br><span class="line">regulator-ramp-delay = &lt;6001&gt;;</span><br><span class="line">regulator-initial-mode = &lt;0x2&gt;;</span><br><span class="line"></span><br><span class="line">regulator-state-mem &#123;</span><br><span class="line">regulator-off-in-suspend;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vdd_gpu: DCDC_REG2 &#123;</span><br><span class="line">regulator-name = &quot;vdd_gpu&quot;;</span><br><span class="line">regulator-always-on;</span><br><span class="line">regulator-boot-on;</span><br><span class="line">regulator-min-microvolt = &lt;500000&gt;;</span><br><span class="line">regulator-max-microvolt = &lt;1350000&gt;;</span><br><span class="line">regulator-ramp-delay = &lt;6001&gt;;</span><br><span class="line">regulator-initial-mode = &lt;0x2&gt;;</span><br><span class="line"></span><br><span class="line">regulator-state-mem &#123;</span><br><span class="line">regulator-off-in-suspend;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vcc_ddr: DCDC_REG3 &#123;</span><br><span class="line">regulator-name = &quot;vcc_ddr&quot;;</span><br><span class="line">regulator-always-on;</span><br><span class="line">regulator-boot-on;</span><br><span class="line">regulator-initial-mode = &lt;0x2&gt;;</span><br><span class="line"></span><br><span class="line">regulator-state-mem &#123;</span><br><span class="line">regulator-on-in-suspend;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vdd_npu: DCDC_REG4 &#123;</span><br><span class="line">regulator-name = &quot;vdd_npu&quot;;</span><br><span class="line">regulator-always-on;</span><br><span class="line">regulator-boot-on;</span><br><span class="line">regulator-min-microvolt = &lt;500000&gt;;</span><br><span class="line">regulator-max-microvolt = &lt;1350000&gt;;</span><br><span class="line">regulator-ramp-delay = &lt;6001&gt;;</span><br><span class="line">regulator-initial-mode = &lt;0x2&gt;;</span><br><span class="line"></span><br><span class="line">regulator-state-mem &#123;</span><br><span class="line">regulator-off-in-suspend;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vcc_1v8: DCDC_REG5 &#123;</span><br><span class="line">regulator-name = &quot;vcc_1v8&quot;;</span><br><span class="line">regulator-always-on;</span><br><span class="line">regulator-boot-on;</span><br><span class="line">regulator-min-microvolt = &lt;1800000&gt;;</span><br><span class="line">regulator-max-microvolt = &lt;1800000&gt;;</span><br><span class="line"></span><br><span class="line">regulator-state-mem &#123;</span><br><span class="line">regulator-off-in-suspend;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vdda0v9_image: LDO_REG1 &#123;</span><br><span class="line">regulator-name = &quot;vdda0v9_image&quot;;</span><br><span class="line">regulator-boot-on;</span><br><span class="line">regulator-always-on;</span><br><span class="line">regulator-min-microvolt = &lt;900000&gt;;</span><br><span class="line">regulator-max-microvolt = &lt;900000&gt;;</span><br><span class="line"></span><br><span class="line">regulator-state-mem &#123;</span><br><span class="line">regulator-off-in-suspend;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vdda_0v9: LDO_REG2 &#123;</span><br><span class="line">regulator-name = &quot;vdda_0v9&quot;;</span><br><span class="line">regulator-always-on;</span><br><span class="line">regulator-boot-on;</span><br><span class="line">regulator-min-microvolt = &lt;900000&gt;;</span><br><span class="line">regulator-max-microvolt = &lt;900000&gt;;</span><br><span class="line"></span><br><span class="line">regulator-state-mem &#123;</span><br><span class="line">regulator-off-in-suspend;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vdda0v9_pmu: LDO_REG3 &#123;</span><br><span class="line">regulator-name = &quot;vdda0v9_pmu&quot;;</span><br><span class="line">regulator-always-on;</span><br><span class="line">regulator-boot-on;</span><br><span class="line">regulator-min-microvolt = &lt;900000&gt;;</span><br><span class="line">regulator-max-microvolt = &lt;900000&gt;;</span><br><span class="line"></span><br><span class="line">regulator-state-mem &#123;</span><br><span class="line">regulator-on-in-suspend;</span><br><span class="line">regulator-suspend-microvolt = &lt;900000&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vccio_acodec: LDO_REG4 &#123;</span><br><span class="line">regulator-name = &quot;vccio_acodec&quot;;</span><br><span class="line">regulator-always-on;</span><br><span class="line">regulator-boot-on;</span><br><span class="line">regulator-min-microvolt = &lt;3300000&gt;;</span><br><span class="line">regulator-max-microvolt = &lt;3300000&gt;;</span><br><span class="line"></span><br><span class="line">regulator-state-mem &#123;</span><br><span class="line">regulator-off-in-suspend;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vccio_sd: LDO_REG5 &#123;</span><br><span class="line">regulator-name = &quot;vccio_sd&quot;;</span><br><span class="line">regulator-always-on;</span><br><span class="line">regulator-boot-on;</span><br><span class="line">regulator-min-microvolt = &lt;1800000&gt;;</span><br><span class="line">regulator-max-microvolt = &lt;3300000&gt;;</span><br><span class="line"></span><br><span class="line">regulator-state-mem &#123;</span><br><span class="line">regulator-off-in-suspend;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vcc3v3_pmu: LDO_REG6 &#123;</span><br><span class="line">regulator-name = &quot;vcc3v3_pmu&quot;;</span><br><span class="line">regulator-always-on;</span><br><span class="line">regulator-boot-on;</span><br><span class="line">regulator-min-microvolt = &lt;3300000&gt;;</span><br><span class="line">regulator-max-microvolt = &lt;3300000&gt;;</span><br><span class="line"></span><br><span class="line">regulator-state-mem &#123;</span><br><span class="line">regulator-on-in-suspend;</span><br><span class="line">regulator-suspend-microvolt = &lt;3300000&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vcca_1v8: LDO_REG7 &#123;</span><br><span class="line">regulator-name = &quot;vcca_1v8&quot;;</span><br><span class="line">regulator-always-on;</span><br><span class="line">regulator-boot-on;</span><br><span class="line">regulator-min-microvolt = &lt;1800000&gt;;</span><br><span class="line">regulator-max-microvolt = &lt;1800000&gt;;</span><br><span class="line"></span><br><span class="line">regulator-state-mem &#123;</span><br><span class="line">regulator-off-in-suspend;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vcca1v8_pmu: LDO_REG8 &#123;</span><br><span class="line">regulator-name = &quot;vcca1v8_pmu&quot;;</span><br><span class="line">regulator-always-on;</span><br><span class="line">regulator-boot-on;</span><br><span class="line">regulator-min-microvolt = &lt;1800000&gt;;</span><br><span class="line">regulator-max-microvolt = &lt;1800000&gt;;</span><br><span class="line"></span><br><span class="line">regulator-state-mem &#123;</span><br><span class="line">regulator-on-in-suspend;</span><br><span class="line">regulator-suspend-microvolt = &lt;1800000&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vcca1v8_image: LDO_REG9 &#123;</span><br><span class="line">regulator-name = &quot;vcca1v8_image&quot;;</span><br><span class="line">regulator-always-on;</span><br><span class="line">regulator-boot-on;</span><br><span class="line">regulator-min-microvolt = &lt;1800000&gt;;</span><br><span class="line">regulator-max-microvolt = &lt;1800000&gt;;</span><br><span class="line"></span><br><span class="line">regulator-state-mem &#123;</span><br><span class="line">regulator-off-in-suspend;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vcc_3v3: SWITCH_REG1 &#123;</span><br><span class="line">regulator-name = &quot;vcc_3v3&quot;;</span><br><span class="line">regulator-always-on;</span><br><span class="line">regulator-boot-on;</span><br><span class="line"></span><br><span class="line">regulator-state-mem &#123;</span><br><span class="line">regulator-off-in-suspend;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vcc3v3_sd: SWITCH_REG2 &#123;</span><br><span class="line">regulator-name = &quot;vcc3v3_sd&quot;;</span><br><span class="line">regulator-always-on;</span><br><span class="line">regulator-boot-on;</span><br><span class="line"></span><br><span class="line">regulator-state-mem &#123;</span><br><span class="line">regulator-off-in-suspend;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>查找<code>rk809</code>对应的<code>compatible</code>c文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ find -name <span class="string">&quot;*.c&quot;</span> -<span class="built_in">exec</span> grep -nR <span class="string">&quot;rockchip,rk809&quot;</span> &#123;&#125; +</span><br><span class="line"></span><br><span class="line">./drivers/mfd/rk8xx-i2c.c:163:&#123; .compatible = <span class="string">&quot;rockchip,rk809&quot;</span>, .data = &amp;rk809_data &#125;,</span><br></pre></td></tr></table></figure><p>根据该目录下的<code>Makefile</code>找到对应配置选项：</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">  1 obj-<span class="variable">$(CONFIG_MFD_RK8XX)</span>         += rk8xx-core.o</span><br><span class="line">225 obj-<span class="variable">$(CONFIG_MFD_RK8XX_I2C)</span>     += rk8xx-i2c.o</span><br></pre></td></tr></table></figure><p><code>menuconfig</code>开启以下选项：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONFIG_MFD_RK8XX</span><br><span class="line">CONFIG_MFD_RK8XX_I2C</span><br></pre></td></tr></table></figure><p>重新编译内核发现还是无法检测到，经过查询发现<code>RK809</code>还有其他选项可以打开：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONFIG_RTC_RK808</span><br><span class="line">CONFIG_PINCTRL_RK805</span><br><span class="line">CONFIG_REGULATOR_RK808</span><br><span class="line">CONFIG_INPUT_RK805_PWRKEY</span><br><span class="line">CONFIG_COMMON_CLK_RK808</span><br></pre></td></tr></table></figure><p>经过启用<code>CONFIG_REGULATOR_RK808</code>选项后，可以正常检测并挂载。</p><p>没有测试<code>CONFIG_REGULATOR_RK808</code>是否依赖于其他几个选项，直接全部开启了。</p><p>ref: <a href="https://blog.csdn.net/weixin_49303682/article/details/138390797">https://blog.csdn.net/weixin_49303682/article/details/138390797</a></p>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
          <category> rockchip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> kernel </tag>
            
            <tag> rk3568 </tag>
            
            <tag> rockchip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim设置80列自动换行</title>
      <link href="/2024/07/30/vim%E8%AE%BE%E7%BD%AE80%E8%A1%8C%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C/"/>
      <url>/2024/07/30/vim%E8%AE%BE%E7%BD%AE80%E8%A1%8C%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>由于平常文件编辑并不需要该设置，但是commit的时候需要，所以记录一下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> tw=80</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rk3568刷写openharmony3.2</title>
      <link href="/2024/07/25/rk3568%E5%88%B7%E5%86%99openharmony3-2/"/>
      <url>/2024/07/25/rk3568%E5%88%B7%E5%86%99openharmony3-2/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> upgrade_tool di -p parameter.txt</span><br><span class="line"><span class="built_in">sudo</span> upgrade_tool UL MiniLoaderAll.bin -noreset</span><br><span class="line"><span class="built_in">sudo</span> upgrade_tool di -u uboot.img &amp;&amp; <span class="built_in">sudo</span> upgrade_tool di -boot_linux boot_linux.img&amp;&amp; <span class="built_in">sudo</span> upgrade_tool di -system system.img &amp;&amp; <span class="built_in">sudo</span> upgrade_tool di -vendor vendor.img &amp;&amp; <span class="built_in">sudo</span> upgrade_tool di -userdata userdata.img &amp;&amp; <span class="built_in">sudo</span> upgrade_tool di -ramdisk ramdisk.img &amp;&amp; <span class="built_in">sudo</span> upgrade_tool di -resource resource.img &amp;&amp; <span class="built_in">sudo</span> upgrade_tool di -sys-prod sys_prod.img &amp;&amp; <span class="built_in">sudo</span> upgrade_tool di -chip-prod chip_prod.img</span><br><span class="line"><span class="built_in">sudo</span> upgrade_tool rd</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
          <category> rockchip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> openHarmony </tag>
            
            <tag> kernel </tag>
            
            <tag> rk3568 </tag>
            
            <tag> rockchip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu22.04多屏闪烁问题</title>
      <link href="/2024/07/24/Ubuntu22-04%E5%A4%9A%E5%B1%8F%E9%97%AA%E7%83%81%E9%97%AE%E9%A2%98/"/>
      <url>/2024/07/24/Ubuntu22-04%E5%A4%9A%E5%B1%8F%E9%97%AA%E7%83%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>当电脑连接多个显示屏时，只要在副屏打字且光标没有悬浮在主屏幕，主屏幕就会白屏闪烁。</p><p>后续发现只有在终端和文件夹出现这个问题，想到安装了<code>Blur my shell</code>这个extension，并且指定了这两个app为模糊，在这个extension里面删掉这两个app的配置即可解决。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i2c-adpater-mainline for k1 of spacemit</title>
      <link href="/2024/07/17/i2c-adpater-mainline-for-k1-of-spacemit/"/>
      <url>/2024/07/17/i2c-adpater-mainline-for-k1-of-spacemit/</url>
      
        <content type="html"><![CDATA[<h2 id="初步完善框架"><a href="#初步完善框架" class="headerlink" title="初步完善框架"></a>初步完善框架</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mod_devicetable.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/clk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;i2c-k1x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">spacemit_k1_i2c_xfer</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapt, <span class="keyword">struct</span> i2c_msg msgs[], <span class="type">int</span> num)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spacemit_k1_i2c</span> *<span class="title">i2c</span> =</span> i2c_get_adapdata(adapt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u32 <span class="title function_">spacemit_k1_i2c_functionality</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> I2C_FUNC_I2C | (I2C_FUNC_SMBUS_EMUL &amp; ~I2C_FUNC_SMBUS_QUICK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> <span class="title">spacemit_k1_i2c_algrtm</span> =</span> &#123;</span><br><span class="line">.master_xfer= spacemit_k1_i2c_xfer,</span><br><span class="line">.functionality= spacemit_k1_i2c_functionality,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">spacemit_k1_i2c_parse_dt</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> spacemit_k1_i2c *i2c)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">dnode</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = of_property_read_u32(dnode, <span class="string">&quot;spacemit,adapter-id&quot;</span>, &amp;pdev-&gt;id);</span><br><span class="line"><span class="keyword">if</span>(ret)</span><br><span class="line">pdev-&gt;id = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">spacemit_k1_i2c_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spacemit_k1_i2c</span> *<span class="title">i2c</span>;</span></span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">i2c = devm_kzalloc(&amp;pdev-&gt;dev,</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">struct</span> spacemit_k1_i2c),</span><br><span class="line">GFP_KERNEL);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!i2c) &#123;</span><br><span class="line">ret = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> err_ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i2c-&gt;dev = &amp;pdev-&gt;dev;</span><br><span class="line">platform_set_drvdata(pdev, i2c);</span><br><span class="line"></span><br><span class="line">ret = spacemit_k1_i2c_parse_dt(pdev, i2c);</span><br><span class="line"><span class="keyword">if</span>(ret)</span><br><span class="line"><span class="keyword">goto</span> err_ret;</span><br><span class="line"></span><br><span class="line">pr_info(<span class="string">&quot;spacemit_k1_i2c_probe function: pdev-&gt;id %d\n&quot;</span>, pdev-&gt;id);</span><br><span class="line"></span><br><span class="line">i2c-&gt;adap.owner = THIS_MODULE;</span><br><span class="line">i2c-&gt;adap.algo = &amp;spacemit_k1_i2c_algrtm;</span><br><span class="line">i2c-&gt;adap.algo_data = i2c;</span><br><span class="line">i2c-&gt;adap.nr = pdev-&gt;id;</span><br><span class="line">i2c-&gt;adap.dev.parent = &amp;pdev-&gt;dev;</span><br><span class="line">i2c-&gt;adap.dev.of_node = pdev-&gt;dev.of_node;</span><br><span class="line">i2c-&gt;adap.retries= <span class="number">3</span>;</span><br><span class="line">strscpy(i2c-&gt;adap.name, <span class="string">&quot;spacemit-i2c-adapter&quot;</span>,</span><br><span class="line"><span class="keyword">sizeof</span>(i2c-&gt;adap.name));</span><br><span class="line">ret = i2c_add_numbered_adapter(&amp;i2c-&gt;adap);</span><br><span class="line"><span class="keyword">if</span>(ret) &#123;</span><br><span class="line">dev_err(i2c-&gt;dev, <span class="string">&quot;failed to add i2c adapter\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> err_ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err_ret:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">spacemit_k1_i2c_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spacemit_k1_i2c</span> *<span class="title">i2c</span>;</span></span><br><span class="line"></span><br><span class="line">pr_info(<span class="string">&quot;spacemit_k1_i2c_remove\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">i2c = platform_get_drvdata(pdev);</span><br><span class="line"></span><br><span class="line">i2c_del_adapter(&amp;i2c-&gt;adap);</span><br><span class="line"></span><br><span class="line">dev_dbg(i2c-&gt;dev, <span class="string">&quot;driver removed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">spacemit_k1_i2c_dt_match</span>[] =</span> &#123;</span><br><span class="line">&#123;</span><br><span class="line">.compatible = <span class="string">&quot;spacemit,k1x-i2c&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MODULE_DEVICE_TABLE(of, spacemit_k1_i2c_dt_match);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">spacemit_k1_i2c_driver</span> =</span> &#123;</span><br><span class="line">.probe  = spacemit_k1_i2c_probe,</span><br><span class="line">.remove = spacemit_k1_i2c_remove,</span><br><span class="line">.driver = &#123;</span><br><span class="line">.name= <span class="string">&quot;i2c-spacemit-k1x&quot;</span>,</span><br><span class="line">.of_match_table= spacemit_k1_i2c_dt_match,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module_platform_driver(spacemit_k1_i2c_driver);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;i2c driver for Spacemit k1 soc&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里选择<code>module_platform_driver</code>而不是像<code>vendor</code>版本的写法是因为我们暂时不需要注册重启<code>hook</code>。</p><p>k1写法如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">spacemit_i2c_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">register_restart_handler(&amp;spacemit_i2c_sys_nb);</span><br><span class="line"><span class="keyword">return</span> platform_driver_register(&amp;spacemit_i2c_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">spacemit_i2c_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">platform_driver_unregister(&amp;spacemit_i2c_driver);</span><br><span class="line">unregister_restart_handler(&amp;spacemit_i2c_sys_nb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subsys_initcall(spacemit_i2c_init);</span><br><span class="line">module_exit(spacemit_i2c_exit);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tmux</title>
      <link href="/2024/07/09/tmux/"/>
      <url>/2024/07/09/tmux/</url>
      
        <content type="html"><![CDATA[<h2 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h2><h3 id="进入"><a href="#进入" class="headerlink" title="进入"></a>进入</h3><ul><li><p><code>tmux</code>命令可以直接进入一个<code>session</code></p></li><li><p>创建一个名为<code>session-name</code>的会话：</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tmux new -s &lt;session-name&gt;</span><br></pre></td></tr></table></figure><ul><li>进入一个已经存在的会话<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用会话编号</span></span><br><span class="line">$ tmux attach -t 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用会话名称</span></span><br><span class="line">$ tmux attach -t &lt;session-name&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><ul><li><code>ctrl + d</code>可以直接退出</li><li><code>ctrl + b</code>后按<code>d</code>可以后台运行该会话，使用<code>attach</code>进入</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><code>tmux ls</code> 或<code>ctrl +b s</code>列出所有会话</li><li><code>tmux kill-session -t</code>销毁某个会话</li><li><code>tmux rename-session</code>或<code>ctrl+b $</code>重命名某个会话</li></ul><h2 id="窗格管理"><a href="#窗格管理" class="headerlink" title="窗格管理"></a>窗格管理</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Ctrl+b %：划分左右两个窗格。</span><br><span class="line">Ctrl+b <span class="string">&quot;：划分上下两个窗格。</span></span><br><span class="line"><span class="string">Ctrl+b &lt;arrow key&gt;：光标切换到其他窗格。&lt;arrow key&gt;是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键↓。</span></span><br><span class="line"><span class="string">Ctrl+b ;：光标切换到上一个窗格。</span></span><br><span class="line"><span class="string">Ctrl+b o：光标切换到下一个窗格。</span></span><br><span class="line"><span class="string">Ctrl+b &#123;：当前窗格与上一个窗格交换位置。</span></span><br><span class="line"><span class="string">Ctrl+b &#125;：当前窗格与下一个窗格交换位置。</span></span><br><span class="line"><span class="string">Ctrl+b Ctrl+o：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。</span></span><br><span class="line"><span class="string">Ctrl+b Alt+o：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。</span></span><br><span class="line"><span class="string">Ctrl+b x：关闭当前窗格。</span></span><br><span class="line"><span class="string">Ctrl+b !：将当前窗格拆分为一个独立窗口。</span></span><br><span class="line"><span class="string">Ctrl+b z：当前窗格全屏显示，再使用一次会变回原来大小。</span></span><br><span class="line"><span class="string">Ctrl+b Ctrl+&lt;arrow key&gt;：按箭头方向调整窗格大小。</span></span><br><span class="line"><span class="string">Ctrl+b q：显示窗格编号。</span></span><br></pre></td></tr></table></figure><h3 id="开启鼠标控制窗格"><a href="#开启鼠标控制窗格" class="headerlink" title="开启鼠标控制窗格"></a>开启鼠标控制窗格</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;set -g mouse on&#x27;</span>&gt;&gt; ~/.tmux.conf</span><br><span class="line">$ tmux source-file ~/.tmux.conf</span><br></pre></td></tr></table></figure><h2 id="窗口管理"><a href="#窗口管理" class="headerlink" title="窗口管理"></a>窗口管理</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Ctrl+b c：创建一个新窗口，状态栏会显示多个窗口的信息。</span><br><span class="line">Ctrl+b p：切换到上一个窗口（按照状态栏上的顺序）。</span><br><span class="line">Ctrl+b n：切换到下一个窗口。</span><br><span class="line">Ctrl+b &lt;number&gt;：切换到指定编号的窗口，其中的&lt;number&gt;是状态栏上的窗口编号。</span><br><span class="line">Ctrl+b w：从列表中选择窗口。</span><br><span class="line">Ctrl+b ,：窗口重命名。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内联汇编</title>
      <link href="/2024/07/05/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"/>
      <url>/2024/07/05/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<p>在c语言中使用汇编代码，为了实现更高效率或执行特定汇编指令。</p><h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;assembly code&quot;</span></span></span><br><span class="line"><span class="params">             : output operands               <span class="comment">/* 可选 */</span></span></span><br><span class="line"><span class="params">             : input operands                <span class="comment">/* 可选 */</span></span></span><br><span class="line"><span class="params">             : <span class="built_in">list</span> of clobbered registers   <span class="comment">/* 可选 */</span></span></span><br><span class="line"><span class="params">            )</span>;</span><br></pre></td></tr></table></figure><ol><li><p>asm和volatile</p><ul><li>asm 是内联汇编的关键字。</li><li>volatile 关键字告诉编译器不要优化这段汇编代码。</li></ul></li><li><p>输出操作数</p><pre><code> 格式为 :[constraints](C variable) constraints 是约束字符串，定义了输出操作数的类型和位置。(C variable)是 C 变量，用于存储汇编代码的输出。</code></pre></li><li><p>输入操作数<br>同输出操作数</p></li><li><p>列表的损坏寄存器<br>这是一个可选部分，列出了在汇编代码中被修改的寄存器，告知编译器这些寄存器在汇编代码后可能包含不同的值。</p></li></ol><p><code>e.g.</code> :</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;mv %0, %1&quot;</span> : <span class="string">&quot;=r&quot;</span>(b) : <span class="string">&quot;r&quot;</span>(a))</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中将<code>a</code>的值赋值给<code>b</code>并且打印输出了<code>b</code>的值。</p><h2 id="constraints-约束字符串"><a href="#constraints-约束字符串" class="headerlink" title="constraints 约束字符串"></a>constraints 约束字符串</h2><p>约束字符与约束字符不可以连用，但约束字符和约束修饰符可以连用。</p><h3 id="约束字符"><a href="#约束字符" class="headerlink" title="约束字符"></a>约束字符</h3><ul><li><code>r</code>表明通用寄存器，编译器可以选择任意一个通用寄存器来存储操作数。</li><li><code>m</code>表示内存地址，操作数必须是内存位置。</li><li><code>i</code>表示立即数，操作数必须是立即数。</li></ul><h3 id="约束修饰符"><a href="#约束修饰符" class="headerlink" title="约束修饰符"></a>约束修饰符</h3><ul><li><code>=</code>表示输出操作数，所操作的操作数可写。</li><li><code>+</code>表示可读可写，所操作的操作数可读可写。</li><li><code>&amp;</code>该操作数要独占相应的寄存器，不要再将其分配给别人。</li></ul><h3 id="匹配约束"><a href="#匹配约束" class="headerlink" title="匹配约束"></a>匹配约束</h3><p>匹配约束使用数字来表示操作数与另一个操作数相同，使用这个约束时，两个操作数将使用相同的寄存器或内存地址。</p><p><code>e.g.</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %0, %1&quot;</span> : <span class="string">&quot;=r&quot;</span>(a) : <span class="string">&quot;0&quot;</span>(b))</span>;</span><br></pre></td></tr></table></figure><p>在这段代码中，表示<code>a</code>和<code>b</code>使用相同的寄存器。</p><h2 id="符号名"><a href="#符号名" class="headerlink" title="符号名"></a>符号名</h2><p>在内联汇编中，可以使用别名（也称为符号名）来提高代码的可读性。别名允许你为操作数指定一个更具描述性的名称，而不是依赖数字占位符（如 %0、%1 等）。</p><p>格式如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="string">&quot;assembly code with %(alias)s&quot;</span></span></span><br><span class="line"><span class="params">    : [alias1] <span class="string">&quot;constraint&quot;</span> (variable1)</span></span><br><span class="line"><span class="params">    , [alias2] <span class="string">&quot;constraint&quot;</span> (variable2)</span></span><br><span class="line"><span class="params">    : [alias3] <span class="string">&quot;constraint&quot;</span> (variable3)</span></span><br><span class="line"><span class="params">    , [alias4] <span class="string">&quot;constraint&quot;</span> (variable4)</span></span><br><span class="line"><span class="params">    : <span class="string">&quot;clobbered registers&quot;</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>在使用时，<code>%(符号名)</code>来进行调用。</p><p><code>e.g.</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %(a), %(b)&quot;</span> : [a]<span class="string">&quot;=r&quot;</span>(a) : [b]<span class="string">&quot;0&quot;</span>(b))</span>;</span><br></pre></td></tr></table></figure><h2 id="list-of-clobbered-registers"><a href="#list-of-clobbered-registers" class="headerlink" title="list of clobbered registers"></a>list of clobbered registers</h2><p>在 GCC 内联汇编中，<code>clobbered registers</code> 列表用于告诉编译器在执行内联汇编代码时会修改哪些寄存器。编译器会确保这些寄存器的值在汇编代码执行前被保存，并在汇编代码执行后恢复。这对于避免意外的寄存器值变化和潜在的错误非常重要。</p><p><code>e.g.</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>, result;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;add %0, %1, %2\n\t&quot;</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;=r&quot;</span> (result)          <span class="comment">// 输出操作数</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;r&quot;</span> (a), <span class="string">&quot;r&quot;</span> (b)       <span class="comment">// 输入操作数</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;t0&quot;</span>                   <span class="comment">// clobbered 寄存器</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %d\n&quot;</span>, result);  <span class="comment">// 输出 result = 15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码当中，防止t0被修改（实际根本不会被修改），写入了<code>clobbered</code>寄存器当中，在执行完汇编代码之前，会保存<code>t0</code>寄存器，执行之后，会恢复<code>t0</code>寄存器。</p><h3 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h3><p>如果你在<code>clobbered</code>加入<code>memory</code>这个特殊的描述符，用于告诉编译器，汇编代码会对内存进行读写操作，可能会影响到内存中的任何数据。这会让编译器知道，它不能依赖于寄存器中的数据，并且需要在汇编代码执行前将所有变量值刷新到内存中，以及在汇编代码执行后重新加载这些变量值。</p><p>当你使用 <code>memory</code> 作为 <code>clobbered</code> 描述符时，你告诉编译器以下几点：</p><p>输入操作数和输出操作数：编译器会确保在执行汇编代码之前，将所有输入操作数的值刷新到内存中，并在执行汇编代码后，从内存中重新加载所有输出操作数的值。<br>防止优化：编译器不会对涉及内存的指令进行重排序，因为它不能确定内联汇编代码具体修改了哪些内存地址。这有助于防止潜在的优化问题。</p>]]></content>
      
      
      <categories>
          
          <category> asm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>earlycon</title>
      <link href="/2024/07/03/earlycon/"/>
      <url>/2024/07/03/earlycon/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><code>earlycon</code> 是一个早期控制台（early console）机制，用于在系统启动的早期阶段提供输出功能。在内核启动过程的早期阶段，标准的控制台设备（如串口、VGA控制台等）可能还没有初始化完成，这时可以使用 <code>earlycon</code> 来输出调试信息，帮助开发者调试内核启动过程中的问题。</p><h2 id="如何开启earlycon"><a href="#如何开启earlycon" class="headerlink" title="如何开启earlycon"></a>如何开启earlycon</h2><p>要在内核启动时启用 <code>earlycon</code>，需要在内核配置中启用几个相关的配置选项：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONFIG_SERIAL_EARLYCON</span><br><span class="line">CONFIG_OF_EARLY_FLATTREE</span><br></pre></td></tr></table></figure><p>还需要在内核命令行参数中添加相关设置。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">earlycon=pxa_serial,0xd4017000</span><br></pre></td></tr></table></figure><h2 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h2><p>在 <code>Kernel</code> 初始化汇编代码执行完跳转到 <code>start_kernel</code> 之后，<code>setup_arch</code> 调用 <code>parse_early_param</code>，进而在其中执行 <code>early_param</code> 的解析，具体如下：</p><p>start_kernel-&gt;setup_arch-&gt;parse_early_param-&gt;parse_early_options-&gt;do_early_param</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In init/main.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *command_line;</span><br><span class="line">    ...</span><br><span class="line">setup_arch(&amp;command_line);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In arch/riscv/kernel/setup.c</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">setup_arch</span><span class="params">(<span class="type">char</span> **cmdline_p)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">parse_early_param();</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In arch/riscv/kernel/setup.c</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">parse_early_param</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> done __initdata;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> tmp_cmdline[COMMAND_LINE_SIZE] __initdata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (done)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* All fall through to do_early_param. */</span></span><br><span class="line">strscpy(tmp_cmdline, boot_command_line, COMMAND_LINE_SIZE);</span><br><span class="line">parse_early_options(tmp_cmdline);</span><br><span class="line">done = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In arch/riscv/kernel/setup.c</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">parse_early_options</span><span class="params">(<span class="type">char</span> *cmdline)</span></span><br><span class="line">&#123;</span><br><span class="line">parse_args(<span class="string">&quot;early options&quot;</span>, cmdline, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>,</span><br><span class="line">   do_early_param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里看到有一个<code>parse_args</code>函数，其函数目的是<code>解析键值</code>对参数并将键值对作为参数<code>执行</code>最后一个参数写入的函数指针。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In kernel/params.c</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">parse_args</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *doing,</span></span><br><span class="line"><span class="params"> <span class="type">char</span> *args,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="keyword">struct</span> kernel_param *params,</span></span><br><span class="line"><span class="params"> <span class="type">unsigned</span> num,</span></span><br><span class="line"><span class="params"> s16 min_level,</span></span><br><span class="line"><span class="params"> s16 max_level,</span></span><br><span class="line"><span class="params"> <span class="type">void</span> *arg, parse_unknown_fn unknown)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *param, *val, *err = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Chew leading spaces */</span></span><br><span class="line">args = skip_spaces(args);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*args)</span><br><span class="line">pr_debug(<span class="string">&quot;doing %s, parsing ARGS: &#x27;%s&#x27;\n&quot;</span>, doing, args);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (*args) &#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">int</span> irq_was_disabled;</span><br><span class="line"></span><br><span class="line">args = next_arg(args, &amp;param, &amp;val);</span><br><span class="line"><span class="comment">/* Stop at -- */</span></span><br><span class="line"><span class="keyword">if</span> (!val &amp;&amp; <span class="built_in">strcmp</span>(param, <span class="string">&quot;--&quot;</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err ?: args;</span><br><span class="line">irq_was_disabled = irqs_disabled();</span><br><span class="line">ret = parse_one(param, val, doing, params, num,</span><br><span class="line">min_level, max_level, arg, unknown);</span><br><span class="line"><span class="keyword">if</span> (irq_was_disabled &amp;&amp; !irqs_disabled())</span><br><span class="line">pr_warn(<span class="string">&quot;%s: option &#x27;%s&#x27; enabled irq&#x27;s!\n&quot;</span>,</span><br><span class="line">doing, param);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (ret) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">case</span> -ENOENT:</span><br><span class="line">pr_err(<span class="string">&quot;%s: Unknown parameter `%s&#x27;\n&quot;</span>, doing, param);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> -ENOSPC:</span><br><span class="line">pr_err(<span class="string">&quot;%s: `%s&#x27; too large for parameter `%s&#x27;\n&quot;</span>,</span><br><span class="line">       doing, val ?: <span class="string">&quot;&quot;</span>, param);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">pr_err(<span class="string">&quot;%s: `%s&#x27; invalid for parameter `%s&#x27;\n&quot;</span>,</span><br><span class="line">       doing, val ?: <span class="string">&quot;&quot;</span>, param);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = ERR_PTR(ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In arch/riscv/kernel/setup.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">do_early_param</span><span class="params">(<span class="type">char</span> *param, <span class="type">char</span> *val,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">char</span> *unused, <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">obs_kernel_param</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (p = __setup_start; p &lt; __setup_end; p++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((p-&gt;early &amp;&amp; parameq(param, p-&gt;str)) ||</span><br><span class="line">    (<span class="built_in">strcmp</span>(param, <span class="string">&quot;console&quot;</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">     <span class="built_in">strcmp</span>(p-&gt;str, <span class="string">&quot;earlycon&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">) &#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;setup_func(val) != <span class="number">0</span>)</span><br><span class="line">pr_warn(<span class="string">&quot;Malformed early option &#x27;%s&#x27;\n&quot;</span>, param);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* We accept everything at this stage. */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__setup_start</code>和<code>__setup_end</code>变量在<code>arch/riscv/kernel/vmlinux.lds</code>中可以查找到相关定义，他们是<code>.init.setup</code>段的开始地址和结束地址：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.init.data : AT(ADDR(.init.data) - ((((-1))) - 0x80000000 + 1)) &#123;</span><br><span class="line">    ... </span><br><span class="line">    __setup_start = .; KEEP(*(.init.setup)) __setup_end = .;  </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>__setup_start</code>和<code>__setup_end</code>都属于<code>.init.setup</code>段，经过搜索在<code>include/linux/init.h</code>发现有宏定义可以将函数放入该段：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Only for really core code.  See moduleparam.h for the normal way.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Force the alignment so the compiler doesn&#x27;t space elements of the</span></span><br><span class="line"><span class="comment"> * obs_kernel_param &quot;array&quot; too far apart in .init.setup.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __setup_param(str, unique_id, fn, early)\</span></span><br><span class="line"><span class="meta">static const char __setup_str_##unique_id[] __initconst\</span></span><br><span class="line"><span class="meta">__aligned(1) = str; \</span></span><br><span class="line"><span class="meta">static struct obs_kernel_param __setup_##unique_id\</span></span><br><span class="line"><span class="meta">__used __section(<span class="string">&quot;.init.setup&quot;</span>)\</span></span><br><span class="line"><span class="meta">__aligned(__alignof__(struct obs_kernel_param))\</span></span><br><span class="line"><span class="meta">= &#123; __setup_str_##unique_id, fn, early &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> __setup functions return values:</span></span><br><span class="line"><span class="comment"> * @fn returns 1 (or non-zero) if the option argument is &quot;handled&quot;</span></span><br><span class="line"><span class="comment"> * and returns 0 if the option argument is &quot;not handled&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __setup(str, fn)\</span></span><br><span class="line"><span class="meta">__setup_param(str, fn, fn, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> @fn is as per module_param, not __setup!</span></span><br><span class="line"><span class="comment"> * I.e., @fn returns 0 for no error or non-zero for error</span></span><br><span class="line"><span class="comment"> * (possibly @fn returns a -errno value, but it does not matter).</span></span><br><span class="line"><span class="comment"> * Emits warning if @fn returns non-zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> early_param(str, fn)\</span></span><br><span class="line"><span class="meta">__setup_param(str, fn, fn, 1)</span></span><br></pre></td></tr></table></figure><p>通过以上代码不难看出，<code>__setup_param</code>宏定义被<code>__setup</code>和<code>early_param</code>两个宏调用，具体区别就是<code>early</code>宏参数是<code>0</code>还是<code>1</code>。</p><p>在<code>do_early_param</code>函数中，如果<code>early</code>不是<code>1</code>的话就不会在<code>early</code>阶段解析，具体在哪个阶段不是本章的范畴，那么看来我们只关心<code>early_param</code>这个宏定义即可。</p><p><code>e.g. early_param(&quot;earlycon&quot;, earlycon_func)</code> </p><p>将<code>early_param</code>一步步展开得到如下结论：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   early_param(<span class="string">&quot;earlycon&quot;</span>, earlycon_func) </span><br><span class="line">   -&gt;</span><br><span class="line">__setup_param(<span class="string">&quot;earlycon&quot;</span>, earlycon_func, earlycon_func, <span class="number">1</span>)  </span><br><span class="line">   -&gt;</span><br><span class="line">   <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> __setup_str_earlycon_func[] __initconst\</span><br><span class="line">__aligned(<span class="number">1</span>) = <span class="string">&quot;earlycon&quot;</span>; \</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">obs_kernel_param</span> __<span class="title">setup_earlycon_func</span>\</span></span><br><span class="line"><span class="class">__<span class="title">used</span> __<span class="title">section</span>(&quot;.<span class="title">init</span>.<span class="title">setup</span>&quot;)\</span></span><br><span class="line"><span class="class">__<span class="title">aligned</span>(__<span class="title">alignof__</span>(<span class="keyword">struct</span> <span class="title">obs_kernel_param</span>))\</span></span><br><span class="line"><span class="class">=</span> &#123; __setup_str_earlycon_func, earlycon_func, <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><p>经过上面推导展开不难发现，其本质就是声明了一个结构体，结构体类型是<code>struct obs_kernel_param</code>，并且在该结构体定义的地方，还导出了<code>lds文件</code>中定义的<code>__setup_start</code>和<code>__setup_end</code>变量。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//In include/linux/init.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">obs_kernel_param</span> &#123;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *str;</span><br><span class="line"><span class="type">int</span> (*setup_func)(<span class="type">char</span> *);</span><br><span class="line"><span class="type">int</span> early;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">obs_kernel_param</span> __<span class="title">setup_start</span>[], __<span class="title">setup_end</span>[];</span></span><br></pre></td></tr></table></figure><p>通过搜索找到在<code>drivers/tty/serial/earlycon.c</code>文件中有调用到<code>early_param</code>这个宏定义：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* early_param wrapper for setup_earlycon() */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">param_setup_earlycon</span><span class="params">(<span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Just &#x27;earlycon&#x27; is a valid param for devicetree and ACPI SPCR. */</span></span><br><span class="line"><span class="keyword">if</span> (!buf || !buf[<span class="number">0</span>]) &#123;</span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_ACPI_SPCR_TABLE)) &#123;</span><br><span class="line">earlycon_acpi_spcr_enable = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!buf) &#123;</span><br><span class="line"><span class="keyword">return</span> early_init_dt_scan_chosen_stdout();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = setup_earlycon(buf);</span><br><span class="line"><span class="keyword">if</span> (err == -ENOENT || err == -EALREADY)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">early_param(<span class="string">&quot;earlycon&quot;</span>, param_setup_earlycon);</span><br></pre></td></tr></table></figure><p>这里就是将<code>param_setup_early</code>这个函数作为结构体的<code>setup_func</code>成员的值，并且将这个结构体加入<code>.init.setup</code>段，也就是在<code>__setup_start</code>和<code>__setup_end</code>地址中间，其中涉及到的名为<code>param_setup_earlycon</code>的函数，这个留作后话。</p><h3 id="do-early-param"><a href="#do-early-param" class="headerlink" title="do_early_param"></a>do_early_param</h3><p>经过一系列的追查，我们终于可以开始分析<code>do_early_param</code>，再回顾一下代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In arch/riscv/kernel/setup.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">do_early_param</span><span class="params">(<span class="type">char</span> *param, <span class="type">char</span> *val,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">char</span> *unused, <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">obs_kernel_param</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (p = __setup_start; p &lt; __setup_end; p++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((p-&gt;early &amp;&amp; parameq(param, p-&gt;str)) ||</span><br><span class="line">    (<span class="built_in">strcmp</span>(param, <span class="string">&quot;console&quot;</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">     <span class="built_in">strcmp</span>(p-&gt;str, <span class="string">&quot;earlycon&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">) &#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;setup_func(val) != <span class="number">0</span>)</span><br><span class="line">pr_warn(<span class="string">&quot;Malformed early option &#x27;%s&#x27;\n&quot;</span>, param);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* We accept everything at this stage. */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现这里定义了一个名为p的指针，类型就是刚刚我们看的<code>obs_kernel_param</code>，同时<code>earlycon.c</code>中声明的结构体也是这个类型，由于<code>early_param</code>或者<code>__setup</code>宏能够将结构体加入<code>__setup_start</code>和<code>__setup_end</code>中间的<code>.init.setup段</code>中，所以我们只需要将<code>p指针</code>指向<code>__setup_start</code>，然后开始遍历，即可获取到在该段中的每一个结构体。</p><p>这里判断<code>early</code>是否为<code>1</code>，也就是只有通过<code>early_param宏</code>声明的结构体才可以在这里被展开继续执行，<code>__setup</code>的并不可以。</p><p><code>parameq</code>函数是判断两个字符串是否相等，并且把<code>-</code>替换成<code>_</code>去比较的，具体代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> <span class="title function_">dash2underscore</span><span class="params">(<span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;_&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">parameqn</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a, <span class="type">const</span> <span class="type">char</span> *b, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (dash2underscore(a[i]) != dash2underscore(b[i]))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">parameq</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a, <span class="type">const</span> <span class="type">char</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> parameqn(a, b, <span class="built_in">strlen</span>(a)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果判断字符串相等或者<code>param</code>为<code>console</code>并且<code>p-&gt;str</code>为<code>earlycon</code>就可以执行<code>setup_func</code>函数，参数是<code>val</code>。</p><h3 id="param-setup-earlycon"><a href="#param-setup-earlycon" class="headerlink" title="param_setup_earlycon"></a>param_setup_earlycon</h3><p>经过了上面的执行，我们应该执行到了<code>setup</code>函数，也就是<code>param_setup_earlycon</code>函数，函数实体如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* early_param wrapper for setup_earlycon() */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">param_setup_earlycon</span><span class="params">(<span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Just &#x27;earlycon&#x27; is a valid param for devicetree and ACPI SPCR. */</span></span><br><span class="line"><span class="keyword">if</span> (!buf || !buf[<span class="number">0</span>]) &#123;</span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_ACPI_SPCR_TABLE)) &#123;</span><br><span class="line">earlycon_acpi_spcr_enable = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!buf) &#123;</span><br><span class="line"><span class="keyword">return</span> early_init_dt_scan_chosen_stdout();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = setup_earlycon(buf);</span><br><span class="line"><span class="keyword">if</span> (err == -ENOENT || err == -EALREADY)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难看出这就是一个包装函数，用来包装两种处理方式，一种是通过<code>boot command line</code>来获取<code>earlycon</code>的配置，一种是通过<code>device tree</code>来获取配置。</p><p>在if判断中判断是否buf为野指针或者buf为空，如果是的话判断<code>CONFIG_ACPI_SPCR_TABLE</code>这个宏定义是否开启，如果没开启的话就去搜索<code>设备树</code>。否则通过<code>setup_earlycon</code>来进行初始化。</p><h2 id="通过setup-earlycon初始化"><a href="#通过setup-earlycon初始化" class="headerlink" title="通过setup_earlycon初始化"></a>通过setup_earlycon初始化</h2><p><code>setup_earlycon</code>函数实体如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *setup_earlycon - match and register earlycon console</span></span><br><span class="line"><span class="comment"> *@buf:earlycon param string</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *Registers the earlycon console matching the earlycon specified</span></span><br><span class="line"><span class="comment"> *in the param string @buf. Acceptable param strings are of the form</span></span><br><span class="line"><span class="comment"> *   &lt;name&gt;,io|mmio|mmio32|mmio32be,&lt;addr&gt;,&lt;options&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;name&gt;,0x&lt;addr&gt;,&lt;options&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;name&gt;,&lt;options&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;name&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *Only for the third form does the earlycon setup() method receive the</span></span><br><span class="line"><span class="comment"> *&lt;options&gt; string in the &#x27;options&#x27; parameter; all other forms set</span></span><br><span class="line"><span class="comment"> *the parameter to NULL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *Returns 0 if an attempt to register the earlycon was made,</span></span><br><span class="line"><span class="comment"> *otherwise negative error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> __init <span class="title function_">setup_earlycon</span><span class="params">(<span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">earlycon_id</span> *<span class="title">match</span>;</span></span><br><span class="line"><span class="type">bool</span> empty_compatible = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!buf || !buf[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (console_is_registered(&amp;early_con))</span><br><span class="line"><span class="keyword">return</span> -EALREADY;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line"><span class="keyword">for</span> (match = __earlycon_table; match &lt; __earlycon_table_end; match++) &#123;</span><br><span class="line"><span class="type">size_t</span> len = <span class="built_in">strlen</span>(match-&gt;name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(buf, match-&gt;name, len))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* prefer entries with empty compatible */</span></span><br><span class="line"><span class="keyword">if</span> (empty_compatible &amp;&amp; *match-&gt;compatible)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (buf[len]) &#123;</span><br><span class="line"><span class="keyword">if</span> (buf[len] != <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">buf += len + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">buf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> register_earlycon(buf, match);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (empty_compatible) &#123;</span><br><span class="line">empty_compatible = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -ENOENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对<code>buf</code>进行了检验并且检查了<code>early_con</code>的<code>console</code>是否已经注册过了。<br>随后使用match变量进行遍历，这其中以<code>__earlycon_table</code>地址开始，以<code>__earlycon_table_end</code>地址结束。</p><p><code>__earlycon_table</code>和<code>__earlycon_table_end</code>变量在<code>arch/riscv/kernel/vmlinux.lds</code>中可以查找到相关定义，他们是<code>__earlycon_table</code>段的开始和结束地址：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> .init.data : AT(ADDR(.init.data) - ((((-1))) - 0x80000000 + 1)) </span><br><span class="line">&#123;  </span><br><span class="line">    __earlycon_table = .; KEEP(*(__earlycon_table)) __earlycon_table_end = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过搜索发现这两个宏可将内容定义到这个段当中，具体代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OF_EARLYCON_DECLARE(_name, compat, fn)\</span></span><br><span class="line"><span class="meta">static const struct earlycon_id __UNIQUE_ID(__earlycon_##_name) \</span></span><br><span class="line"><span class="meta">EARLYCON_USED_OR_UNUSED  __section(<span class="string">&quot;__earlycon_table&quot;</span>)  \</span></span><br><span class="line"><span class="meta">__aligned(__alignof__(struct earlycon_id))\</span></span><br><span class="line"><span class="meta">= &#123; .name = __stringify(_name),\</span></span><br><span class="line"><span class="meta">    .compatible = compat,\</span></span><br><span class="line"><span class="meta">    .setup = fn &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EARLYCON_DECLARE(_name, fn)OF_EARLYCON_DECLARE(_name, <span class="string">&quot;&quot;</span>, fn)</span></span><br></pre></td></tr></table></figure><p>第一个宏定义<code>OF_EARLYCON_DECLARE</code>是用于设备树的<br>    - <code>_name</code>: 名字，不应该有双引号<br>    - <code>compat</code>: 与设备树的compatible相对应，用于匹配，应有双引号<br>    - <code>fn</code>: 执行函数，即匹配到后执行的函数</p><p>第二个宏定义<code>EARLYCON_DECLARE</code>是用于非设备树的版本的，参数定义与<code>OF_EARLYCON_DECLARE</code>相同，只不过将compat设置为了空字符串也就是<code>\0</code>。</p><p>拿<code>bpi-f3</code>为例，其在<code>drivers/tty/serial/pxa_k1x.c</code>中有如下定义：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Support for earlycon */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pxa_early_write</span><span class="params">(<span class="keyword">struct</span> console *con, <span class="type">const</span> <span class="type">char</span> *s,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">earlycon_device</span> *<span class="title">dev</span> =</span> con-&gt;data;</span><br><span class="line"></span><br><span class="line">   uart_console_write(&amp;dev-&gt;port, s, n, serial_pxa_console_putchar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">pxa_early_console_setup</span><span class="params">(<span class="keyword">struct</span> earlycon_device *device, <span class="type">const</span> <span class="type">char</span> *opt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!device-&gt;port.membase) &#123;</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">device-&gt;con-&gt;write = pxa_early_write;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EARLYCON_DECLARE(pxa_serial, pxa_early_console_setup);</span><br></pre></td></tr></table></figure><p>这部分代码将<code>pxa_serial</code>, <code>&quot;&quot;</code>, <code>pxa_early_console_setup</code>依次定义成结构体。</p><p><code>earlycon_id</code>的成员并且放在__earlycon_table段当中，<code>earlycon_id</code>结构体定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">earlycon_id</span> &#123;</span></span><br><span class="line"><span class="type">char</span>name[<span class="number">15</span>];</span><br><span class="line"><span class="type">char</span>name_term;<span class="comment">/* In case compiler didn&#x27;t &#x27;\0&#x27; term name */</span></span><br><span class="line"><span class="type">char</span>compatible[<span class="number">128</span>];</span><br><span class="line"><span class="type">int</span>(*setup)(<span class="keyword">struct</span> earlycon_device *, <span class="type">const</span> <span class="type">char</span> *options);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中, <code>name_term</code>成员是为了<code>name</code>字符串以<code>\0</code>为结尾。</p><p>继续回到<code>setup_earlycon</code>函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *setup_earlycon - match and register earlycon console</span></span><br><span class="line"><span class="comment"> *@buf:earlycon param string</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *Registers the earlycon console matching the earlycon specified</span></span><br><span class="line"><span class="comment"> *in the param string @buf. Acceptable param strings are of the form</span></span><br><span class="line"><span class="comment"> *   &lt;name&gt;,io|mmio|mmio32|mmio32be,&lt;addr&gt;,&lt;options&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;name&gt;,0x&lt;addr&gt;,&lt;options&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;name&gt;,&lt;options&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;name&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *Only for the third form does the earlycon setup() method receive the</span></span><br><span class="line"><span class="comment"> *&lt;options&gt; string in the &#x27;options&#x27; parameter; all other forms set</span></span><br><span class="line"><span class="comment"> *the parameter to NULL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *Returns 0 if an attempt to register the earlycon was made,</span></span><br><span class="line"><span class="comment"> *otherwise negative error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> __init <span class="title function_">setup_earlycon</span><span class="params">(<span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">earlycon_id</span> *<span class="title">match</span>;</span></span><br><span class="line"><span class="type">bool</span> empty_compatible = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!buf || !buf[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (console_is_registered(&amp;early_con))</span><br><span class="line"><span class="keyword">return</span> -EALREADY;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line"><span class="keyword">for</span> (match = __earlycon_table; match &lt; __earlycon_table_end; match++) &#123;</span><br><span class="line"><span class="type">size_t</span> len = <span class="built_in">strlen</span>(match-&gt;name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(buf, match-&gt;name, len))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* prefer entries with empty compatible */</span></span><br><span class="line"><span class="keyword">if</span> (empty_compatible &amp;&amp; *match-&gt;compatible)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (buf[len]) &#123;</span><br><span class="line"><span class="keyword">if</span> (buf[len] != <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">buf += len + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">buf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> register_earlycon(buf, match);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (empty_compatible) &#123;</span><br><span class="line">empty_compatible = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -ENOENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里比较<code>buf</code>与每一个在<code>__earlycon_table</code>段中的<code>earlycon_id</code>结构体的<code>name</code>是否匹配。</p><p>在匹配之后比较每一个在<code>__earlycon_table</code>段中的<code>earlycon_id</code>结构体的<code>compatible</code>是否不为<code>空</code>。</p><p>随后进行判断是否有<code>,</code>存在，如果有<code>,</code>存在，就会跳过前面的内容，否则则设置为<code>NULL</code>。</p><p>e.g. :</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buf=&quot;pxa_serial,0xd4017000&quot;</span><br><span class="line">    -&gt;</span><br><span class="line">        buf=&quot;0xd4017000&quot;</span><br></pre></td></tr></table></figure><p>最后通过<code>register_earlycon</code>函数进行注册：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">register_earlycon</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="keyword">struct</span> earlycon_id *match)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_port</span> *<span class="title">port</span> =</span> &amp;early_console_dev.port;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* On parsing error, pass the options buf to the setup function */</span></span><br><span class="line"><span class="keyword">if</span> (buf &amp;&amp; !parse_options(&amp;early_console_dev, buf))</span><br><span class="line">buf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">spin_lock_init(&amp;port-&gt;lock);</span><br><span class="line"><span class="keyword">if</span> (!port-&gt;uartclk)</span><br><span class="line">port-&gt;uartclk = BASE_BAUD * <span class="number">16</span>;</span><br><span class="line"><span class="keyword">if</span> (port-&gt;mapbase)</span><br><span class="line">port-&gt;membase = earlycon_map(port-&gt;mapbase, <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">earlycon_init(&amp;early_console_dev, match-&gt;name);</span><br><span class="line">err = match-&gt;setup(&amp;early_console_dev, buf);</span><br><span class="line">earlycon_print_info(&amp;early_console_dev);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"><span class="keyword">if</span> (!early_console_dev.con-&gt;write)</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">register_console(early_console_dev.con);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>parse_options</code>解析参数值：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//In drivers/tty/serial/earlycon.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">parse_options</span><span class="params">(<span class="keyword">struct</span> earlycon_device *device, <span class="type">char</span> *options)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_port</span> *<span class="title">port</span> =</span> &amp;device-&gt;port;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line"><span class="type">resource_size_t</span> addr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (uart_parse_earlycon(options, &amp;port-&gt;iotype, &amp;addr, &amp;options))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (port-&gt;iotype) &#123;</span><br><span class="line"><span class="keyword">case</span> UPIO_MEM:</span><br><span class="line">port-&gt;mapbase = addr;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> UPIO_MEM16:</span><br><span class="line">port-&gt;regshift = <span class="number">1</span>;</span><br><span class="line">port-&gt;mapbase = addr;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> UPIO_MEM32:</span><br><span class="line"><span class="keyword">case</span> UPIO_MEM32BE:</span><br><span class="line">port-&gt;regshift = <span class="number">2</span>;</span><br><span class="line">port-&gt;mapbase = addr;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> UPIO_PORT:</span><br><span class="line">port-&gt;iobase = addr;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (options) &#123;</span><br><span class="line"><span class="type">char</span> *uartclk;</span><br><span class="line"></span><br><span class="line">device-&gt;baud = simple_strtoul(options, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">uartclk = <span class="built_in">strchr</span>(options, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (uartclk &amp;&amp; kstrtouint(uartclk + <span class="number">1</span>, <span class="number">0</span>, &amp;port-&gt;uartclk) &lt; <span class="number">0</span>)</span><br><span class="line">pr_warn(<span class="string">&quot;[%s] unsupported earlycon uart clkrate option\n&quot;</span>,</span><br><span class="line">options);</span><br><span class="line">length = min(<span class="built_in">strcspn</span>(options, <span class="string">&quot; &quot;</span>) + <span class="number">1</span>,</span><br><span class="line">     (<span class="type">size_t</span>)(<span class="keyword">sizeof</span>(device-&gt;options)));</span><br><span class="line">strscpy(device-&gt;options, options, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>uart_parse_earlycon</code>函数解析传入参数<code>options</code>，也就是<code>buf</code>，<code>buf</code>指针现在指向<code>0xd4017000</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In drivers/tty/serial/serial_core.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * uart_parse_earlycon - Parse earlycon options</span></span><br><span class="line"><span class="comment"> * @p:     ptr to 2nd field (ie., just beyond &#x27;&lt;name&gt;,&#x27;)</span></span><br><span class="line"><span class="comment"> * @iotype:  ptr for decoded iotype (out)</span></span><br><span class="line"><span class="comment"> * @addr:    ptr for decoded mapbase/iobase (out)</span></span><br><span class="line"><span class="comment"> * @options: ptr for &lt;options&gt; field; %NULL if not present (out)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Decodes earlycon kernel command line parameters of the form:</span></span><br><span class="line"><span class="comment"> *  * earlycon=&lt;name&gt;,io|mmio|mmio16|mmio32|mmio32be|mmio32native,&lt;addr&gt;,&lt;options&gt;</span></span><br><span class="line"><span class="comment"> *  * console=&lt;name&gt;,io|mmio|mmio16|mmio32|mmio32be|mmio32native,&lt;addr&gt;,&lt;options&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The optional form:</span></span><br><span class="line"><span class="comment"> *  * earlycon=&lt;name&gt;,0x&lt;addr&gt;,&lt;options&gt;</span></span><br><span class="line"><span class="comment"> *  * console=&lt;name&gt;,0x&lt;addr&gt;,&lt;options&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * is also accepted; the returned @iotype will be %UPIO_MEM.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns: 0 on success or -%EINVAL on failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">uart_parse_earlycon</span><span class="params">(<span class="type">char</span> *p, <span class="type">unsigned</span> <span class="type">char</span> *iotype, <span class="type">resource_size_t</span> *addr,</span></span><br><span class="line"><span class="params"><span class="type">char</span> **options)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(p, <span class="string">&quot;mmio,&quot;</span>, <span class="number">5</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">*iotype = UPIO_MEM;</span><br><span class="line">p += <span class="number">5</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(p, <span class="string">&quot;mmio16,&quot;</span>, <span class="number">7</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">*iotype = UPIO_MEM16;</span><br><span class="line">p += <span class="number">7</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(p, <span class="string">&quot;mmio32,&quot;</span>, <span class="number">7</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">*iotype = UPIO_MEM32;</span><br><span class="line">p += <span class="number">7</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(p, <span class="string">&quot;mmio32be,&quot;</span>, <span class="number">9</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">*iotype = UPIO_MEM32BE;</span><br><span class="line">p += <span class="number">9</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(p, <span class="string">&quot;mmio32native,&quot;</span>, <span class="number">13</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">*iotype = IS_ENABLED(CONFIG_CPU_BIG_ENDIAN) ?</span><br><span class="line">UPIO_MEM32BE : UPIO_MEM32;</span><br><span class="line">p += <span class="number">13</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(p, <span class="string">&quot;io,&quot;</span>, <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">*iotype = UPIO_PORT;</span><br><span class="line">p += <span class="number">3</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(p, <span class="string">&quot;0x&quot;</span>, <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">*iotype = UPIO_MEM;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Before you replace it with kstrtoull(), think about options separator</span></span><br><span class="line"><span class="comment"> * (&#x27;,&#x27;) it will not tolerate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">*addr = simple_strtoull(p, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">p = <span class="built_in">strchr</span>(p, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (p)</span><br><span class="line">p++;</span><br><span class="line"></span><br><span class="line">*options = p;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难看出这里在对<code>io类型</code>进行判断，我们<code>buf</code>指向的内容是<code>0xd4017000</code>，所以这里<code>iotype</code>被设置为了<code>UPIO_MEM</code>。</p><p>通过<code>simple_strtoull</code>函数将字符串转为数字，此时<code>addr</code>应该为<code>0xd4017000</code>。</p><p><code>strchr</code>函数找出是否有额外选项，如果有额外选项，则将额外选项开始的字符串地址赋值给<code>options</code>指针，这里我们并没有，所以应该指向了<code>NULL</code>。</p><p>回到<code>parse_options</code>函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//In drivers/tty/serial/earlycon.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">parse_options</span><span class="params">(<span class="keyword">struct</span> earlycon_device *device, <span class="type">char</span> *options)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_port</span> *<span class="title">port</span> =</span> &amp;device-&gt;port;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line"><span class="type">resource_size_t</span> addr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (uart_parse_earlycon(options, &amp;port-&gt;iotype, &amp;addr, &amp;options))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (port-&gt;iotype) &#123;</span><br><span class="line"><span class="keyword">case</span> UPIO_MEM:</span><br><span class="line">port-&gt;mapbase = addr;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> UPIO_MEM16:</span><br><span class="line">port-&gt;regshift = <span class="number">1</span>;</span><br><span class="line">port-&gt;mapbase = addr;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> UPIO_MEM32:</span><br><span class="line"><span class="keyword">case</span> UPIO_MEM32BE:</span><br><span class="line">port-&gt;regshift = <span class="number">2</span>;</span><br><span class="line">port-&gt;mapbase = addr;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> UPIO_PORT:</span><br><span class="line">port-&gt;iobase = addr;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (options) &#123;</span><br><span class="line"><span class="type">char</span> *uartclk;</span><br><span class="line"></span><br><span class="line">device-&gt;baud = simple_strtoul(options, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">uartclk = <span class="built_in">strchr</span>(options, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (uartclk &amp;&amp; kstrtouint(uartclk + <span class="number">1</span>, <span class="number">0</span>, &amp;port-&gt;uartclk) &lt; <span class="number">0</span>)</span><br><span class="line">pr_warn(<span class="string">&quot;[%s] unsupported earlycon uart clkrate option\n&quot;</span>,</span><br><span class="line">options);</span><br><span class="line">length = min(<span class="built_in">strcspn</span>(options, <span class="string">&quot; &quot;</span>) + <span class="number">1</span>,</span><br><span class="line">     (<span class="type">size_t</span>)(<span class="keyword">sizeof</span>(device-&gt;options)));</span><br><span class="line">strscpy(device-&gt;options, options, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过以上的步骤，<code>port-&gt;iotype</code>的类型应该被设置成了<code>UPIO_MEM</code>，所以将<code>port-&gt;mapbase</code>设置成了<code>addr</code>。</p><p><code>if</code>判断<code>options</code>指针是否为空，也就是是否有额外选项。</p><p>回到<code>register_earlycon</code>函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">register_earlycon</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="keyword">struct</span> earlycon_id *match)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_port</span> *<span class="title">port</span> =</span> &amp;early_console_dev.port;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* On parsing error, pass the options buf to the setup function */</span></span><br><span class="line"><span class="keyword">if</span> (buf &amp;&amp; !parse_options(&amp;early_console_dev, buf))</span><br><span class="line">buf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">spin_lock_init(&amp;port-&gt;lock);</span><br><span class="line"><span class="keyword">if</span> (!port-&gt;uartclk)</span><br><span class="line">port-&gt;uartclk = BASE_BAUD * <span class="number">16</span>;</span><br><span class="line"><span class="keyword">if</span> (port-&gt;mapbase)</span><br><span class="line">port-&gt;membase = earlycon_map(port-&gt;mapbase, <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">earlycon_init(&amp;early_console_dev, match-&gt;name);</span><br><span class="line">err = match-&gt;setup(&amp;early_console_dev, buf);</span><br><span class="line">earlycon_print_info(&amp;early_console_dev);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"><span class="keyword">if</span> (!early_console_dev.con-&gt;write)</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">register_console(early_console_dev.con);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>parse_options</code>函数执行后，<code>mapbase</code>, <code>iotype</code>都已经被设置好，但由于我们没有<code>options</code>选项，所以<code>uartclk</code>是没有被设置的，可以看到如果这里没有被设置的话，在这里就会被手动设置为<code>BASE_BAUD * 16</code>。</p><p><code>mapbase</code>也就是串口寄存器地址的地址我们现在已经拿到了，但是这是个物理地址，所以要通过<code>earlycon_map</code>函数映射进入页表，随后返回虚拟地址赋值给<code>membase</code>。</p><p>调用<code>earlycon_init</code>函数进行赋值，随后调用<code>match-&gt;setup</code>函数，也就是通过<code>EARLYCON_DECALRE</code>宏声明的函数<code>pxa_early_console_setup</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">pxa_early_console_setup</span><span class="params">(<span class="keyword">struct</span> earlycon_device *device, <span class="type">const</span> <span class="type">char</span> *opt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!device-&gt;port.membase) &#123;</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">device-&gt;con-&gt;write = pxa_early_write;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EARLYCON_DECLARE(pxa_serial, pxa_early_console_setup);</span><br></pre></td></tr></table></figure><p>可以看到这个函数就是判断<code>membase</code>也就是虚拟地址是否映射成功，并且设置了<code>write</code>函数为<code>pxa_early_write</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Support for earlycon */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pxa_early_write</span><span class="params">(<span class="keyword">struct</span> console *con, <span class="type">const</span> <span class="type">char</span> *s,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">earlycon_device</span> *<span class="title">dev</span> =</span> con-&gt;data;</span><br><span class="line"></span><br><span class="line">   uart_console_write(&amp;dev-&gt;port, s, n, serial_pxa_console_putchar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过early-init-dt-scan-chosen-stdout初始化"><a href="#通过early-init-dt-scan-chosen-stdout初始化" class="headerlink" title="通过early_init_dt_scan_chosen_stdout初始化"></a>通过early_init_dt_scan_chosen_stdout初始化</h2><h4 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In drivers/of/fdt.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SERIAL_EARLYCON</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __init <span class="title function_">early_init_dt_scan_chosen_stdout</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> offset;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *p, *q, *options = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> l;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">earlycon_id</span> *<span class="title">match</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">void</span> *fdt = initial_boot_params;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">offset = fdt_path_offset(fdt, <span class="string">&quot;/chosen&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (offset &lt; <span class="number">0</span>)</span><br><span class="line">offset = fdt_path_offset(fdt, <span class="string">&quot;/chosen@0&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (offset &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line">p = fdt_getprop(fdt, offset, <span class="string">&quot;stdout-path&quot;</span>, &amp;l);</span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line">p = fdt_getprop(fdt, offset, <span class="string">&quot;linux,stdout-path&quot;</span>, &amp;l);</span><br><span class="line"><span class="keyword">if</span> (!p || !l)</span><br><span class="line"><span class="keyword">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line">q = strchrnul(p, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (*q != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">options = q + <span class="number">1</span>;</span><br><span class="line">l = q - p;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the node specified by stdout-path */</span></span><br><span class="line">offset = fdt_path_offset_namelen(fdt, p, l);</span><br><span class="line"><span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">pr_warn(<span class="string">&quot;earlycon: stdout-path %.*s not found\n&quot;</span>, l, p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (match = __earlycon_table; match &lt; __earlycon_table_end; match++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!match-&gt;compatible[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fdt_node_check_compatible(fdt, offset, match-&gt;compatible))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">ret = of_setup_earlycon(match, offset, options);</span><br><span class="line"><span class="keyword">if</span> (!ret || ret == -EALREADY)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> kernel </tag>
            
            <tag> serial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim快捷操作</title>
      <link href="/2024/07/02/vim%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/07/02/vim%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="快速定位"><a href="#快速定位" class="headerlink" title="快速定位"></a>快速定位</h2><ul><li>A: 跳到行尾并开启编辑模式</li><li>0: 跳到行首</li><li>$: 跳到行尾</li><li>G: 跳到文件尾</li><li>gg: 跳到文件首</li><li>nG: 跳到第n行<ul><li>e.g. 50G: 跳到第50行</li></ul></li><li>nj: 向下跳n行<ul><li>e.g. 3j: 向下跳3行</li></ul></li><li>nk: 向上跳n行<ul><li>e.g. 3k: 向上跳3行</li></ul></li><li>nw: 向后跳n个单词<ul><li>e.g. 3w: 向后跳3个单词</li></ul></li><li>nb: 向前跳n个单词<ul><li>e.g. 3b: 向前跳3个单词</li></ul></li><li>&#x2F;: 搜索<ul><li>e.g. &#x2F;123: 搜索123文本</li><li>按n和N向下和向上</li></ul></li></ul><h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><ul><li>%: 在pair中来回跳<ul><li>e.g. (123)  在（和）之间来回跳</li></ul></li><li>ci + left-pair: 删除pair中的内容并且开启编辑模式<ul><li>e.g. ci+(: 删除（）中的内容并且开启编辑模式</li></ul></li><li>di + left-pair: 删除pair中的内容<ul><li>e.g. di+(: 删除（）中的内容</li></ul></li><li>yi + left-pair: 复制pair中的内容<ul><li>e.g. yi+(: 复制（）中的内容</li></ul></li><li>vi + left-pair: 选中pair中的内容<ul><li>e.g. vi+(: 选中（）中的内容</li></ul></li><li>va + left-pair: 删除pair中的内容包括pair<ul><li>e.g. va+(: 删除（）中的内容包括（）</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用vim阅读代码</title>
      <link href="/2024/07/02/%E4%BD%BF%E7%94%A8vim%E9%98%85%E8%AF%BB%E4%BB%A3%E7%A0%81/"/>
      <url>/2024/07/02/%E4%BD%BF%E7%94%A8vim%E9%98%85%E8%AF%BB%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>Ubuntu22.04</li><li>VIM - Vi IMproved 8.2 (2019 Dec 12, 编译于 May 03 2024 02:37:51)</li></ul><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在<code>Linux</code>环境下，<code>Source Insight</code>只能在Wine环境下运行，显得并没有那么好用，于是便有了本文，使用<code>Vim+Ctags+Cscope</code>来进行阅读代码。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装Ctags"><a href="#安装Ctags" class="headerlink" title="安装Ctags"></a>安装Ctags</h3><p>打开终端，运行以下命令安装 <code>ctags</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install exuberant-ctags</span><br></pre></td></tr></table></figure><p>如果你希望使用 <code>universal-ctags</code>（这是一个更新和维护更积极的分支），则可以安装它：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install universal-ctags</span><br></pre></td></tr></table></figure><h3 id="安装Cscope"><a href="#安装Cscope" class="headerlink" title="安装Cscope"></a>安装Cscope</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install cscope</span><br></pre></td></tr></table></figure><h2 id="配置与使用"><a href="#配置与使用" class="headerlink" title="配置与使用"></a>配置与使用</h2><h3 id="配置Ctags"><a href="#配置Ctags" class="headerlink" title="配置Ctags"></a>配置Ctags</h3><p>在项目根目录执行如下命令生成<code>tags</code>文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctags -R .  </span><br></pre></td></tr></table></figure><p>可以发现在项目根目录下多了如下文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">ls</span> tags</span><br><span class="line">tags</span><br></pre></td></tr></table></figure><p>为了能够在项目中使用该文件作为<code>tag</code>索引，则在<code>~/.vimrc</code>中增加如下配置，这个配置的目的是为了能够让<code>vim</code>在项目的任意目录中都能够找到<code>tags</code>的配置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> tags=./tags;/</span><br></pre></td></tr></table></figure><h3 id="使用Ctags"><a href="#使用Ctags" class="headerlink" title="使用Ctags"></a>使用Ctags</h3><ul><li><code>ctrl+t </code>:在跳转之后，按下ctrl+t,vim就会返回之前的跳转位置</li><li><code>ctrl+] </code>:将光标移动到函数或变量名上，按下ctrl+],vim会自动跳转到该函数或者变量的定义处</li><li><code>ctrl + w + ctrl + ]</code>: 将光标移动到函数或变量名上，按下快捷键,vim会自动跳转到该函数或者变量的定义处并垂直拆分标签页</li><li><code>ctrl +w +w</code>: 在刚才垂直拆分的标签页中来回跳转光标</li><li><code>ctrl + w + c</code>: 关闭一个垂直拆分的标签页</li><li><code>:tags </code>: 输入:tags, vim会显示所有可跳转的列表</li></ul><h3 id="配置Cscope"><a href="#配置Cscope" class="headerlink" title="配置Cscope"></a>配置Cscope</h3><p>在项目根目录执行如下命令生成<code>tags</code>文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cscope -Rbq</span><br></pre></td></tr></table></figure><p>可以发现在项目根目录下多了如下文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">ls</span> cscope*</span><br><span class="line">cscope.in.out  cscope.out  cscope.po.out</span><br></pre></td></tr></table></figure><p>为了能够在项目中使用这些文件作为索引，则在下载<code>cscope</code>的官方配置文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -O ~/.cscope_maps.vim https://cscope.sourceforge.net/cscope_maps.vim</span><br></pre></td></tr></table></figure><p>并且在<code>.vimrc</code>中增加配置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.cscope_maps.vim</span><br></pre></td></tr></table></figure><h3 id="使用Cscope"><a href="#使用Cscope" class="headerlink" title="使用Cscope"></a>使用Cscope</h3><p>在<code>vim</code>中光标放到一个<code>symbol</code>上，随后使用<code>vim</code>中配置的快捷键（details: ~&#x2F;.cscope_maps.vim）。</p><ul><li>a: 查找一个符合被赋值(assigned)的地方</li><li>c: 查找调用(call)这个函数的函数</li><li>d: 查找被这个函数调用(called)的函数</li><li>e: 使用(egrep)搜索进行查找</li><li>f: 按照文件(file)名查找</li><li>g: 查找一个符合的全局(global)定义</li><li>i: 查找包含(include)这个文件的文件</li><li>s: 查找一个符合(symbol)的引用</li><li>t: 查找这个文本(text)字符串的所有出现位置</li></ul><p>e.g.: <code>ctrl + \ + c</code>: 搜索光标处的<code>symbol</code>在工程中被谁调用了。</p><h2 id="创建脚本"><a href="#创建脚本" class="headerlink" title="创建脚本"></a>创建脚本</h2><p>为了每次创建<code>cscope</code>和<code>ctag</code>索引的方便快捷性，可以在<code>/usr/local/bin</code>目录下创建一个名为<code>ctcs</code>的脚本，脚本内容如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ctcs</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">star</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    ctags -R *   </span><br><span class="line">    <span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;ctags successfully!&quot;</span></span><br><span class="line">    <span class="keyword">fi</span>  </span><br><span class="line">    cscope -qbR </span><br><span class="line">    <span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;cscope successfully!&quot;</span></span><br><span class="line">    <span class="keyword">fi</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">del</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> [ -f tags -o -f cscope.out -o -f cscope.po.out -o -f cscope.in.out ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">rm</span> -f tags  &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;clean tags ok!&quot;</span></span><br><span class="line">        <span class="built_in">rm</span> -f cscope.* &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;clean cscope.* files ok!&quot;</span></span><br><span class="line">    <span class="keyword">fi</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">    -r) </span><br><span class="line">        del </span><br><span class="line">        star</span><br><span class="line">        ;;  </span><br><span class="line">    -d) </span><br><span class="line">        del </span><br><span class="line">        ;;  </span><br><span class="line">    *)  </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;usage : ctcs -r|-d&quot;</span>   </span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>随后使用如下命令赋予执行权限：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/ctcs</span><br></pre></td></tr></table></figure><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://cscope.sourceforge.net/cscope_maps.vim">https://cscope.sourceforge.net/cscope_maps.vim</a><br><a href="https://stackoverflow.com/questions/563616/vim-and-ctags-tips-and-tricks">https://stackoverflow.com/questions/563616/vim-and-ctags-tips-and-tricks</a><br><a href="https://bigeast.github.io/Source_Code_Tree_Navigation_in_Vim.html">https://bigeast.github.io/Source_Code_Tree_Navigation_in_Vim.html</a><br><a href="https://segmentfault.com/a/1190000044591252">https://segmentfault.com/a/1190000044591252</a><br><a href="https://blog.csdn.net/zg_hover/article/details/78917921">https://blog.csdn.net/zg_hover/article/details/78917921</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于CloudFlare搭建Docker镜像</title>
      <link href="/2024/07/01/%E5%9F%BA%E4%BA%8ECloudFlare%E6%90%AD%E5%BB%BADocker%E9%95%9C%E5%83%8F-1/"/>
      <url>/2024/07/01/%E5%9F%BA%E4%BA%8ECloudFlare%E6%90%AD%E5%BB%BADocker%E9%95%9C%E5%83%8F-1/</url>
      
        <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>一个域名</li><li>一个CloudFlare账号</li></ul><h2 id="域名修改DNS"><a href="#域名修改DNS" class="headerlink" title="域名修改DNS"></a>域名修改DNS</h2><p>PS:如果该站点已在CloudFlare中存在，请忽略该步骤。</p><p>首先在CloudFlare中添加一个站点，域名就写你自己的域名：</p><p><img src="/images/pasted-0.png" alt="upload successful"></p><p>添加好之后在下面我们可以看到需要修改的DNS为：</p><p><img src="/images/pasted-1.png" alt="upload successful"></p><p>这里我是使用的腾讯云的域名，所以以腾讯这里为例，修改好后如下图：</p><p><img src="/images/pasted-2.png" alt="upload successful"></p><h2 id="使用github部署"><a href="#使用github部署" class="headerlink" title="使用github部署"></a>使用github部署</h2><p>首先fork该仓库：<a href="https://github.com/ciiiii/cloudflare-docker-proxy">https://github.com/ciiiii/cloudflare-docker-proxy</a></p><p>将<code>src/index.js</code>、<code>wrangler.toml</code>的<code>libcuda.so</code>替换成你的域名，以<code>src/index.js</code>为例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim src/index.js</span><br><span class="line"></span><br><span class="line">:%s/libcuda.so/your-url/g</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改完成后push（如果在网页ui操作忽略该步骤）。</p><p>随后点击Deploy with works即可开始部署。</p><p>PS:<br>如果Delpoy with works有问题，请修改readme中该按钮的超链接为你自己的仓库地址。</p><h2 id="Deploy-with-works"><a href="#Deploy-with-works" class="headerlink" title="Deploy with works"></a>Deploy with works</h2><p>Account id就是<a href="https://dash.cloudflare.com/%E4%B8%AD/%E5%90%8E%E9%9D%A2%E7%9A%84%E9%82%A3%E4%B8%80%E9%83%A8%E5%88%86%E3%80%82">https://dash.cloudflare.com/中/后面的那一部分。</a><br>Token需要自己在该网址进行创建：<a href="https://dash.cloudflare.com/profile/api-tokens">https://dash.cloudflare.com/profile/api-tokens</a><br>token模板就选择<code>编辑 Cloudflare Workers</code>即可。</p>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
